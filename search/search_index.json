{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u4ec0\u4e48\u662f\u7eff\u6d32\uff1f \u00b6 \u7b80\u4f53\u4e2d\u6587 | English OpenOasis\uff0c\u7eff\u6d32\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u771f\u5b9e\u4e16\u754c\u7269\u7406\u6a21\u578b\u7684\u6570\u503c\u6a21\u62df\u9879\u76ee\uff0c\u5e0c\u671b\u80fd\u5e2e\u52a9\u63d0\u9ad8\u5bf9\u4e8e\u7406\u8bba\u6982\u5ff5\u3001 \u6570\u503c\u65b9\u6cd5\u548c\u73b0\u5b9e\u6570\u636e\u7684\u7406\u89e3\uff1b\u540c\u65f6\uff0c\u63d0\u4f9b\u4e00\u4e2a\u6807\u51c6\u5316\u7684\u5e73\u53f0\u6765\u5c1d\u8bd5\u65b0\u60f3\u6cd5\u548c\u65b0\u65b9\u6848\u3002 \u7eff\u6d32 \u9879\u76ee\u57fa\u4e8e OpenMI v2.0 \u63a5\u53e3\u89c4\u8303\uff0c\u5b9e\u73b0\u4e00\u5957\u901a\u7528\u7684\u6570\u503c\u6a21\u578b\u5f00\u53d1\u4ee5\u53ca\u96c6\u6210\u6846\u67b6\uff0c \u4e0d\u5c40\u9650\u4e8e\u7279\u5b9a\u9886\u57df\u3002\u5c31\u5f53\u524d\u6765\u8bf4\uff0c\u9879\u76ee\u4e3b\u8981\u5e94\u7528\u4e8e\u533a\u57df\u5185\u6d41\u4f53\u6d41\u52a8\u3001\u70ed\u91cf\u6d41\u52a8\u7b49\u8fc7\u7a0b\u3002\u9664\u6b64\u4e4b\u5916\uff0c \u6211\u4eec\u4e5f\u79ef\u6781\u63a2\u7d22\u6df1\u5ea6\u5b66\u4e60\u548c\u5f3a\u5316\u5b66\u4e60\u7b49\u65b0\u601d\u8def\u5728\u5feb\u901f\u9884\u62a5\u3001\u667a\u80fd\u51b3\u7b56\u7b49\u65b9\u9762\u7684\u5e94\u7528\u3002 \u7eff\u6d32 \u9879\u76ee\u91c7\u7528 C++17 \u5f00\u53d1\u6570\u503c\u7b97\u6cd5\u6a21\u578b\u5185\u6838\uff0c\u540c\u65f6\u91c7\u7528 Python 3.x \u5f00\u53d1\u667a\u80fd\u5f15\u64ce\u5305\u548c\u6570\u636e\u5de5\u5177\uff0c \u79ef\u6781\u5c1d\u8bd5\u84ec\u52c3\u53d1\u5c55\u7684\u4eba\u5de5\u667a\u80fd\u6280\u672f\u3002 \u5982\u4f55\u4f7f\u7528\uff1f \u00b6 \u73b0\u5728\u52a0\u5165\uff01 \u00b6 \u66f4\u591a \u00b6","title":"brief"},{"location":"#_1","text":"\u7b80\u4f53\u4e2d\u6587 | English OpenOasis\uff0c\u7eff\u6d32\uff0c\u4f5c\u4e3a\u4e00\u4e2a\u771f\u5b9e\u4e16\u754c\u7269\u7406\u6a21\u578b\u7684\u6570\u503c\u6a21\u62df\u9879\u76ee\uff0c\u5e0c\u671b\u80fd\u5e2e\u52a9\u63d0\u9ad8\u5bf9\u4e8e\u7406\u8bba\u6982\u5ff5\u3001 \u6570\u503c\u65b9\u6cd5\u548c\u73b0\u5b9e\u6570\u636e\u7684\u7406\u89e3\uff1b\u540c\u65f6\uff0c\u63d0\u4f9b\u4e00\u4e2a\u6807\u51c6\u5316\u7684\u5e73\u53f0\u6765\u5c1d\u8bd5\u65b0\u60f3\u6cd5\u548c\u65b0\u65b9\u6848\u3002 \u7eff\u6d32 \u9879\u76ee\u57fa\u4e8e OpenMI v2.0 \u63a5\u53e3\u89c4\u8303\uff0c\u5b9e\u73b0\u4e00\u5957\u901a\u7528\u7684\u6570\u503c\u6a21\u578b\u5f00\u53d1\u4ee5\u53ca\u96c6\u6210\u6846\u67b6\uff0c \u4e0d\u5c40\u9650\u4e8e\u7279\u5b9a\u9886\u57df\u3002\u5c31\u5f53\u524d\u6765\u8bf4\uff0c\u9879\u76ee\u4e3b\u8981\u5e94\u7528\u4e8e\u533a\u57df\u5185\u6d41\u4f53\u6d41\u52a8\u3001\u70ed\u91cf\u6d41\u52a8\u7b49\u8fc7\u7a0b\u3002\u9664\u6b64\u4e4b\u5916\uff0c \u6211\u4eec\u4e5f\u79ef\u6781\u63a2\u7d22\u6df1\u5ea6\u5b66\u4e60\u548c\u5f3a\u5316\u5b66\u4e60\u7b49\u65b0\u601d\u8def\u5728\u5feb\u901f\u9884\u62a5\u3001\u667a\u80fd\u51b3\u7b56\u7b49\u65b9\u9762\u7684\u5e94\u7528\u3002 \u7eff\u6d32 \u9879\u76ee\u91c7\u7528 C++17 \u5f00\u53d1\u6570\u503c\u7b97\u6cd5\u6a21\u578b\u5185\u6838\uff0c\u540c\u65f6\u91c7\u7528 Python 3.x \u5f00\u53d1\u667a\u80fd\u5f15\u64ce\u5305\u548c\u6570\u636e\u5de5\u5177\uff0c \u79ef\u6781\u5c1d\u8bd5\u84ec\u52c3\u53d1\u5c55\u7684\u4eba\u5de5\u667a\u80fd\u6280\u672f\u3002","title":"\u4ec0\u4e48\u662f\u7eff\u6d32\uff1f"},{"location":"#_2","text":"","title":"\u5982\u4f55\u4f7f\u7528\uff1f"},{"location":"#_3","text":"","title":"\u73b0\u5728\u52a0\u5165\uff01"},{"location":"#_4","text":"","title":"\u66f4\u591a"},{"location":"OpenOasisDevTips/","text":"\u7eff\u6d32\u5f00\u53d1\u5c0f\u8d34\u58eb \u00b6 OpenOasis Development Tips \u7eff\u6d32\u9879\u76ee\u65e8\u5728\u7528\u4e8e\u5b66\u672f\u4ee5\u53ca\u6559\u5b66\u7528\u9014\uff0c\u56e0\u6b64\u5728\u8bbe\u8ba1\u5404\u79cd\u7b97\u6cd5\u548c\u65b9\u6848\u7684\u5b9e\u73b0\u7ec6\u8282\u65f6\uff0c\u7f16\u7801\u7684\u6e05\u6670\u5ea6\u662f\u91cd\u4e2d\u4e4b\u91cd\u3002 \u5c3d\u7ba1\u5982\u6b64\uff0c\u5b83\u7684\u6240\u6709\u6570\u503c\u548c\u7b97\u6cd5\u5728\u5f88\u591a\u65b9\u9762\u90fd\u4e0e\u9762\u5411\u5de5\u4e1a\u7684 CFD \u4ee3\u7801\u4e2d\u4f7f\u7528\u7684\u6570\u503c\u548c\u7b97\u6cd5\u76f8\u4f3c\uff0c\u5e76\u9f13\u52b1\u8be6\u5c3d\u7684\u6587\u6863\u8bf4\u660e\u3002 Tip1-\u5173\u4e8e\u6a21\u578b\u5f00\u53d1\u8fc7\u7a0b\u548c\u6587\u6863\uff1a\u4e00\u4e2a\u5f85\u5b8c\u5584\u7684\u5f00\u53d1\u5efa\u8bae Tip2-\u5173\u4e8e\u9879\u76ee\u7684\u7ec4\u7ec7\u7ed3\u6784 Tip3-\u5173\u4e8e\u9879\u76ee\u7684\u53d1\u5e03\u6d41\u7a0b Tip4-\u5173\u4e8e\u9879\u76ee\u7684\u7f16\u7801\u98ce\u683c Tipx-\u4e34\u65f6\u8bf4\u660e Tip1: \u5173\u4e8e\u6a21\u578b\u5f00\u53d1\u9636\u6bb5\u7684\u5212\u5206\u548c\u6587\u6863\u8981\u6c42 \u00b6 \u4e00\u4e2a\u6a21\u578b\u7684\u5f00\u53d1\u8fc7\u7a0b\u53ef\u80fd\u4f1a\u7ecf\u5386\u4ee5\u4e0b\u51e0\u4e2a\u9636\u6bb5\uff1a 1 st : \u7b2c\u4e00\u9636\u6bb5 \u63d0\u51fa\u6a21\u578b\u60f3\u6cd5\uff0c\u8bf4\u660e\u5f00\u53d1\u76ee\u7684\u6216\u610f\u4e49\uff0c\u63d0\u4f9b\u4e00\u4e9b\u57fa\u7840\u5f00\u53d1\u8d44\u6599\u3001\u65b9\u5411\u6216\u601d\u8def\uff1b\u901a\u5e38\u6765\u8bf4\uff0c 1st \u4ecd\u5904\u4e8e\u524d\u671f\u8ba8\u8bba\u9636\u6bb5\uff0c\u53ef\u4ee5\u5728\u9879\u76ee\u4ed3\u5e93\u3001\u77e5\u4e4e\u95ee\u9898\u3001\u8bfe\u9898\u5c0f\u7ec4\u6216\u8005\u5176\u4ed6\u5e73\u53f0\u63d0\u51fa\uff0c \u4f5c\u4e3a\u4e00\u4e2a issue \u3001\u4e00\u4e2a \u63d0\u95ee \u3001\u4e00\u4e2a \u62a5\u544a \u3001\u4e00\u4e2a \u52a8\u6001 \u53d1\u5e03\u3002 2 nd : \u7b2c\u4e8c\u9636\u6bb5 \u8bbe\u8ba1\u6a21\u578b\u7b97\u6cd5\uff0c\u89e3\u91ca\u7406\u8bba\u4f9d\u636e\uff0c\u63d0\u4f9b\u7b97\u6cd5\u8be6\u7ec6\u8bbe\u8ba1\uff08\u8ba1\u7b97\u94fe\u8def\u95ed\u73af\uff09\u3002 \u8fd9\u4e2a\u9636\u6bb5\u53ef\u80fd\u4e3b\u8981\u805a\u7126\u5728\u5982\u4f55\u4f7f\u60f3\u6cd5\u843d\u5730\uff0c\u600e\u4e48\u6837\u6765\u8bbe\u8ba1\u4e00\u4e2a\u5b8c\u6574\u7684\u8ba1\u7b97\u903b\u8f91\u6216\u8ba1\u7b97\u94fe\u8def\uff1f \u8fd9\u4e2a\u9636\u6bb5\u53ef\u80fd\u8fd8\u9700\u8981\u521d\u6b65\u7684\u539f\u578b\u5b9e\u73b0\uff0c\u6572\u4ee3\u7801\u548c\u63a8\u516c\u5f0f\u4ea4\u7ec7\u8fdb\u884c\u3002 3 rd : \u7b2c\u4e09\u9636\u6bb5 \u5b9e\u65bd\u5f00\u53d1\u65b9\u6848\uff0c\u5b9a\u4e49\u6a21\u578b\u6570\u636e\u548c\u63a5\u53e3\uff0c\u5b8c\u6210\u6a21\u5757\u5f00\u53d1\u548c\u5355\u5143\u6d4b\u8bd5\u3002 \u8fdb\u5165 3rd \u9636\u6bb5\u901a\u5e38\u8868\u660e\u6a21\u578b\u7684\u7b97\u6cd5\u5df2\u7ecf\u57fa\u672c\u7a33\u5b9a\uff0c\u5f00\u59cb\u5de5\u7a0b\u9879\u76ee\u5f00\u53d1\u3002\u4e00\u822c\u7684\u5efa\u8bae\u662f\uff0c\u7740\u624b\u7f16\u7801\u524d\u68b3\u7406\u529f\u80fd\u6a21\u5757\u5173\u7cfb\uff0c\u786e\u5b9a\u6a21\u5757\u96c6\u6210\u63a5\u53e3\uff0c\u8bbe\u8ba1\u6570\u636e\u7ed3\u6784\uff1b\u540c\u65f6\uff0c\u5728\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u9075\u5faa\u4e00\u5957\u4ee3\u7801\u89c4\u8303\u548c\u683c\u5f0f\u5316\u65b9\u6848\uff0c\u5e76\u53ca\u65f6\u5b8c\u6210\u5355\u5143\u6d4b\u8bd5\u3001\u96c6\u6210\u6d4b\u8bd5\uff0c\u6ce8\u610f\u4ee3\u7801\u8986\u76d6\u5ea6\u3002 4 th : \u7b2c\u56db\u9636\u6bb5 \u901a\u8fc7\u6a21\u578b\u8bc4\u4f30\u65b9\u6848\uff0c\u6d4b\u8bd5\u6a21\u578b\u51c6\u786e\u6027\u548c\u7a33\u5b9a\u6027\uff0c\u6d4b\u8bd5\u53c2\u6570\u654f\u611f\u6027\u3002 \u5728\u53ef\u9760\u7684\u5355\u5143\u6d4b\u8bd5\u57fa\u7840\u4e0a\uff0c\u8fdb\u4e00\u6b65\u5730\u8fdb\u884c\u76f8\u5bf9\u5145\u5206\u7684\u6a21\u578b\u7528\u4f8b\u6d4b\u8bd5(\u9700\u8981\u8986\u76d6\u53ef\u9884\u89c1\u7684\u5e38\u89c1\u573a\u666f\u548c\u90e8\u5206\u6781\u7aef\u573a\u666f)\uff0c\u6d4b\u8bd5\u6a21\u5757\u7684\u7a33\u5b9a\u6027\u3001\u9002\u7528\u6027\uff0c\u5206\u6790\u6a21\u5757\u7684\u53c2\u6570\u654f\u611f\u6027\uff0c\u8fdb\u4e00\u6b65\u5730\u6d4b\u8bd5\u6a21\u5757\u7684\u51c6\u786e\u6027\u53ca\u6027\u80fd\u8868\u73b0\u3002 \u9664\u6b64\u4e4b\u5916\uff0c\u53ef\u80fd\u8fd8\u5305\u62ec\uff1a 5 th : \u7ef4\u62a4\u9636\u6bb5 \u4fee\u590d\u6a21\u5757bug\u3001\u5347\u7ea7\u6a21\u5757\u529f\u80fd\u3001\u91cd\u6784\u6a21\u5757\u7b49\u540e\u671f\u7ef4\u62a4\u3002 \u6a21\u578b\u6587\u6863 \u4e3a\u4e86\u63d0\u9ad8\u6a21\u578b\u548c\u9879\u76ee\u7684\u53ef\u9760\u6027\u548c\u53ef\u7ef4\u62a4\u6027\uff0c\u4e00\u4e2a\u6a21\u578b\u7ec4\u4ef6\u7684\u6587\u6863\u5efa\u8bae\u5305\u542b\uff1a \u7b97\u6cd5\u8be6\u7ec6\u8bbe\u8ba1 \uff0c\u8bf4\u660e\u7b97\u6cd5\u539f\u7406\u548c\u524d\u63d0\u5047\u8bbe\uff0c\u63d0\u4f9b\u5b8c\u6574\u7684\u8ba1\u7b97\u8fc7\u7a0b\u4ee5\u53ca\u6d89\u53ca\u7684\u53d8\u91cf\u5b9a\u4e49\uff1b \u5f00\u53d1\u63a5\u53e3\u8bf4\u660e \uff0c\u8bf4\u660e\u7ec4\u4ef6\u63a5\u53e3\uff0c\u5305\u62ec\u63a5\u53e3\u53c2\u6570\u3001\u63a5\u53e3\u529f\u80fd\u548c\u53ef\u80fd\u7684\u5f02\u5e38\u7b49\uff1b \u6d4b\u8bd5\u8bc4\u4f30\u62a5\u544a \uff0c\u63d0\u4f9b\u5404\u7c7b\u6d4b\u8bd5\u7ed3\u679c\u5206\u6790\u62a5\u544a\uff1b \u6a21\u578b\u64cd\u4f5c\u624b\u518c \uff0c\u8bf4\u660e\u6a21\u578b\u7684\u7528\u6237\u7aef\u8f93\u5165\u8f93\u51fa\u683c\u5f0f\uff0c\u6f14\u793a\u5e38\u89c1\u573a\u666f\u4e0b\u7684\u7ec4\u4ef6\u4f7f\u7528\u3002 \u805a\u7126\u4e8e\u6a21\u5757\u7684\u53ef\u9760\u6027\uff0c \u6d4b\u8bd5\u8bc4\u4f30\u62a5\u544a \u4e2d\u5e94\u8be5\u5305\u62ec\u6a21\u578b\u4e0e\u73b0\u5b9e\u7684\u4e00\u81f4\u6027\u3001\u53c2\u6570\u53ca\u524d\u63d0\u5047\u8bbe\u7684\u5f71\u54cd\u3001\u53c2\u6570\u771f\u503c\u4ee5\u53ca\u5176\u5206\u5e03\u7684\u5f71\u54cd\u5206\u6790\uff0c\u63d0\u4f9b\u6a21\u578b\u6821\u6838\u62a5\u544a\u3001\u53c2\u6570\u654f\u611f\u6027\u8bc4\u4f30\u62a5\u544a\u3001\u7f51\u683c\u76f8\u5173\u6027\u8bc4\u4f30\u62a5\u544a\uff0c\u6570\u503c\u7b97\u6cd5\u7a33\u5b9a\u6027\u8bc4\u4f30\u62a5\u544a\uff0c\u6a21\u578b\u6027\u80fd\u8bc4\u4f30\u62a5\u544a\u3002 Tip4: \u5173\u4e8e\u7eff\u6d32\u7684\u9879\u76ee\u67b6\u6784 \u00b6 OpenOasis Project Structure: +-- / | +-- DataAsst/ : \u6570\u636e\u52a9\u624b\uff0c\u7528\u4e8e\u6570\u636e\u5206\u6790\u3001\u5904\u7406\u548c\u53ef\u89c6\u5316 | +-- Doc/ : \u9879\u76ee\u6587\u6863 | +-- iAgents/ : \u6df1\u5ea6\u5b66\u4e60\u4e0e\u5f3a\u5316\u5b66\u4e60\u89e3\u51b3\u65b9\u6848\u5e93 | | +-- Spark/ : \u661f\u706b\u4eba\u5de5\u667a\u80fd\u5305 | | +-- tests/ : \u6d4b\u8bd5\u96c6 | +-- Models/ : \u6a21\u578b\u7ec4\u4ef6\u96c6\u4ee5\u53ca\u6570\u503c\u6c42\u89e3\u5668\u96c6 | | +-- CommImp/ : \u63a5\u53e3\u7684\u901a\u7528\u5b9e\u73b0 | | +-- Inc/ : \u63a5\u53e3\u6807\u51c6 | | +-- SystFluids/ : \u6d41\u4f53\u6d41\u52a8\u6a21\u578b\u96c6 | | +-- SystHeats/ : \u70ed\u91cf\u6d41\u52a8\u6a21\u578b\u96c6 | | +-- Utils/ : \u901a\u7528\u529f\u80fd\u6a21\u5757 | | +-- tests/ : \u6d4b\u8bd5\u96c6 | | +-- ThirdPart/ : \u7b2c\u4e09\u65b9\u5de5\u5177\u7bb1 | | +-- wrappers/ : c++/python\u63a5\u53e3\u5c01\u88c5 | | +-- Launcher.cpp : \u6a21\u5757\u52a8\u6001\u52a0\u8f7d\u5668 | +-- Rsrc/ : \u76f8\u5173\u8d44\u6e90 | | +-- Benchmarks/ : \u9879\u76ee\u6848\u4f8b\u6570\u636e\u96c6 | | +-- Logo/ : \u9879\u76ee\u6807\u8bc6\u7b49 | | +-- TheoryBriefs/ : \u7406\u8bba/\u6280\u672f/\u6982\u5ff5\u7b80\u4ecb \u5728\u8fd9\u4e2a\u9879\u76ee\u67b6\u6784\u8bbe\u8ba1\u4e2d\uff0c\u6570\u503c\u7b97\u6cd5\u5185\u6838\u4f4d\u4e8e Models \u76ee\u5f55\u4e0b\u3002 Inc \u76ee\u5f55\u4e0b\u5b58\u653e\u63a5\u53e3\u6807\u51c6\uff0c CommImp \u76ee\u5f55\u4e0b\u5b58\u653e\u8be5\u63a5\u53e3\u7684\u901a\u7528\u5b9e\u73b0\u65b9\u6848\uff08SDK\uff09\u3002 SystFluids \u548c SystHeats \u76ee\u5f55\u4e0b\u5b58\u653e\u57fa\u4e8e\u901a\u7528\u5b9e\u73b0\u65b9\u6848\u7684\u6d41\u4f53\u6d41\u52a8\u548c\u70ed\u91cf\u6d41\u52a8\u6a21\u578b\uff08App\uff09\uff0c Utils \u76ee\u5f55\u4e0b\u5b58\u653e\u901a\u7528\u529f\u80fd\u6a21\u5757(\u4e0d\u4f9d\u8d56\u63a5\u53e3\u6807\u51c6\u4ee5\u53ca\u4efb\u4f55\u5916\u90e8\u5b9e\u73b0\uff0c\u9664\u4e86\u7b2c\u4e09\u65b9\u5e93)\u3002 Launcher.cpp \u662f\u4e00\u4e2a\u6a21\u5757\u52a8\u6001\u52a0\u8f7d\u5668\uff0c\u7528\u4e8e\u52a8\u6001\u52a0\u8f7d\u7b26\u5408\u63a5\u53e3\u6807\u51c6\u7684\u6a21\u5757\uff0c\u5e76\u63d0\u4f9b\u7edf\u4e00\u7684\u63a5\u53e3\u8c03\u7528\u65b9\u5f0f\u3002 CommImp \u4e2d\u8fd8\u6709\u6b21\u7ea7\u76ee\u5f55\uff0c\u5305\u62ec: DevSupports (\u7528\u4e8e\u62d3\u5c55\u63a5\u53e3\u5b9a\u4e49\u548c\u5b9e\u73b0\uff0c\u63d0\u4f9b\u63a5\u53e3\u5bf9\u8c61\u7684\u8f85\u52a9\u51fd\u6570)\uff0c IO (\u7528\u4e8e\u63d0\u4f9b\u7edf\u4e00\u7684IO\u63a5\u53e3\uff0c\u4e0d\u4f9d\u8d56\u63a5\u53e3\u6807\u51c6)\uff0c Numeric (\u7528\u4e8e\u63d0\u4f9b\u7ed9\u96f7\u6570\u503c\u7b97\u6cd5\u6c42\u89e3\u5668\u5b9e\u73b0\uff0c\u4e0d\u4f9d\u8d56\u63a5\u53e3\u6807\u51c6)\uff0c Spatial \u548c Temporal (\u7528\u4e8e\u63d0\u4f9b\u7a7a\u95f4\u548c\u65f6\u95f4\u79bb\u6563\u7684\u6570\u636e\u5b9a\u4e49\u548c\u5904\u7406\uff0c\u4e0d\u4f9d\u8d56\u63a5\u53e3\u6807\u51c6)\u3002 Tip3: \u5173\u4e8e\u9879\u76ee\u7684\u53d1\u5e03\u6d41\u7a0b \u00b6 \u9879\u76ee\u6682\u5b9a\u53d1\u5e03\u5728 GitHub\uff1b\u91c7\u7528 Git \u4f5c\u4e3a\u534f\u4f5c\u5f00\u53d1\u548c\u7248\u672c\u63a7\u5236\u5de5\u5177\uff1b\u91c7\u7528 Git Flow \u5f00\u53d1\u6a21\u5f0f\uff1b\u7248\u672c\u53f7\u91c7\u7528 major.minor.patch \u683c\u5f0f\u3002 \u9879\u76ee\u6682\u5b9a\u6bcf\u5e74\u79cb\u5206\u53d1\u5e03\u5927\u7248\u672c\u66f4\u65b0\uff08LTS \u7248\u672c\uff09\uff0c\u5e76\u63d0\u524d\u4e00\u4e2a\u6708\u51bb\u7ed3\u5408\u5e76\u8bf7\u6c42\u3001\u6267\u884c\u56de\u5f52\u6d4b\u8bd5\u3002 \u5f00\u53d1\u6a21\u5f0f \u7b80\u5355\u8bf4\u6765\uff0cGit Flow \u6a21\u5f0f\u5c31\u662f\u7ed9\u539f\u672c\u666e\u666e\u901a\u901a\u7684\u5206\u652f\u8d4b\u4e88\u4e86\u4e0d\u540c\u7684\u300c\u804c\u8d23\u300d\uff1a main - \u4e3b\u5206\u652f \u6240\u6709\u63d0\u4f9b\u7ed9\u7528\u6237\u4f7f\u7528\u7684\u6b63\u5f0f\u7248\u672c\uff0c\u90fd\u5728\u8fd9\u4e2a\u4e3b\u5206\u652f\u4e0a\u53d1\u5e03\u3002 \u5f00\u53d1\u8005\u5728\u6b64\u5206\u652f \u4e0d\u53ef\u8fdb\u884c push \u64cd\u4f5c\u3002 dev - \u5f00\u53d1\u5206\u652f \u65e5\u5e38\u5f00\u53d1\u6240\u4f7f\u7528\u7684\u5206\u652f\uff0c\u5f00\u53d1\u8005\u5b8c\u6210\u7684\u9636\u6bb5\u6027\u529f\u80fd\u6a21\u5757\u5c06\u9996\u5148\u88ab\u5408\u5e76\u5230\u6b64\u5206\u652f\u3002 \u5f00\u53d1\u8005\u5728\u6b64\u5206\u652f \u4e0d\u53ef\u8fdb\u884c push \u64cd\u4f5c\uff0c\u53ea\u80fd\u901a\u8fc7 Pull Request \u7684\u65b9\u5f0f\u5c06\u4e2a\u4eba\u5206\u652f\u5408\u5e76\u5230\u6b64\u5206\u652f\u3002 \u5f00\u53d1\u8fc7\u7a0b\u4e2d\uff0c\u8981\u7ecf\u5e38\u4e0e\u6b64\u5206\u652f\u4fdd\u6301\u540c\u6b65\u3002 feature/xxx - \u7279\u6027\u5206\u652f \u7528\u4e8e\u67d0\u4e2a\u529f\u80fd\u6a21\u5757\u7684\u5f00\u53d1\uff0c\u5f53\u8be5\u529f\u80fd\u6a21\u5757\u5f00\u53d1\u4efb\u52a1\u5b8c\u6210\u540e\uff0c\u901a\u8fc7 Pull Request \u7684\u5f62\u5f0f\u8fdb\u884c\u8bf7\u6c42\u5408\u5e76\uff0c\u7ba1\u7406\u5458 Code Review \u901a\u8fc7\u540e\uff0c\u5c06\u8be5\u5206\u652f\u5408\u5e76\u5230 dev \u5206\u652f\uff1b\u6b64\u540e\uff0c\u8be5\u5206\u652f\u5c06\u88ab\u5220\u9664\u3002 \u6b64\u7c7b\u5206\u652f\u7531\u5f00\u53d1\u8005\u4e2a\u4eba\u7ba1\u7406\u548c\u4f7f\u7528\uff0c\u53ef\u4ee5\u8fdb\u884c push \u64cd\u4f5c\u3002 \u5f00\u53d1\u8fc7\u7a0b\u4e2d\uff0c\u8981\u7ecf\u5e38\u4e0e dev \u5206\u652f\u4fdd\u6301\u540c\u6b65\u3002 hotfix/xxx - \u8865\u4e01\u5206\u652f \u7528\u4e8e\u7d27\u6025\u4fee\u590d Bug \u7684\u5206\u652f\uff0c\u53ef\u4ee5\u7531 main \u6216 develop \u5206\u652f\u521b\u5efa\u3002 \u4e00\u65e6\u4fee\u590d\u5b8c\u6210\uff0c\u5c31\u5408\u5e76\u5230 main \u6216 dev \u5206\u652f\uff08\u4ec5\u80fd\u901a\u8fc7 Pull Request \u7684\u65b9\u5f0f\uff09\uff0c\u7136\u540e\u5220\u9664\u3002 release - \u53d1\u5e03\u5206\u652f \u53d1\u5e03\u5b9a\u671f\u8981\u4e0a\u7ebf\u7684\u529f\u80fd\uff0c\u6b64\u5206\u652f\u4ea6\u662f\u56e2\u961f\u5185\u90e8\u6d4b\u8bd5\u3001\u9636\u6bb5\u6027\u5de5\u4f5c\u9a8c\u8bc1\u6240\u4f7f\u7528\u7684\u5206\u652f\u3002 \u5982\u679c\u53d1\u73b0\u4e86 bug\uff0c\u76f8\u5e94\u7684\u5c31\u5728 release \u5206\u652f\u4e0a\u6216\u57fa\u4e8e release \u5206\u652f\u521b\u5efa\u4e00\u4e2a\u5206\u652f\u8fdb\u884c\u4fee\u590d\uff0c\u7136\u540e\u91cd\u65b0\u63d0\u4ea4\u6d4b\u8bd5\u3002 \u4e00\u65e6\u6d4b\u8bd5\u5b8c\u6210\uff0c\u5c31\u5408\u5e76\u5230 main \u6216 dev \u5206\u652f\uff08\u4ec5\u80fd\u901a\u8fc7 Pull Request \u7684\u65b9\u5f0f\uff09\uff0c\u7136\u540e\u5220\u9664\u3002 \u5bf9\u4e8e\u957f\u671f\u652f\u6301\u7248\u672c(LTS)\uff0c\u4fdd\u7559\u5176release\u5206\u652f\uff0c\u5e76\u5728\u7ef4\u62a4\u671f\u5185\u63d0\u4f9bbug\u4fee\u590d\u652f\u6301\u3002 \u8d1f\u8d23\u67d0\u4e2a\u529f\u80fd\u7684\u5f00\u53d1\u4eba\u5458\u521b\u5efa\u4e00\u4e2a\u5bf9\u5e94\u7684\u672c\u5730 feature \u5206\u652f\uff0c\u5e76\u505a\u4e00\u4e9b\u521d\u59cb\u5316\u5de5\u4f5c\u4e4b\u540e\u5c31\u63a8\u9001\u521b\u5efa\u8fdc\u7a0b\u5206\u652f\u3002\u529f\u80fd\u5f00\u53d1\u5b8c\u5e76\u81ea\u6d4b\u4e4b\u540e\uff0c\u5148\u5207\u6362\u5230 dev \u5206\u652f\u5c06\u6700\u65b0\u7684\u4ee3\u7801\u62c9\u53d6\u4e0b\u6765\uff0c\u518d\u5207\u6362\u56de\u81ea\u5df1\u8d1f\u8d23\u7684 feature \u5206\u652f\u628a dev \u5206\u652f\u7684\u4ee3\u7801\u5408\u5e76\u8fdb\u6765\u3002\u5982\u679c\u6709\u51b2\u7a81\uff0c\u89e3\u51b3\u5408\u5e76\u51b2\u7a81\u3002\u7136\u540e\uff0c\u5230 GitHub \u4e0a\u7684\u9879\u76ee\u521b\u5efa\u5408\u5e76\u8bf7\u6c42\uff08merge request\uff09\u3002 \u9879\u76ee\u8d1f\u8d23\u4eba\u5728\u6536\u5230\u5408\u5e76\u8bf7\u6c42\u65f6\uff0c\u8fdb\u884c\u4ee3\u7801\u5ba1\u6838\uff1b\u6709\u95ee\u9898\u5c31\u53cd\u9988\u7ed9\u8d1f\u8d23\u5f00\u53d1\u7684\u4eba\u5458\u53bb\u4fee\u6539\uff0c\u6ca1\u6709\u5c31\u63a5\u53d7\u8bf7\u6c42\u5e76\u5220\u9664\u5bf9\u5e94\u7684 feature \u5206\u652f\u3002 \u5728\u5c06\u67d0\u6b21\u53d1\u5e03\u7684\u6240\u9700\u529f\u80fd\u5168\u90e8\u5f00\u53d1\u5b8c\u6210\u65f6\uff0c\u51bb\u7ed3\u5408\u5e76\u8bf7\u6c42\uff0c\u5f00\u59cb\u4ea4\u4ed8\u53d1\u5e03\u6d4b\u8bd5\u3002\u53d1\u5e03\u6d4b\u8bd5\u65f6\u521b\u5efa\u4e00\u4e2a release \u5206\u652f\u90e8\u7f72\u5230\u6d4b\u8bd5\u73af\u5883\u8fdb\u884c\u6d4b\u8bd5\uff1b\u82e5\u53d1\u73b0\u4e86 bug\uff0c\u76f8\u5e94\u7684\u5f00\u53d1\u4eba\u5458\u5c31\u5728 release \u5206\u652f\u4e0a\u6216\u8005\u57fa\u4e8e release \u5206\u652f\u521b\u5efa\u4e00\u4e2a\u5206\u652f\u8fdb\u884c\u4fee\u590d\u3002release \u5206\u652f\u4e0a\u4e0d\u518d\u63a5\u53d7\u65b0\u529f\u80fd\u63d0\u4ea4\u3002 \u5f53\u786e\u4fdd\u67d0\u6b21\u53d1\u5e03\u7684\u529f\u80fd\u53ef\u4ee5\u53d1\u5e03\u65f6\uff0c\u5c06 release \u5206\u652f\u5408\u5e76\u5230 dev \u548c main \u5206\u652f\u5e76\u6253\u4e0a tag\u3002 \u5f53\u53d1\u73b0\u7ebf\u4e0a\u73af\u5883\u7684\u4ee3\u7801\u6709\u5c0f\u95ee\u9898\u6216\u8005\u505a\u4e9b\u6587\u6848\u4fee\u6539\u65f6\uff0c\u76f8\u5173\u5f00\u53d1\u4eba\u5458\u5c31\u76f4\u63a5\u4ece main \u5206\u652f\u5207\u51fa hotfix \u5206\u652f\u8fdb\u884c\u4fee\u6539\u540e\u5408\u5e76\u5230 main \u548c dev \u5206\u652f\u5e76\u6253\u4e0a tag\u3002\u5982\u679c\u662f\u76f8\u5f53\u4e25\u91cd\u7684\u95ee\u9898\uff0c\u53ef\u80fd\u5c31\u5f97\u56de\u6eda\u5230\u4e0a\u4e00\u4e2a tag \u7684\u7248\u672c\u3002 \u5206\u652f\u547d\u540d \u4e3b\u8981\u5206\u652f\u7684\u540d\u5b57\u662f\u56fa\u5b9a\u7684\uff0c\u6d3e\u751f\u5206\u652f\u662f\u9700\u8981\u81ea\u5df1\u547d\u540d\u3002\u5f3a\u70c8\u63a8\u8350\u7528\u5982\u4e0b\u5f62\u5f0f\u7684\u547d\u540d\u89c4\u8303\uff1a feature\uff1a\u6309\u7167\u529f\u80fd\u70b9\uff08\u800c\u4e0d\u662f\u9700\u6c42\uff09\u547d\u540d\uff1b release\uff1a\u7528\u53d1\u5e03\u65f6\u95f4\u547d\u540d\uff0c\u53ef\u4ee5\u52a0\u4e0a\u9002\u5f53\u7684\u524d\u7f00\uff1b hotfix\uff1a GitHub \u7684 issue \u7f16\u53f7\u6216 bug \u6027\u8d28\u7b49\u3002 \u529f\u80fd\u63d0\u4ea4 \u63d0\u4ea4\u9891\u7387 \u6bcf\u4e2a\u63d0\u4ea4\u5e94\u8be5\u53ea\u5305\u542b\u4e00\u4e2a\u903b\u8f91\u4e0a\u7684\u66f4\u6539\u6216\u4fee\u590d\uff0c\u8fd9\u6837\u53ef\u4ee5\u66f4\u5bb9\u6613\u8ffd\u8e2a\u548c\u7406\u89e3\u6bcf\u4e2a\u63d0\u4ea4\u7684\u610f\u56fe\u3002 \u5efa\u8bae\u5c06\u6bcf\u4e2acommit\u7528\u65f6\u63a7\u5236\u5728 3 \u5c0f\u65f6\u5185\uff0c\u9f13\u52b1\u63d0\u9ad8\u63d0\u4ea4\u9891\u7387\u3002 \u907f\u514d\u5c06\u591a\u4e2a\u4e0d\u76f8\u5173\u7684\u66f4\u6539\u6df7\u5408\u5728\u4e00\u4e2a\u63d0\u4ea4\u4e2d\uff0c\u4ee5\u514d\u7ed9\u4ee3\u7801\u5ba1\u67e5\u548c\u7248\u672c\u63a7\u5236\u5e26\u6765\u56f0\u6270\u3002 \u63d0\u4ea4\u4fe1\u606f\u683c\u5f0f \u63d0\u4ea4\u4fe1\u606f\u7684\u683c\u5f0f\u901a\u5e38\u662f\uff1a\u201c[\u7c7b\u578b]: \u63cf\u8ff0\u201d\u3002 \u63d0\u4ea4\u7c7b\u578b\uff08type\uff09\u6307\u8fd9\u4e2a\u63d0\u4ea4\u6240\u5c5e\u7c7b\u522b\uff0c\u53ef\u4ee5\u662ffeat\u3001fix\u3001docs\u3001style\u3001refactor\u3001test\u3001chore\u7b49\u3002 \u63cf\u8ff0\uff08description\uff09\u662f\u5bf9\u63d0\u4ea4\u7684\u7b80\u77ed\u63cf\u8ff0\uff0c\u5e94\u5c3d\u91cf\u6e05\u6670\u660e\u4e86\uff0c\u7a81\u51fa\u5173\u952e\u4fe1\u606f\u3002 \u63d0\u4ea4\u4fe1\u606f\u5185\u5bb9 \u63d0\u4ea4\u4fe1\u606f\u5e94\u8be5\u63cf\u8ff0\u6e05\u695a\u4fee\u6539\u7684\u5185\u5bb9\uff0c\u4e0d\u8981\u4f7f\u7528\u6a21\u7cca\u7684\u8bcd\u6c47\u3002 \u5c3d\u91cf\u63d0\u4f9b\u4e00\u4e9b\u4e0a\u4e0b\u6587\u4fe1\u606f\uff0c\u4f8b\u5982\u4e3a\u4ec0\u4e48\u505a\u51fa\u8fd9\u4e2a\u66f4\u6539\u3001\u89e3\u51b3\u4e86\u4ec0\u4e48\u95ee\u9898\u3001\u6709\u4ec0\u4e48\u5f71\u54cd\u7b49\u3002 \u5982\u679c\u6709\u5173\u8054\u7684\u95ee\u9898\uff08\u5982GitHub Issue\u7b49\uff09\u6216\u4efb\u52a1\uff0c\u53ef\u4ee5\u5728\u63d0\u4ea4\u4fe1\u606f\u4e2d\u5f15\u7528\u76f8\u5173\u7684\u7f16\u53f7\u3002 Github\u539f\u751f\u5f00\u53d1 Actions \u548c Security \u901a\u8fc7 github actions \u548c security\uff08code scanning\uff09\u5b9e\u73b0linux\u3001windows\u3001macos\u5e73\u53f0\u4e0b\u7684 ci \u65b9\u6848\u3002 Issues \u901a\u8fc7 github issues \u767b\u8bb0\u5f00\u53d1\u5de5\u4f5c\uff08\u4fdd\u7559feat\u3001bug\u7b49\u5f00\u53d1\u8db3\u8ff9\uff09\u3002 Discussions \u901a\u8fc7 github discussions \u8fdb\u884c\u56e2\u961f\u6c9f\u901a\u4ea4\u6d41\u3002 \u901a\u8fc7 issues \u5f53\u7136\u4e5f\u53ef\u4ee5\u8ba8\u8bba\uff0c\u4e0d\u8fc7\u66f4\u591a\u662f\u5df2\u786e\u5b9a\u7684 feat \u6216 bug\u3002 Projects \u901a\u8fc7 github projects \u8fdb\u884c\u5f00\u53d1\u8ba1\u5212\u548c\u8fdb\u5ea6\u7ba1\u7406\uff0c\u63a7\u5236\u7248\u672c\u53d1\u5e03 \u3002 Tip4: \u5173\u4e8e\u9879\u76ee\u7684\u7f16\u7801\u98ce\u683c \u00b6 \u5728\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u57f9\u517b\u4ee3\u7801\u5de5\u7a0b\u7d20\u517b\uff0c\u5bf9\u4ee3\u7801\u201c\u6709\u8bb2\u7a76\u201d\uff0c\u6709\u52a9\u4e8e\u6211\u4eec\u5f00\u53d1\u66f4\u53ef\u9760\u548c\u597d\u7ef4\u62a4\u7684\u6a21\u578b\u6a21\u5757\uff1a \u7edf\u4e00\u7684\u547d\u540d\u903b\u8f91\u3001\u826f\u597d\u7684\u5c01\u88c5\u9694\u79bb\u3001\u6e05\u6670\u7684\u6570\u636e\u6d41\uff0c\u80fd\u5e2e\u52a9\u63a7\u5236\u4ee3\u7801\u7684\u590d\u6742\u5ea6\u3002 \u7f8e\u89c2\u3001\u7b26\u5408\u76f4\u89c9\u3001\u76f4\u767d\u7684\u4ee3\u7801\u3002 \u597d\u7684\u4ee3\u7801\u8bfb\u8d77\u6765\u6709\u4e00\u79cd\u97f5\u5f8b\u611f\uff0c\u80fd\u8ba9\u4eba\u4e00\u5929\u90fd\u5f88\u5f00\u5fc3\u3002 \u5bf9\u4e8e\u5355\u4e2a\u6982\u5ff5\uff0c\u5b9a\u4e49\u597d\u5176\u5185\u6db5\u5916\u5ef6\uff1b\u5bf9\u4e8e\u591a\u4e2a\u6982\u5ff5\uff0c\u68b3\u7406\u597d\u5176\u5c42\u6b21\u5173\u7cfb\u3002\u6620\u5c04\u5230\u4ee3\u7801\u4e0a\uff0c\u5c31\u662f\u4e0d\u540c\u7c7b\u7684\u804c\u8d23\u6e05\u6670\u5212\u5206\u3002 \u4f46\u9700\u8981\u58f0\u660e\uff0c\u4e0d\u540c\u7684\u9636\u6bb5\u5bf9\u8bb2\u7a76\u7a0b\u5ea6\u8981\u6c42\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u5982\u4f55\u6289\u62e9\u5462\uff1f\u8fd9\u91cc\u53ef\u4ee5\u5f15\u5165\u4e00\u4e2a\u53c2\u8003\u5ea6\u91cf\uff1a \u751f\u547d\u5468\u671f \u3002 \u751f\u547d\u5468\u671f\u8d8a\u957f\u7684\u4ee3\u7801\uff0c\u4e00\u5b9a\u8981\u5199\u7684\u8d8a\u5e72\u51c0\uff1b\u4e34\u65f6\u4f7f\u7528\u4ee3\u7801\uff0c\u6bd4\u5982\u539f\u578b\u3001\u811a\u672c\uff0c\u5c31\u53ef\u4ee5\u4e0d\u8bb2\u7a76\u4e00\u4e9b\u3002\u53cd\u8fc7\u6765\uff0c\u4e5f\u6b63\u662f\u5e72\u51c0\u7684\u4ee3\u7801\u624d\u80fd\u6210\u5c31\u8d85\u957f\u7684\u751f\u547d\u5468\u671f\u3002 \u5728\u8f6f\u4ef6\u9879\u76ee\u5f00\u53d1\u4e2d\uff0c\u4ee3\u7801\u7684\u89c4\u8303\u6027\u4e3b\u8981\u5305\u62ec\u51e0\u4e2a\u65b9\u9762\uff1a \u4ee3\u7801\u91cd\u590d\u7387\uff1b \u547d\u540d\u7684\u89c4\u8303\uff1b \u5355\u5143\u6d4b\u8bd5\u7684\u8986\u76d6\u7387\uff1b \u65e5\u5fd7\u6253\u5370\u7684\u89c4\u8303\u6027\u3002 \u7f16\u7801\u98ce\u683c \u7eff\u6d32\u9879\u76ee\u4e2d\u4e3b\u8981\u53c2\u8003 \u534e\u4e3a\u7f16\u7a0b\u98ce\u683c \uff0c\u5dee\u5f02\u5728\u4e8e\uff1a \u6210\u5458\u53d8\u91cf\u7528\u524d\u7f00 m \u6807\u8bc6\uff0c\u4e0d\u9002\u7528\u540e\u7f00 _ \u3002 \u6587\u4ef6\u540d\u53ef\u4ee5\u4f7f\u7528\u5927\u9a7c\u5cf0\u547d\u540d\u3002 \u4ee3\u7801\u6ce8\u91ca \u6211\u4eec\u5b8c\u5168\u4e0d\u4ecb\u610f\u4f60\u7684\u6ce8\u91ca\u662f\u4ee3\u7801\u76842\u500d\u30013\u500d ...\uff0c\u4f60\u7684\u4ee3\u7801\u3001\u4f60\u7684\u6210\u679c\uff0c\u4f60\u60f3\u8bf4\u4ec0\u4e48\u3001\u60f3\u8bf4\u591a\u5c11\u90fd\u53ef\u4ee5\u3002 \u65e5\u5fd7 \u826f\u597d\u7684\u7cfb\u7edf\uff0c\u53ef\u4ee5\u901a\u8fc7\u65e5\u5fd7\u8fdb\u884c\u95ee\u9898\u5b9a\u4e3a\u3002\u9664\u4e86\u5728\u672c\u5730\u4ee3\u7801\u4e0a\u590d\u73b0\u3001\u8c03\u8bd5\u5916\uff0c\u8fd8\u8981\u80fd\u591f\u901a\u8fc7\u4e30\u5bcc\u5408\u7406\u7684\u65e5\u5fd7\u4fe1\u606f\u8fd8\u539f\u95ee\u9898\u73b0\u573a\uff0c\u53d1\u73b0\u9519\u8bef\u4f4d\u7f6e\u548c\u539f\u56e0\u3002 \u4e3a\u4ec0\u4e48\u6253\u65e5\u5fd7 \u8ddf\u8e2a\u7a0b\u5e8f\u7684\u8b66\u544a\u548c\u9519\u8bef\uff0c\u6807\u8bc6\u7a0b\u5e8f\u8fd0\u884c\u4e2d\u7684\u5371\u9669\u64cd\u4f5c\u3001\u9519\u8bef\u64cd\u4f5c\uff1b \u8ddf\u8e2a\u5d29\u6e83bug\uff1b \u8ddf\u8e2a\u6027\u80fd\u4e0b\u964d\u7684\u95ee\u9898\u8303\u56f4\uff0c\u901a\u8fc7\u65e5\u5fd7\u63d0\u4f9b\u7684\u8be6\u7ec6\u6267\u884c\u65f6\u95f4\u8bb0\u5f55\u627e\u51fa\u5e94\u7528\u7684\u6027\u80fd\u74f6\u9888\uff1b \u8ddf\u8e2a\u64cd\u4f5c\u6d41\u7a0b\uff0c\u83b7\u53d6\u64cd\u4f5c\u53d1\u751f\u7684\u5177\u4f53\u73af\u5883\u3001\u64cd\u4f5c\u7684\u7ed3\u679c\uff1b \u4ec0\u4e48\u65f6\u5019\u8be5\u6253\u65e5\u5fd7\uff1f \u7ecf\u5e38\u4ee5\u529f\u80fd\u4e3a\u6838\u5fc3\u8fdb\u884c\u5f00\u53d1\uff0c\u5e94\u8be5\u5728\u63d0\u4ea4\u4ee3\u7801\u524d\uff0c\u53ef\u4ee5\u786e\u5b9a\u901a\u8fc7\u65e5\u5fd7\u53ef\u4ee5\u770b\u5230\u6574\u4e2a\u6d41\u7a0b\uff1b \u65e5\u5fd7\u5206\u7ea7 ERROR \u3002\u8be5\u7ea7\u522b\u65e5\u5fd7\u53d1\u751f\u65f6\uff0c\u5df2\u7ecf\u5f71\u54cd\u4e86\u7528\u6237\u7684\u6b63\u5e38\u4f7f\u7528\uff0c\u901a\u5e38\u7a0b\u5e8f\u629b\u9519\u3001\u4e2d\u6b62\u3002\u4e3b\u8981\u7c7b\u578b\u6709\uff1a \u8bfb\u5199\u914d\u7f6e\u6587\u4ef6\u5931\u8d25 \u6240\u6709\u7b2c\u4e09\u65b9\u5bf9\u63a5\u7684\u5f02\u5e38(\u5305\u62ec\u7b2c\u4e09\u65b9\u8fd4\u56de\u9519\u8bef\u7801) \u6240\u6709\u5f71\u54cd\u529f\u80fd\u4f7f\u7528\u7684\u5f02\u5e38 WARN \u3002\u8be5\u7ea7\u522b\u65e5\u5fd7\u4e0d\u5e94\u8be5\u51fa\u73b0\u4f46\u662f\u4e0d\u5f71\u54cd\u7a0b\u5e8f\u7ee7\u7eed\u8fd0\u884c\u7684\u95ee\u9898\u3002\u4e3b\u8981\u7c7b\u578b\u6709\uff1a \u5f02\u5e38\uff1a\u4e0d\u660e\u786e\u5f02\u5e38\uff0c\u53ea\u8fdb\u884c\u4e86\u7b80\u5355\u7684\u6355\u83b7\u629b\u51fa\uff0c\u9700\u8981\u6253\u5370\u8fd9\u79cd\u7b3c\u7edf\u5904\u7406\u7684\u5f02\u5e38 \u6709\u5bb9\u9519\u673a\u5236\u7684\u65f6\u5019\u51fa\u73b0\u7684\u9519\u8bef\u60c5\u51b5 \u627e\u4e0d\u5230\u914d\u7f6e\u6587\u4ef6\uff0c\u4f46\u662f\u7cfb\u7edf\u80fd\u81ea\u52a8\u521b\u5efa\u914d\u7f6e\u6587\u4ef6 \u6027\u80fd\u5373\u5c06\u63a5\u8fd1\u4e34\u754c\u503c\u7684\u65f6\u5019 \u975e\u9884\u671f\u6267\u884c\uff1a\u4e3a\u7a0b\u5e8f\u5728\u201c\u6709\u53ef\u80fd\u201d\u6267\u884c\u5230\u7684\u5730\u65b9\u6253\u5370\u65e5\u5fd7 switch case \u8bed\u53e5\u5757\u4e2d\u7684 default if else \u8bed\u53e5\u5757\u4e2d\u5f88\u5c11\u51fa\u73b0\u7684 else \u60c5\u51b5 try catch \u8bed\u53e5\u5757\u4e2d catch \u5206\u652f INFO \u3002\u8be5\u7ea7\u522b\u65e5\u5fd7\u4e3b\u8981\u7528\u4e8e\u8bb0\u5f55\u7cfb\u7edf\u8fd0\u884c\u72b6\u6001\u3001\u7b49\u4fe1\u606f\uff0c\u5e38\u7528\u4e8e\u53cd\u9988\u7cfb\u7edf\u5f53\u524d\u72b6\u6001\u7ed9\u7528\u6237\u3002\u4e3b\u8981\u7c7b\u578b\u6709\uff1a \u7cfb\u7edf\u64cd\u4f5c\u884c\u4e3a\uff1a\u8bfb\u5199\u6587\u4ef6\u3001\u5b9a\u65f6\u4efb\u52a1\u7b49 \u4e0d\u7b26\u5408\u4e1a\u52a1\u903b\u8f91\u9884\u671f\uff1a\u6253\u5370\u5173\u952e\u7684\u53c2\u6570 \u5bf9\u5916\u63d0\u4f9b\u7684\u63a5\u53e3\u5165\u53e3\u5904\uff1a\u6253\u5370\u63a5\u53e3\u7684\u552f\u4e00\u6807\u8bc6\u548c\u7b80\u77ed\u63cf\u8ff0\uff0c\u5e76\u4e14\u8981\u5c06\u4f20\u5165\u7684\u53c2\u6570\u539f\u6837\u6253\u5370 \u8c03\u7528\u5176\u5b83\u7cfb\u7edf\u63a5\u53e3\u7684\u524d\u540e\uff1a\u6253\u5370\u6240\u8c03\u7528\u63a5\u53e3\u7684\u7cfb\u7edf\u540d\u79f0/\u63a5\u53e3\u540d\u79f0\u548c\u4f20\u5165\u53c2\u6570/\u54cd\u5e94\u53c2\u6570 \u7cfb\u7edf\u6a21\u5757\u7684\u5165\u53e3\u4e0e\u51fa\u53e3\u5904\uff1a\u53ef\u4ee5\u5728\u91cd\u8981\u65b9\u6cd5\u7ea7\u6216\u6a21\u5757\u7ea7\u8bb0\u5f55\u8f93\u5165\u4e0e\u8f93\u51fa \u670d\u52a1\u72b6\u6001\u53d8\u5316(\u5c3d\u53ef\u80fd\u8bb0\u5f55\u7ebf\u7d22)\uff1a\u7a0b\u5e8f\u4e2d\u91cd\u8981\u7684\u72b6\u6001\u4fe1\u606f\u7684\u53d8\u5316\u5e94\u8be5\u8bb0\u5f55\u4e0b\u6765 \u4e00\u4e9b\u53ef\u80fd\u5f88\u8017\u65f6\u7684\u4e1a\u52a1\u5904\u7406\uff1a\u6279\u5904\u7406\uff0cIO\u64cd\u4f5c \u7a0b\u5e8f\u8fd0\u884c\u8017\u65f6\uff1a\u901a\u8fc7\u5b83\u53ef\u4ee5\u8ddf\u8e2a\u4e3a\u4ec0\u4e48\u7cfb\u7edf\u54cd\u5e94\u53d8\u6162\u6216\u8005\u592a\u5feb \u5927\u6279\u91cf\u6570\u636e\u7684\u6267\u884c\u8fdb\u5ea6 DEBUG \u3002\u8be5\u7ea7\u522b\u65e5\u5fd7\u7684\u4e3b\u8981\u4f5c\u7528\u662f\u5bf9\u7cfb\u7edf\u6bcf\u4e00\u6b65\u7684\u8fd0\u884c\u72b6\u6001\u8fdb\u884c\u7cbe\u786e\u7684\u8bb0\u5f55\u3002 \u6ce8\u610f\uff1a \u5728\u751f\u4ea7\u73af\u5883\u4e2d\u4e0d\u80fd\u6253\u5370DEBUG\u7ea7\u522b\u7684\u65e5\u5fd7\uff0cDEBUG\u7ea7\u522b\u7684\u65e5\u5fd7\u53ea\u80fd\u7528\u4e8e\u5f00\u53d1\u8c03\u8bd5\u6216\u6d4b\u8bd5\u73af\u8282\uff0c\u540c\u65f6\u5728\u8f93\u51faDEBUG\u7ea7\u522b\u7684\u65e5\u5fd7\u7684\u65f6\u5019\uff0c\u4e5f\u5e94\u8be5\u4f9d\u636e\u9879\u76ee\u7ec4\u7684\u5f00\u53d1\u9700\u6c42\u6253\u5370\u65e5\u5fd7\uff0c\u5c3d\u91cf\u505a\u5230\uff1a \u5f00\u53d1\u4eba\u5458\u548c\u6d4b\u8bd5\u4eba\u5458\u90fd\u80fd\u770b\u61c2 \u901a\u8fc7\u9605\u8bfbDEBUG\u7ea7\u522b\u7684\u65e5\u5fd7\u540e\u4e0d\u9700\u8981\u91cd\u73b0\u95ee\u9898\uff0c\u5c31\u80fd\u51c6\u786e\u7684\u5b9a\u4f4d\u89e3\u51b3\u95ee\u9898 \u65e5\u5fd7\u683c\u5f0f \u4f7f\u7528\u53c2\u6570\u5316\u4fe1\u606f\u7684\u65b9\u5f0f\uff1b \u4f7f\u7528 [] \u8fdb\u884c\u53c2\u6570\u53d8\u91cf\u9694\u79bb\uff1b \u76f8\u540c\u7684\u65e5\u5fd7\u4fe1\u606f\u4e0d\u80fd\u5728\u4e0d\u540c\u7ea7\u522b\u4e2d\u91cd\u590d\uff1b \u65e5\u5fd7\u5185\u5bb9\u5305\u62ec \u201c\u65f6\u95f4 \u8fdb\u7a0b|\u7ebf\u7a0b \u7ea7\u522b \u6a21\u5757 Filter(\u7528\u4e8e\u67e5\u627elog) \u5185\u5bb9\u201d\uff1b Tipx: \u4e34\u65f6\u8bf4\u660e \u00b6 \u6682\u65e0\u3002","title":"DevTips"},{"location":"OpenOasisDevTips/#_1","text":"OpenOasis Development Tips \u7eff\u6d32\u9879\u76ee\u65e8\u5728\u7528\u4e8e\u5b66\u672f\u4ee5\u53ca\u6559\u5b66\u7528\u9014\uff0c\u56e0\u6b64\u5728\u8bbe\u8ba1\u5404\u79cd\u7b97\u6cd5\u548c\u65b9\u6848\u7684\u5b9e\u73b0\u7ec6\u8282\u65f6\uff0c\u7f16\u7801\u7684\u6e05\u6670\u5ea6\u662f\u91cd\u4e2d\u4e4b\u91cd\u3002 \u5c3d\u7ba1\u5982\u6b64\uff0c\u5b83\u7684\u6240\u6709\u6570\u503c\u548c\u7b97\u6cd5\u5728\u5f88\u591a\u65b9\u9762\u90fd\u4e0e\u9762\u5411\u5de5\u4e1a\u7684 CFD \u4ee3\u7801\u4e2d\u4f7f\u7528\u7684\u6570\u503c\u548c\u7b97\u6cd5\u76f8\u4f3c\uff0c\u5e76\u9f13\u52b1\u8be6\u5c3d\u7684\u6587\u6863\u8bf4\u660e\u3002 Tip1-\u5173\u4e8e\u6a21\u578b\u5f00\u53d1\u8fc7\u7a0b\u548c\u6587\u6863\uff1a\u4e00\u4e2a\u5f85\u5b8c\u5584\u7684\u5f00\u53d1\u5efa\u8bae Tip2-\u5173\u4e8e\u9879\u76ee\u7684\u7ec4\u7ec7\u7ed3\u6784 Tip3-\u5173\u4e8e\u9879\u76ee\u7684\u53d1\u5e03\u6d41\u7a0b Tip4-\u5173\u4e8e\u9879\u76ee\u7684\u7f16\u7801\u98ce\u683c Tipx-\u4e34\u65f6\u8bf4\u660e","title":"\u7eff\u6d32\u5f00\u53d1\u5c0f\u8d34\u58eb"},{"location":"OpenOasisDevTips/#tip1","text":"\u4e00\u4e2a\u6a21\u578b\u7684\u5f00\u53d1\u8fc7\u7a0b\u53ef\u80fd\u4f1a\u7ecf\u5386\u4ee5\u4e0b\u51e0\u4e2a\u9636\u6bb5\uff1a 1 st : \u7b2c\u4e00\u9636\u6bb5 \u63d0\u51fa\u6a21\u578b\u60f3\u6cd5\uff0c\u8bf4\u660e\u5f00\u53d1\u76ee\u7684\u6216\u610f\u4e49\uff0c\u63d0\u4f9b\u4e00\u4e9b\u57fa\u7840\u5f00\u53d1\u8d44\u6599\u3001\u65b9\u5411\u6216\u601d\u8def\uff1b\u901a\u5e38\u6765\u8bf4\uff0c 1st \u4ecd\u5904\u4e8e\u524d\u671f\u8ba8\u8bba\u9636\u6bb5\uff0c\u53ef\u4ee5\u5728\u9879\u76ee\u4ed3\u5e93\u3001\u77e5\u4e4e\u95ee\u9898\u3001\u8bfe\u9898\u5c0f\u7ec4\u6216\u8005\u5176\u4ed6\u5e73\u53f0\u63d0\u51fa\uff0c \u4f5c\u4e3a\u4e00\u4e2a issue \u3001\u4e00\u4e2a \u63d0\u95ee \u3001\u4e00\u4e2a \u62a5\u544a \u3001\u4e00\u4e2a \u52a8\u6001 \u53d1\u5e03\u3002 2 nd : \u7b2c\u4e8c\u9636\u6bb5 \u8bbe\u8ba1\u6a21\u578b\u7b97\u6cd5\uff0c\u89e3\u91ca\u7406\u8bba\u4f9d\u636e\uff0c\u63d0\u4f9b\u7b97\u6cd5\u8be6\u7ec6\u8bbe\u8ba1\uff08\u8ba1\u7b97\u94fe\u8def\u95ed\u73af\uff09\u3002 \u8fd9\u4e2a\u9636\u6bb5\u53ef\u80fd\u4e3b\u8981\u805a\u7126\u5728\u5982\u4f55\u4f7f\u60f3\u6cd5\u843d\u5730\uff0c\u600e\u4e48\u6837\u6765\u8bbe\u8ba1\u4e00\u4e2a\u5b8c\u6574\u7684\u8ba1\u7b97\u903b\u8f91\u6216\u8ba1\u7b97\u94fe\u8def\uff1f \u8fd9\u4e2a\u9636\u6bb5\u53ef\u80fd\u8fd8\u9700\u8981\u521d\u6b65\u7684\u539f\u578b\u5b9e\u73b0\uff0c\u6572\u4ee3\u7801\u548c\u63a8\u516c\u5f0f\u4ea4\u7ec7\u8fdb\u884c\u3002 3 rd : \u7b2c\u4e09\u9636\u6bb5 \u5b9e\u65bd\u5f00\u53d1\u65b9\u6848\uff0c\u5b9a\u4e49\u6a21\u578b\u6570\u636e\u548c\u63a5\u53e3\uff0c\u5b8c\u6210\u6a21\u5757\u5f00\u53d1\u548c\u5355\u5143\u6d4b\u8bd5\u3002 \u8fdb\u5165 3rd \u9636\u6bb5\u901a\u5e38\u8868\u660e\u6a21\u578b\u7684\u7b97\u6cd5\u5df2\u7ecf\u57fa\u672c\u7a33\u5b9a\uff0c\u5f00\u59cb\u5de5\u7a0b\u9879\u76ee\u5f00\u53d1\u3002\u4e00\u822c\u7684\u5efa\u8bae\u662f\uff0c\u7740\u624b\u7f16\u7801\u524d\u68b3\u7406\u529f\u80fd\u6a21\u5757\u5173\u7cfb\uff0c\u786e\u5b9a\u6a21\u5757\u96c6\u6210\u63a5\u53e3\uff0c\u8bbe\u8ba1\u6570\u636e\u7ed3\u6784\uff1b\u540c\u65f6\uff0c\u5728\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u9075\u5faa\u4e00\u5957\u4ee3\u7801\u89c4\u8303\u548c\u683c\u5f0f\u5316\u65b9\u6848\uff0c\u5e76\u53ca\u65f6\u5b8c\u6210\u5355\u5143\u6d4b\u8bd5\u3001\u96c6\u6210\u6d4b\u8bd5\uff0c\u6ce8\u610f\u4ee3\u7801\u8986\u76d6\u5ea6\u3002 4 th : \u7b2c\u56db\u9636\u6bb5 \u901a\u8fc7\u6a21\u578b\u8bc4\u4f30\u65b9\u6848\uff0c\u6d4b\u8bd5\u6a21\u578b\u51c6\u786e\u6027\u548c\u7a33\u5b9a\u6027\uff0c\u6d4b\u8bd5\u53c2\u6570\u654f\u611f\u6027\u3002 \u5728\u53ef\u9760\u7684\u5355\u5143\u6d4b\u8bd5\u57fa\u7840\u4e0a\uff0c\u8fdb\u4e00\u6b65\u5730\u8fdb\u884c\u76f8\u5bf9\u5145\u5206\u7684\u6a21\u578b\u7528\u4f8b\u6d4b\u8bd5(\u9700\u8981\u8986\u76d6\u53ef\u9884\u89c1\u7684\u5e38\u89c1\u573a\u666f\u548c\u90e8\u5206\u6781\u7aef\u573a\u666f)\uff0c\u6d4b\u8bd5\u6a21\u5757\u7684\u7a33\u5b9a\u6027\u3001\u9002\u7528\u6027\uff0c\u5206\u6790\u6a21\u5757\u7684\u53c2\u6570\u654f\u611f\u6027\uff0c\u8fdb\u4e00\u6b65\u5730\u6d4b\u8bd5\u6a21\u5757\u7684\u51c6\u786e\u6027\u53ca\u6027\u80fd\u8868\u73b0\u3002 \u9664\u6b64\u4e4b\u5916\uff0c\u53ef\u80fd\u8fd8\u5305\u62ec\uff1a 5 th : \u7ef4\u62a4\u9636\u6bb5 \u4fee\u590d\u6a21\u5757bug\u3001\u5347\u7ea7\u6a21\u5757\u529f\u80fd\u3001\u91cd\u6784\u6a21\u5757\u7b49\u540e\u671f\u7ef4\u62a4\u3002 \u6a21\u578b\u6587\u6863 \u4e3a\u4e86\u63d0\u9ad8\u6a21\u578b\u548c\u9879\u76ee\u7684\u53ef\u9760\u6027\u548c\u53ef\u7ef4\u62a4\u6027\uff0c\u4e00\u4e2a\u6a21\u578b\u7ec4\u4ef6\u7684\u6587\u6863\u5efa\u8bae\u5305\u542b\uff1a \u7b97\u6cd5\u8be6\u7ec6\u8bbe\u8ba1 \uff0c\u8bf4\u660e\u7b97\u6cd5\u539f\u7406\u548c\u524d\u63d0\u5047\u8bbe\uff0c\u63d0\u4f9b\u5b8c\u6574\u7684\u8ba1\u7b97\u8fc7\u7a0b\u4ee5\u53ca\u6d89\u53ca\u7684\u53d8\u91cf\u5b9a\u4e49\uff1b \u5f00\u53d1\u63a5\u53e3\u8bf4\u660e \uff0c\u8bf4\u660e\u7ec4\u4ef6\u63a5\u53e3\uff0c\u5305\u62ec\u63a5\u53e3\u53c2\u6570\u3001\u63a5\u53e3\u529f\u80fd\u548c\u53ef\u80fd\u7684\u5f02\u5e38\u7b49\uff1b \u6d4b\u8bd5\u8bc4\u4f30\u62a5\u544a \uff0c\u63d0\u4f9b\u5404\u7c7b\u6d4b\u8bd5\u7ed3\u679c\u5206\u6790\u62a5\u544a\uff1b \u6a21\u578b\u64cd\u4f5c\u624b\u518c \uff0c\u8bf4\u660e\u6a21\u578b\u7684\u7528\u6237\u7aef\u8f93\u5165\u8f93\u51fa\u683c\u5f0f\uff0c\u6f14\u793a\u5e38\u89c1\u573a\u666f\u4e0b\u7684\u7ec4\u4ef6\u4f7f\u7528\u3002 \u805a\u7126\u4e8e\u6a21\u5757\u7684\u53ef\u9760\u6027\uff0c \u6d4b\u8bd5\u8bc4\u4f30\u62a5\u544a \u4e2d\u5e94\u8be5\u5305\u62ec\u6a21\u578b\u4e0e\u73b0\u5b9e\u7684\u4e00\u81f4\u6027\u3001\u53c2\u6570\u53ca\u524d\u63d0\u5047\u8bbe\u7684\u5f71\u54cd\u3001\u53c2\u6570\u771f\u503c\u4ee5\u53ca\u5176\u5206\u5e03\u7684\u5f71\u54cd\u5206\u6790\uff0c\u63d0\u4f9b\u6a21\u578b\u6821\u6838\u62a5\u544a\u3001\u53c2\u6570\u654f\u611f\u6027\u8bc4\u4f30\u62a5\u544a\u3001\u7f51\u683c\u76f8\u5173\u6027\u8bc4\u4f30\u62a5\u544a\uff0c\u6570\u503c\u7b97\u6cd5\u7a33\u5b9a\u6027\u8bc4\u4f30\u62a5\u544a\uff0c\u6a21\u578b\u6027\u80fd\u8bc4\u4f30\u62a5\u544a\u3002","title":"Tip1: \u5173\u4e8e\u6a21\u578b\u5f00\u53d1\u9636\u6bb5\u7684\u5212\u5206\u548c\u6587\u6863\u8981\u6c42"},{"location":"OpenOasisDevTips/#tip4","text":"OpenOasis Project Structure: +-- / | +-- DataAsst/ : \u6570\u636e\u52a9\u624b\uff0c\u7528\u4e8e\u6570\u636e\u5206\u6790\u3001\u5904\u7406\u548c\u53ef\u89c6\u5316 | +-- Doc/ : \u9879\u76ee\u6587\u6863 | +-- iAgents/ : \u6df1\u5ea6\u5b66\u4e60\u4e0e\u5f3a\u5316\u5b66\u4e60\u89e3\u51b3\u65b9\u6848\u5e93 | | +-- Spark/ : \u661f\u706b\u4eba\u5de5\u667a\u80fd\u5305 | | +-- tests/ : \u6d4b\u8bd5\u96c6 | +-- Models/ : \u6a21\u578b\u7ec4\u4ef6\u96c6\u4ee5\u53ca\u6570\u503c\u6c42\u89e3\u5668\u96c6 | | +-- CommImp/ : \u63a5\u53e3\u7684\u901a\u7528\u5b9e\u73b0 | | +-- Inc/ : \u63a5\u53e3\u6807\u51c6 | | +-- SystFluids/ : \u6d41\u4f53\u6d41\u52a8\u6a21\u578b\u96c6 | | +-- SystHeats/ : \u70ed\u91cf\u6d41\u52a8\u6a21\u578b\u96c6 | | +-- Utils/ : \u901a\u7528\u529f\u80fd\u6a21\u5757 | | +-- tests/ : \u6d4b\u8bd5\u96c6 | | +-- ThirdPart/ : \u7b2c\u4e09\u65b9\u5de5\u5177\u7bb1 | | +-- wrappers/ : c++/python\u63a5\u53e3\u5c01\u88c5 | | +-- Launcher.cpp : \u6a21\u5757\u52a8\u6001\u52a0\u8f7d\u5668 | +-- Rsrc/ : \u76f8\u5173\u8d44\u6e90 | | +-- Benchmarks/ : \u9879\u76ee\u6848\u4f8b\u6570\u636e\u96c6 | | +-- Logo/ : \u9879\u76ee\u6807\u8bc6\u7b49 | | +-- TheoryBriefs/ : \u7406\u8bba/\u6280\u672f/\u6982\u5ff5\u7b80\u4ecb \u5728\u8fd9\u4e2a\u9879\u76ee\u67b6\u6784\u8bbe\u8ba1\u4e2d\uff0c\u6570\u503c\u7b97\u6cd5\u5185\u6838\u4f4d\u4e8e Models \u76ee\u5f55\u4e0b\u3002 Inc \u76ee\u5f55\u4e0b\u5b58\u653e\u63a5\u53e3\u6807\u51c6\uff0c CommImp \u76ee\u5f55\u4e0b\u5b58\u653e\u8be5\u63a5\u53e3\u7684\u901a\u7528\u5b9e\u73b0\u65b9\u6848\uff08SDK\uff09\u3002 SystFluids \u548c SystHeats \u76ee\u5f55\u4e0b\u5b58\u653e\u57fa\u4e8e\u901a\u7528\u5b9e\u73b0\u65b9\u6848\u7684\u6d41\u4f53\u6d41\u52a8\u548c\u70ed\u91cf\u6d41\u52a8\u6a21\u578b\uff08App\uff09\uff0c Utils \u76ee\u5f55\u4e0b\u5b58\u653e\u901a\u7528\u529f\u80fd\u6a21\u5757(\u4e0d\u4f9d\u8d56\u63a5\u53e3\u6807\u51c6\u4ee5\u53ca\u4efb\u4f55\u5916\u90e8\u5b9e\u73b0\uff0c\u9664\u4e86\u7b2c\u4e09\u65b9\u5e93)\u3002 Launcher.cpp \u662f\u4e00\u4e2a\u6a21\u5757\u52a8\u6001\u52a0\u8f7d\u5668\uff0c\u7528\u4e8e\u52a8\u6001\u52a0\u8f7d\u7b26\u5408\u63a5\u53e3\u6807\u51c6\u7684\u6a21\u5757\uff0c\u5e76\u63d0\u4f9b\u7edf\u4e00\u7684\u63a5\u53e3\u8c03\u7528\u65b9\u5f0f\u3002 CommImp \u4e2d\u8fd8\u6709\u6b21\u7ea7\u76ee\u5f55\uff0c\u5305\u62ec: DevSupports (\u7528\u4e8e\u62d3\u5c55\u63a5\u53e3\u5b9a\u4e49\u548c\u5b9e\u73b0\uff0c\u63d0\u4f9b\u63a5\u53e3\u5bf9\u8c61\u7684\u8f85\u52a9\u51fd\u6570)\uff0c IO (\u7528\u4e8e\u63d0\u4f9b\u7edf\u4e00\u7684IO\u63a5\u53e3\uff0c\u4e0d\u4f9d\u8d56\u63a5\u53e3\u6807\u51c6)\uff0c Numeric (\u7528\u4e8e\u63d0\u4f9b\u7ed9\u96f7\u6570\u503c\u7b97\u6cd5\u6c42\u89e3\u5668\u5b9e\u73b0\uff0c\u4e0d\u4f9d\u8d56\u63a5\u53e3\u6807\u51c6)\uff0c Spatial \u548c Temporal (\u7528\u4e8e\u63d0\u4f9b\u7a7a\u95f4\u548c\u65f6\u95f4\u79bb\u6563\u7684\u6570\u636e\u5b9a\u4e49\u548c\u5904\u7406\uff0c\u4e0d\u4f9d\u8d56\u63a5\u53e3\u6807\u51c6)\u3002","title":"Tip4: \u5173\u4e8e\u7eff\u6d32\u7684\u9879\u76ee\u67b6\u6784"},{"location":"OpenOasisDevTips/#tip3","text":"\u9879\u76ee\u6682\u5b9a\u53d1\u5e03\u5728 GitHub\uff1b\u91c7\u7528 Git \u4f5c\u4e3a\u534f\u4f5c\u5f00\u53d1\u548c\u7248\u672c\u63a7\u5236\u5de5\u5177\uff1b\u91c7\u7528 Git Flow \u5f00\u53d1\u6a21\u5f0f\uff1b\u7248\u672c\u53f7\u91c7\u7528 major.minor.patch \u683c\u5f0f\u3002 \u9879\u76ee\u6682\u5b9a\u6bcf\u5e74\u79cb\u5206\u53d1\u5e03\u5927\u7248\u672c\u66f4\u65b0\uff08LTS \u7248\u672c\uff09\uff0c\u5e76\u63d0\u524d\u4e00\u4e2a\u6708\u51bb\u7ed3\u5408\u5e76\u8bf7\u6c42\u3001\u6267\u884c\u56de\u5f52\u6d4b\u8bd5\u3002 \u5f00\u53d1\u6a21\u5f0f \u7b80\u5355\u8bf4\u6765\uff0cGit Flow \u6a21\u5f0f\u5c31\u662f\u7ed9\u539f\u672c\u666e\u666e\u901a\u901a\u7684\u5206\u652f\u8d4b\u4e88\u4e86\u4e0d\u540c\u7684\u300c\u804c\u8d23\u300d\uff1a main - \u4e3b\u5206\u652f \u6240\u6709\u63d0\u4f9b\u7ed9\u7528\u6237\u4f7f\u7528\u7684\u6b63\u5f0f\u7248\u672c\uff0c\u90fd\u5728\u8fd9\u4e2a\u4e3b\u5206\u652f\u4e0a\u53d1\u5e03\u3002 \u5f00\u53d1\u8005\u5728\u6b64\u5206\u652f \u4e0d\u53ef\u8fdb\u884c push \u64cd\u4f5c\u3002 dev - \u5f00\u53d1\u5206\u652f \u65e5\u5e38\u5f00\u53d1\u6240\u4f7f\u7528\u7684\u5206\u652f\uff0c\u5f00\u53d1\u8005\u5b8c\u6210\u7684\u9636\u6bb5\u6027\u529f\u80fd\u6a21\u5757\u5c06\u9996\u5148\u88ab\u5408\u5e76\u5230\u6b64\u5206\u652f\u3002 \u5f00\u53d1\u8005\u5728\u6b64\u5206\u652f \u4e0d\u53ef\u8fdb\u884c push \u64cd\u4f5c\uff0c\u53ea\u80fd\u901a\u8fc7 Pull Request \u7684\u65b9\u5f0f\u5c06\u4e2a\u4eba\u5206\u652f\u5408\u5e76\u5230\u6b64\u5206\u652f\u3002 \u5f00\u53d1\u8fc7\u7a0b\u4e2d\uff0c\u8981\u7ecf\u5e38\u4e0e\u6b64\u5206\u652f\u4fdd\u6301\u540c\u6b65\u3002 feature/xxx - \u7279\u6027\u5206\u652f \u7528\u4e8e\u67d0\u4e2a\u529f\u80fd\u6a21\u5757\u7684\u5f00\u53d1\uff0c\u5f53\u8be5\u529f\u80fd\u6a21\u5757\u5f00\u53d1\u4efb\u52a1\u5b8c\u6210\u540e\uff0c\u901a\u8fc7 Pull Request \u7684\u5f62\u5f0f\u8fdb\u884c\u8bf7\u6c42\u5408\u5e76\uff0c\u7ba1\u7406\u5458 Code Review \u901a\u8fc7\u540e\uff0c\u5c06\u8be5\u5206\u652f\u5408\u5e76\u5230 dev \u5206\u652f\uff1b\u6b64\u540e\uff0c\u8be5\u5206\u652f\u5c06\u88ab\u5220\u9664\u3002 \u6b64\u7c7b\u5206\u652f\u7531\u5f00\u53d1\u8005\u4e2a\u4eba\u7ba1\u7406\u548c\u4f7f\u7528\uff0c\u53ef\u4ee5\u8fdb\u884c push \u64cd\u4f5c\u3002 \u5f00\u53d1\u8fc7\u7a0b\u4e2d\uff0c\u8981\u7ecf\u5e38\u4e0e dev \u5206\u652f\u4fdd\u6301\u540c\u6b65\u3002 hotfix/xxx - \u8865\u4e01\u5206\u652f \u7528\u4e8e\u7d27\u6025\u4fee\u590d Bug \u7684\u5206\u652f\uff0c\u53ef\u4ee5\u7531 main \u6216 develop \u5206\u652f\u521b\u5efa\u3002 \u4e00\u65e6\u4fee\u590d\u5b8c\u6210\uff0c\u5c31\u5408\u5e76\u5230 main \u6216 dev \u5206\u652f\uff08\u4ec5\u80fd\u901a\u8fc7 Pull Request \u7684\u65b9\u5f0f\uff09\uff0c\u7136\u540e\u5220\u9664\u3002 release - \u53d1\u5e03\u5206\u652f \u53d1\u5e03\u5b9a\u671f\u8981\u4e0a\u7ebf\u7684\u529f\u80fd\uff0c\u6b64\u5206\u652f\u4ea6\u662f\u56e2\u961f\u5185\u90e8\u6d4b\u8bd5\u3001\u9636\u6bb5\u6027\u5de5\u4f5c\u9a8c\u8bc1\u6240\u4f7f\u7528\u7684\u5206\u652f\u3002 \u5982\u679c\u53d1\u73b0\u4e86 bug\uff0c\u76f8\u5e94\u7684\u5c31\u5728 release \u5206\u652f\u4e0a\u6216\u57fa\u4e8e release \u5206\u652f\u521b\u5efa\u4e00\u4e2a\u5206\u652f\u8fdb\u884c\u4fee\u590d\uff0c\u7136\u540e\u91cd\u65b0\u63d0\u4ea4\u6d4b\u8bd5\u3002 \u4e00\u65e6\u6d4b\u8bd5\u5b8c\u6210\uff0c\u5c31\u5408\u5e76\u5230 main \u6216 dev \u5206\u652f\uff08\u4ec5\u80fd\u901a\u8fc7 Pull Request \u7684\u65b9\u5f0f\uff09\uff0c\u7136\u540e\u5220\u9664\u3002 \u5bf9\u4e8e\u957f\u671f\u652f\u6301\u7248\u672c(LTS)\uff0c\u4fdd\u7559\u5176release\u5206\u652f\uff0c\u5e76\u5728\u7ef4\u62a4\u671f\u5185\u63d0\u4f9bbug\u4fee\u590d\u652f\u6301\u3002 \u8d1f\u8d23\u67d0\u4e2a\u529f\u80fd\u7684\u5f00\u53d1\u4eba\u5458\u521b\u5efa\u4e00\u4e2a\u5bf9\u5e94\u7684\u672c\u5730 feature \u5206\u652f\uff0c\u5e76\u505a\u4e00\u4e9b\u521d\u59cb\u5316\u5de5\u4f5c\u4e4b\u540e\u5c31\u63a8\u9001\u521b\u5efa\u8fdc\u7a0b\u5206\u652f\u3002\u529f\u80fd\u5f00\u53d1\u5b8c\u5e76\u81ea\u6d4b\u4e4b\u540e\uff0c\u5148\u5207\u6362\u5230 dev \u5206\u652f\u5c06\u6700\u65b0\u7684\u4ee3\u7801\u62c9\u53d6\u4e0b\u6765\uff0c\u518d\u5207\u6362\u56de\u81ea\u5df1\u8d1f\u8d23\u7684 feature \u5206\u652f\u628a dev \u5206\u652f\u7684\u4ee3\u7801\u5408\u5e76\u8fdb\u6765\u3002\u5982\u679c\u6709\u51b2\u7a81\uff0c\u89e3\u51b3\u5408\u5e76\u51b2\u7a81\u3002\u7136\u540e\uff0c\u5230 GitHub \u4e0a\u7684\u9879\u76ee\u521b\u5efa\u5408\u5e76\u8bf7\u6c42\uff08merge request\uff09\u3002 \u9879\u76ee\u8d1f\u8d23\u4eba\u5728\u6536\u5230\u5408\u5e76\u8bf7\u6c42\u65f6\uff0c\u8fdb\u884c\u4ee3\u7801\u5ba1\u6838\uff1b\u6709\u95ee\u9898\u5c31\u53cd\u9988\u7ed9\u8d1f\u8d23\u5f00\u53d1\u7684\u4eba\u5458\u53bb\u4fee\u6539\uff0c\u6ca1\u6709\u5c31\u63a5\u53d7\u8bf7\u6c42\u5e76\u5220\u9664\u5bf9\u5e94\u7684 feature \u5206\u652f\u3002 \u5728\u5c06\u67d0\u6b21\u53d1\u5e03\u7684\u6240\u9700\u529f\u80fd\u5168\u90e8\u5f00\u53d1\u5b8c\u6210\u65f6\uff0c\u51bb\u7ed3\u5408\u5e76\u8bf7\u6c42\uff0c\u5f00\u59cb\u4ea4\u4ed8\u53d1\u5e03\u6d4b\u8bd5\u3002\u53d1\u5e03\u6d4b\u8bd5\u65f6\u521b\u5efa\u4e00\u4e2a release \u5206\u652f\u90e8\u7f72\u5230\u6d4b\u8bd5\u73af\u5883\u8fdb\u884c\u6d4b\u8bd5\uff1b\u82e5\u53d1\u73b0\u4e86 bug\uff0c\u76f8\u5e94\u7684\u5f00\u53d1\u4eba\u5458\u5c31\u5728 release \u5206\u652f\u4e0a\u6216\u8005\u57fa\u4e8e release \u5206\u652f\u521b\u5efa\u4e00\u4e2a\u5206\u652f\u8fdb\u884c\u4fee\u590d\u3002release \u5206\u652f\u4e0a\u4e0d\u518d\u63a5\u53d7\u65b0\u529f\u80fd\u63d0\u4ea4\u3002 \u5f53\u786e\u4fdd\u67d0\u6b21\u53d1\u5e03\u7684\u529f\u80fd\u53ef\u4ee5\u53d1\u5e03\u65f6\uff0c\u5c06 release \u5206\u652f\u5408\u5e76\u5230 dev \u548c main \u5206\u652f\u5e76\u6253\u4e0a tag\u3002 \u5f53\u53d1\u73b0\u7ebf\u4e0a\u73af\u5883\u7684\u4ee3\u7801\u6709\u5c0f\u95ee\u9898\u6216\u8005\u505a\u4e9b\u6587\u6848\u4fee\u6539\u65f6\uff0c\u76f8\u5173\u5f00\u53d1\u4eba\u5458\u5c31\u76f4\u63a5\u4ece main \u5206\u652f\u5207\u51fa hotfix \u5206\u652f\u8fdb\u884c\u4fee\u6539\u540e\u5408\u5e76\u5230 main \u548c dev \u5206\u652f\u5e76\u6253\u4e0a tag\u3002\u5982\u679c\u662f\u76f8\u5f53\u4e25\u91cd\u7684\u95ee\u9898\uff0c\u53ef\u80fd\u5c31\u5f97\u56de\u6eda\u5230\u4e0a\u4e00\u4e2a tag \u7684\u7248\u672c\u3002 \u5206\u652f\u547d\u540d \u4e3b\u8981\u5206\u652f\u7684\u540d\u5b57\u662f\u56fa\u5b9a\u7684\uff0c\u6d3e\u751f\u5206\u652f\u662f\u9700\u8981\u81ea\u5df1\u547d\u540d\u3002\u5f3a\u70c8\u63a8\u8350\u7528\u5982\u4e0b\u5f62\u5f0f\u7684\u547d\u540d\u89c4\u8303\uff1a feature\uff1a\u6309\u7167\u529f\u80fd\u70b9\uff08\u800c\u4e0d\u662f\u9700\u6c42\uff09\u547d\u540d\uff1b release\uff1a\u7528\u53d1\u5e03\u65f6\u95f4\u547d\u540d\uff0c\u53ef\u4ee5\u52a0\u4e0a\u9002\u5f53\u7684\u524d\u7f00\uff1b hotfix\uff1a GitHub \u7684 issue \u7f16\u53f7\u6216 bug \u6027\u8d28\u7b49\u3002 \u529f\u80fd\u63d0\u4ea4 \u63d0\u4ea4\u9891\u7387 \u6bcf\u4e2a\u63d0\u4ea4\u5e94\u8be5\u53ea\u5305\u542b\u4e00\u4e2a\u903b\u8f91\u4e0a\u7684\u66f4\u6539\u6216\u4fee\u590d\uff0c\u8fd9\u6837\u53ef\u4ee5\u66f4\u5bb9\u6613\u8ffd\u8e2a\u548c\u7406\u89e3\u6bcf\u4e2a\u63d0\u4ea4\u7684\u610f\u56fe\u3002 \u5efa\u8bae\u5c06\u6bcf\u4e2acommit\u7528\u65f6\u63a7\u5236\u5728 3 \u5c0f\u65f6\u5185\uff0c\u9f13\u52b1\u63d0\u9ad8\u63d0\u4ea4\u9891\u7387\u3002 \u907f\u514d\u5c06\u591a\u4e2a\u4e0d\u76f8\u5173\u7684\u66f4\u6539\u6df7\u5408\u5728\u4e00\u4e2a\u63d0\u4ea4\u4e2d\uff0c\u4ee5\u514d\u7ed9\u4ee3\u7801\u5ba1\u67e5\u548c\u7248\u672c\u63a7\u5236\u5e26\u6765\u56f0\u6270\u3002 \u63d0\u4ea4\u4fe1\u606f\u683c\u5f0f \u63d0\u4ea4\u4fe1\u606f\u7684\u683c\u5f0f\u901a\u5e38\u662f\uff1a\u201c[\u7c7b\u578b]: \u63cf\u8ff0\u201d\u3002 \u63d0\u4ea4\u7c7b\u578b\uff08type\uff09\u6307\u8fd9\u4e2a\u63d0\u4ea4\u6240\u5c5e\u7c7b\u522b\uff0c\u53ef\u4ee5\u662ffeat\u3001fix\u3001docs\u3001style\u3001refactor\u3001test\u3001chore\u7b49\u3002 \u63cf\u8ff0\uff08description\uff09\u662f\u5bf9\u63d0\u4ea4\u7684\u7b80\u77ed\u63cf\u8ff0\uff0c\u5e94\u5c3d\u91cf\u6e05\u6670\u660e\u4e86\uff0c\u7a81\u51fa\u5173\u952e\u4fe1\u606f\u3002 \u63d0\u4ea4\u4fe1\u606f\u5185\u5bb9 \u63d0\u4ea4\u4fe1\u606f\u5e94\u8be5\u63cf\u8ff0\u6e05\u695a\u4fee\u6539\u7684\u5185\u5bb9\uff0c\u4e0d\u8981\u4f7f\u7528\u6a21\u7cca\u7684\u8bcd\u6c47\u3002 \u5c3d\u91cf\u63d0\u4f9b\u4e00\u4e9b\u4e0a\u4e0b\u6587\u4fe1\u606f\uff0c\u4f8b\u5982\u4e3a\u4ec0\u4e48\u505a\u51fa\u8fd9\u4e2a\u66f4\u6539\u3001\u89e3\u51b3\u4e86\u4ec0\u4e48\u95ee\u9898\u3001\u6709\u4ec0\u4e48\u5f71\u54cd\u7b49\u3002 \u5982\u679c\u6709\u5173\u8054\u7684\u95ee\u9898\uff08\u5982GitHub Issue\u7b49\uff09\u6216\u4efb\u52a1\uff0c\u53ef\u4ee5\u5728\u63d0\u4ea4\u4fe1\u606f\u4e2d\u5f15\u7528\u76f8\u5173\u7684\u7f16\u53f7\u3002 Github\u539f\u751f\u5f00\u53d1 Actions \u548c Security \u901a\u8fc7 github actions \u548c security\uff08code scanning\uff09\u5b9e\u73b0linux\u3001windows\u3001macos\u5e73\u53f0\u4e0b\u7684 ci \u65b9\u6848\u3002 Issues \u901a\u8fc7 github issues \u767b\u8bb0\u5f00\u53d1\u5de5\u4f5c\uff08\u4fdd\u7559feat\u3001bug\u7b49\u5f00\u53d1\u8db3\u8ff9\uff09\u3002 Discussions \u901a\u8fc7 github discussions \u8fdb\u884c\u56e2\u961f\u6c9f\u901a\u4ea4\u6d41\u3002 \u901a\u8fc7 issues \u5f53\u7136\u4e5f\u53ef\u4ee5\u8ba8\u8bba\uff0c\u4e0d\u8fc7\u66f4\u591a\u662f\u5df2\u786e\u5b9a\u7684 feat \u6216 bug\u3002 Projects \u901a\u8fc7 github projects \u8fdb\u884c\u5f00\u53d1\u8ba1\u5212\u548c\u8fdb\u5ea6\u7ba1\u7406\uff0c\u63a7\u5236\u7248\u672c\u53d1\u5e03 \u3002","title":"Tip3: \u5173\u4e8e\u9879\u76ee\u7684\u53d1\u5e03\u6d41\u7a0b"},{"location":"OpenOasisDevTips/#tip4_1","text":"\u5728\u5f00\u53d1\u8fc7\u7a0b\u4e2d\u57f9\u517b\u4ee3\u7801\u5de5\u7a0b\u7d20\u517b\uff0c\u5bf9\u4ee3\u7801\u201c\u6709\u8bb2\u7a76\u201d\uff0c\u6709\u52a9\u4e8e\u6211\u4eec\u5f00\u53d1\u66f4\u53ef\u9760\u548c\u597d\u7ef4\u62a4\u7684\u6a21\u578b\u6a21\u5757\uff1a \u7edf\u4e00\u7684\u547d\u540d\u903b\u8f91\u3001\u826f\u597d\u7684\u5c01\u88c5\u9694\u79bb\u3001\u6e05\u6670\u7684\u6570\u636e\u6d41\uff0c\u80fd\u5e2e\u52a9\u63a7\u5236\u4ee3\u7801\u7684\u590d\u6742\u5ea6\u3002 \u7f8e\u89c2\u3001\u7b26\u5408\u76f4\u89c9\u3001\u76f4\u767d\u7684\u4ee3\u7801\u3002 \u597d\u7684\u4ee3\u7801\u8bfb\u8d77\u6765\u6709\u4e00\u79cd\u97f5\u5f8b\u611f\uff0c\u80fd\u8ba9\u4eba\u4e00\u5929\u90fd\u5f88\u5f00\u5fc3\u3002 \u5bf9\u4e8e\u5355\u4e2a\u6982\u5ff5\uff0c\u5b9a\u4e49\u597d\u5176\u5185\u6db5\u5916\u5ef6\uff1b\u5bf9\u4e8e\u591a\u4e2a\u6982\u5ff5\uff0c\u68b3\u7406\u597d\u5176\u5c42\u6b21\u5173\u7cfb\u3002\u6620\u5c04\u5230\u4ee3\u7801\u4e0a\uff0c\u5c31\u662f\u4e0d\u540c\u7c7b\u7684\u804c\u8d23\u6e05\u6670\u5212\u5206\u3002 \u4f46\u9700\u8981\u58f0\u660e\uff0c\u4e0d\u540c\u7684\u9636\u6bb5\u5bf9\u8bb2\u7a76\u7a0b\u5ea6\u8981\u6c42\u662f\u4e0d\u4e00\u6837\u7684\uff0c\u5982\u4f55\u6289\u62e9\u5462\uff1f\u8fd9\u91cc\u53ef\u4ee5\u5f15\u5165\u4e00\u4e2a\u53c2\u8003\u5ea6\u91cf\uff1a \u751f\u547d\u5468\u671f \u3002 \u751f\u547d\u5468\u671f\u8d8a\u957f\u7684\u4ee3\u7801\uff0c\u4e00\u5b9a\u8981\u5199\u7684\u8d8a\u5e72\u51c0\uff1b\u4e34\u65f6\u4f7f\u7528\u4ee3\u7801\uff0c\u6bd4\u5982\u539f\u578b\u3001\u811a\u672c\uff0c\u5c31\u53ef\u4ee5\u4e0d\u8bb2\u7a76\u4e00\u4e9b\u3002\u53cd\u8fc7\u6765\uff0c\u4e5f\u6b63\u662f\u5e72\u51c0\u7684\u4ee3\u7801\u624d\u80fd\u6210\u5c31\u8d85\u957f\u7684\u751f\u547d\u5468\u671f\u3002 \u5728\u8f6f\u4ef6\u9879\u76ee\u5f00\u53d1\u4e2d\uff0c\u4ee3\u7801\u7684\u89c4\u8303\u6027\u4e3b\u8981\u5305\u62ec\u51e0\u4e2a\u65b9\u9762\uff1a \u4ee3\u7801\u91cd\u590d\u7387\uff1b \u547d\u540d\u7684\u89c4\u8303\uff1b \u5355\u5143\u6d4b\u8bd5\u7684\u8986\u76d6\u7387\uff1b \u65e5\u5fd7\u6253\u5370\u7684\u89c4\u8303\u6027\u3002 \u7f16\u7801\u98ce\u683c \u7eff\u6d32\u9879\u76ee\u4e2d\u4e3b\u8981\u53c2\u8003 \u534e\u4e3a\u7f16\u7a0b\u98ce\u683c \uff0c\u5dee\u5f02\u5728\u4e8e\uff1a \u6210\u5458\u53d8\u91cf\u7528\u524d\u7f00 m \u6807\u8bc6\uff0c\u4e0d\u9002\u7528\u540e\u7f00 _ \u3002 \u6587\u4ef6\u540d\u53ef\u4ee5\u4f7f\u7528\u5927\u9a7c\u5cf0\u547d\u540d\u3002 \u4ee3\u7801\u6ce8\u91ca \u6211\u4eec\u5b8c\u5168\u4e0d\u4ecb\u610f\u4f60\u7684\u6ce8\u91ca\u662f\u4ee3\u7801\u76842\u500d\u30013\u500d ...\uff0c\u4f60\u7684\u4ee3\u7801\u3001\u4f60\u7684\u6210\u679c\uff0c\u4f60\u60f3\u8bf4\u4ec0\u4e48\u3001\u60f3\u8bf4\u591a\u5c11\u90fd\u53ef\u4ee5\u3002 \u65e5\u5fd7 \u826f\u597d\u7684\u7cfb\u7edf\uff0c\u53ef\u4ee5\u901a\u8fc7\u65e5\u5fd7\u8fdb\u884c\u95ee\u9898\u5b9a\u4e3a\u3002\u9664\u4e86\u5728\u672c\u5730\u4ee3\u7801\u4e0a\u590d\u73b0\u3001\u8c03\u8bd5\u5916\uff0c\u8fd8\u8981\u80fd\u591f\u901a\u8fc7\u4e30\u5bcc\u5408\u7406\u7684\u65e5\u5fd7\u4fe1\u606f\u8fd8\u539f\u95ee\u9898\u73b0\u573a\uff0c\u53d1\u73b0\u9519\u8bef\u4f4d\u7f6e\u548c\u539f\u56e0\u3002 \u4e3a\u4ec0\u4e48\u6253\u65e5\u5fd7 \u8ddf\u8e2a\u7a0b\u5e8f\u7684\u8b66\u544a\u548c\u9519\u8bef\uff0c\u6807\u8bc6\u7a0b\u5e8f\u8fd0\u884c\u4e2d\u7684\u5371\u9669\u64cd\u4f5c\u3001\u9519\u8bef\u64cd\u4f5c\uff1b \u8ddf\u8e2a\u5d29\u6e83bug\uff1b \u8ddf\u8e2a\u6027\u80fd\u4e0b\u964d\u7684\u95ee\u9898\u8303\u56f4\uff0c\u901a\u8fc7\u65e5\u5fd7\u63d0\u4f9b\u7684\u8be6\u7ec6\u6267\u884c\u65f6\u95f4\u8bb0\u5f55\u627e\u51fa\u5e94\u7528\u7684\u6027\u80fd\u74f6\u9888\uff1b \u8ddf\u8e2a\u64cd\u4f5c\u6d41\u7a0b\uff0c\u83b7\u53d6\u64cd\u4f5c\u53d1\u751f\u7684\u5177\u4f53\u73af\u5883\u3001\u64cd\u4f5c\u7684\u7ed3\u679c\uff1b \u4ec0\u4e48\u65f6\u5019\u8be5\u6253\u65e5\u5fd7\uff1f \u7ecf\u5e38\u4ee5\u529f\u80fd\u4e3a\u6838\u5fc3\u8fdb\u884c\u5f00\u53d1\uff0c\u5e94\u8be5\u5728\u63d0\u4ea4\u4ee3\u7801\u524d\uff0c\u53ef\u4ee5\u786e\u5b9a\u901a\u8fc7\u65e5\u5fd7\u53ef\u4ee5\u770b\u5230\u6574\u4e2a\u6d41\u7a0b\uff1b \u65e5\u5fd7\u5206\u7ea7 ERROR \u3002\u8be5\u7ea7\u522b\u65e5\u5fd7\u53d1\u751f\u65f6\uff0c\u5df2\u7ecf\u5f71\u54cd\u4e86\u7528\u6237\u7684\u6b63\u5e38\u4f7f\u7528\uff0c\u901a\u5e38\u7a0b\u5e8f\u629b\u9519\u3001\u4e2d\u6b62\u3002\u4e3b\u8981\u7c7b\u578b\u6709\uff1a \u8bfb\u5199\u914d\u7f6e\u6587\u4ef6\u5931\u8d25 \u6240\u6709\u7b2c\u4e09\u65b9\u5bf9\u63a5\u7684\u5f02\u5e38(\u5305\u62ec\u7b2c\u4e09\u65b9\u8fd4\u56de\u9519\u8bef\u7801) \u6240\u6709\u5f71\u54cd\u529f\u80fd\u4f7f\u7528\u7684\u5f02\u5e38 WARN \u3002\u8be5\u7ea7\u522b\u65e5\u5fd7\u4e0d\u5e94\u8be5\u51fa\u73b0\u4f46\u662f\u4e0d\u5f71\u54cd\u7a0b\u5e8f\u7ee7\u7eed\u8fd0\u884c\u7684\u95ee\u9898\u3002\u4e3b\u8981\u7c7b\u578b\u6709\uff1a \u5f02\u5e38\uff1a\u4e0d\u660e\u786e\u5f02\u5e38\uff0c\u53ea\u8fdb\u884c\u4e86\u7b80\u5355\u7684\u6355\u83b7\u629b\u51fa\uff0c\u9700\u8981\u6253\u5370\u8fd9\u79cd\u7b3c\u7edf\u5904\u7406\u7684\u5f02\u5e38 \u6709\u5bb9\u9519\u673a\u5236\u7684\u65f6\u5019\u51fa\u73b0\u7684\u9519\u8bef\u60c5\u51b5 \u627e\u4e0d\u5230\u914d\u7f6e\u6587\u4ef6\uff0c\u4f46\u662f\u7cfb\u7edf\u80fd\u81ea\u52a8\u521b\u5efa\u914d\u7f6e\u6587\u4ef6 \u6027\u80fd\u5373\u5c06\u63a5\u8fd1\u4e34\u754c\u503c\u7684\u65f6\u5019 \u975e\u9884\u671f\u6267\u884c\uff1a\u4e3a\u7a0b\u5e8f\u5728\u201c\u6709\u53ef\u80fd\u201d\u6267\u884c\u5230\u7684\u5730\u65b9\u6253\u5370\u65e5\u5fd7 switch case \u8bed\u53e5\u5757\u4e2d\u7684 default if else \u8bed\u53e5\u5757\u4e2d\u5f88\u5c11\u51fa\u73b0\u7684 else \u60c5\u51b5 try catch \u8bed\u53e5\u5757\u4e2d catch \u5206\u652f INFO \u3002\u8be5\u7ea7\u522b\u65e5\u5fd7\u4e3b\u8981\u7528\u4e8e\u8bb0\u5f55\u7cfb\u7edf\u8fd0\u884c\u72b6\u6001\u3001\u7b49\u4fe1\u606f\uff0c\u5e38\u7528\u4e8e\u53cd\u9988\u7cfb\u7edf\u5f53\u524d\u72b6\u6001\u7ed9\u7528\u6237\u3002\u4e3b\u8981\u7c7b\u578b\u6709\uff1a \u7cfb\u7edf\u64cd\u4f5c\u884c\u4e3a\uff1a\u8bfb\u5199\u6587\u4ef6\u3001\u5b9a\u65f6\u4efb\u52a1\u7b49 \u4e0d\u7b26\u5408\u4e1a\u52a1\u903b\u8f91\u9884\u671f\uff1a\u6253\u5370\u5173\u952e\u7684\u53c2\u6570 \u5bf9\u5916\u63d0\u4f9b\u7684\u63a5\u53e3\u5165\u53e3\u5904\uff1a\u6253\u5370\u63a5\u53e3\u7684\u552f\u4e00\u6807\u8bc6\u548c\u7b80\u77ed\u63cf\u8ff0\uff0c\u5e76\u4e14\u8981\u5c06\u4f20\u5165\u7684\u53c2\u6570\u539f\u6837\u6253\u5370 \u8c03\u7528\u5176\u5b83\u7cfb\u7edf\u63a5\u53e3\u7684\u524d\u540e\uff1a\u6253\u5370\u6240\u8c03\u7528\u63a5\u53e3\u7684\u7cfb\u7edf\u540d\u79f0/\u63a5\u53e3\u540d\u79f0\u548c\u4f20\u5165\u53c2\u6570/\u54cd\u5e94\u53c2\u6570 \u7cfb\u7edf\u6a21\u5757\u7684\u5165\u53e3\u4e0e\u51fa\u53e3\u5904\uff1a\u53ef\u4ee5\u5728\u91cd\u8981\u65b9\u6cd5\u7ea7\u6216\u6a21\u5757\u7ea7\u8bb0\u5f55\u8f93\u5165\u4e0e\u8f93\u51fa \u670d\u52a1\u72b6\u6001\u53d8\u5316(\u5c3d\u53ef\u80fd\u8bb0\u5f55\u7ebf\u7d22)\uff1a\u7a0b\u5e8f\u4e2d\u91cd\u8981\u7684\u72b6\u6001\u4fe1\u606f\u7684\u53d8\u5316\u5e94\u8be5\u8bb0\u5f55\u4e0b\u6765 \u4e00\u4e9b\u53ef\u80fd\u5f88\u8017\u65f6\u7684\u4e1a\u52a1\u5904\u7406\uff1a\u6279\u5904\u7406\uff0cIO\u64cd\u4f5c \u7a0b\u5e8f\u8fd0\u884c\u8017\u65f6\uff1a\u901a\u8fc7\u5b83\u53ef\u4ee5\u8ddf\u8e2a\u4e3a\u4ec0\u4e48\u7cfb\u7edf\u54cd\u5e94\u53d8\u6162\u6216\u8005\u592a\u5feb \u5927\u6279\u91cf\u6570\u636e\u7684\u6267\u884c\u8fdb\u5ea6 DEBUG \u3002\u8be5\u7ea7\u522b\u65e5\u5fd7\u7684\u4e3b\u8981\u4f5c\u7528\u662f\u5bf9\u7cfb\u7edf\u6bcf\u4e00\u6b65\u7684\u8fd0\u884c\u72b6\u6001\u8fdb\u884c\u7cbe\u786e\u7684\u8bb0\u5f55\u3002 \u6ce8\u610f\uff1a \u5728\u751f\u4ea7\u73af\u5883\u4e2d\u4e0d\u80fd\u6253\u5370DEBUG\u7ea7\u522b\u7684\u65e5\u5fd7\uff0cDEBUG\u7ea7\u522b\u7684\u65e5\u5fd7\u53ea\u80fd\u7528\u4e8e\u5f00\u53d1\u8c03\u8bd5\u6216\u6d4b\u8bd5\u73af\u8282\uff0c\u540c\u65f6\u5728\u8f93\u51faDEBUG\u7ea7\u522b\u7684\u65e5\u5fd7\u7684\u65f6\u5019\uff0c\u4e5f\u5e94\u8be5\u4f9d\u636e\u9879\u76ee\u7ec4\u7684\u5f00\u53d1\u9700\u6c42\u6253\u5370\u65e5\u5fd7\uff0c\u5c3d\u91cf\u505a\u5230\uff1a \u5f00\u53d1\u4eba\u5458\u548c\u6d4b\u8bd5\u4eba\u5458\u90fd\u80fd\u770b\u61c2 \u901a\u8fc7\u9605\u8bfbDEBUG\u7ea7\u522b\u7684\u65e5\u5fd7\u540e\u4e0d\u9700\u8981\u91cd\u73b0\u95ee\u9898\uff0c\u5c31\u80fd\u51c6\u786e\u7684\u5b9a\u4f4d\u89e3\u51b3\u95ee\u9898 \u65e5\u5fd7\u683c\u5f0f \u4f7f\u7528\u53c2\u6570\u5316\u4fe1\u606f\u7684\u65b9\u5f0f\uff1b \u4f7f\u7528 [] \u8fdb\u884c\u53c2\u6570\u53d8\u91cf\u9694\u79bb\uff1b \u76f8\u540c\u7684\u65e5\u5fd7\u4fe1\u606f\u4e0d\u80fd\u5728\u4e0d\u540c\u7ea7\u522b\u4e2d\u91cd\u590d\uff1b \u65e5\u5fd7\u5185\u5bb9\u5305\u62ec \u201c\u65f6\u95f4 \u8fdb\u7a0b|\u7ebf\u7a0b \u7ea7\u522b \u6a21\u5757 Filter(\u7528\u4e8e\u67e5\u627elog) \u5185\u5bb9\u201d\uff1b","title":"Tip4: \u5173\u4e8e\u9879\u76ee\u7684\u7f16\u7801\u98ce\u683c"},{"location":"OpenOasisDevTips/#tipx","text":"\u6682\u65e0\u3002","title":"Tipx: \u4e34\u65f6\u8bf4\u660e"},{"location":"OpenOasisTutorial/","text":"\u7eff\u6d32\u7528\u6237\u6307\u5357 \u00b6 OpenOasis Tutorials Chapt1-\u7b80\u4ecb Chapt1-\u7b80\u4ecb \u00b6 \u6682\u65e0\u3002","title":"Tutorials"},{"location":"OpenOasisTutorial/#_1","text":"OpenOasis Tutorials Chapt1-\u7b80\u4ecb","title":"\u7eff\u6d32\u7528\u6237\u6307\u5357"},{"location":"OpenOasisTutorial/#chapt1-","text":"\u6682\u65e0\u3002","title":"Chapt1-\u7b80\u4ecb"},{"location":"DataAssts/","text":"\u6570\u636e\u5206\u6790\u4e0e\u53ef\u89c6\u5316\u52a9\u624b \u00b6 Data Analysis and Visualization Assistant \u672c\u5355\u5143\u4e3b\u8981\u5173\u6ce8\u6570\u636e\u63d0\u53d6\u3001\u5206\u6790\u548c\u53ef\u89c6\u5316\u5de5\u5177\u3002","title":"Converters"},{"location":"DataAssts/#_1","text":"Data Analysis and Visualization Assistant \u672c\u5355\u5143\u4e3b\u8981\u5173\u6ce8\u6570\u636e\u63d0\u53d6\u3001\u5206\u6790\u548c\u53ef\u89c6\u5316\u5de5\u5177\u3002","title":"\u6570\u636e\u5206\u6790\u4e0e\u53ef\u89c6\u5316\u52a9\u624b"},{"location":"iAgents/","text":"\u7eff\u6d32\u667a\u80fd \u00b6 Oasis Agents \u672c\u5355\u5143\u4e3b\u8981\u8ba8\u8bba\u4eba\u5de5\u667a\u80fd\u6280\u672f\u7684\u884c\u4e1a\u5e94\u7528\u65b9\u6848\u3002 \u7eff\u6d32\u661f\u706b\u667a\u80fd\u6a21\u578b\u6846\u67b6 \u00b6 Spark The Model component is responsible for integrating all the components to form the entire pipeline. Model \u00b6 Model class manage the network, loss function and optimizer. :param net: The network component. :param loss: The loss component. :param optimizer: The optimizer component. Source code in iAgents\\Spark\\model.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Model : \"\"\"Model class manage the network, loss function and optimizer. :param net: The network component. :param loss: The loss component. :param optimizer: The optimizer component. \"\"\" def __init__ ( self , net , loss , optimizer ): self . net = net self . loss = loss self . optimizer = optimizer def forward ( self , inputs : np . ndarray ) -> np . ndarray : \"\"\"Drive forward propagation of net components. :param inputs: The input tensor to the network. :return: The output of the network. \"\"\" return self . net . forward ( inputs ) def backward ( self , predictions : np . ndarray , targets : np . ndarray ) -> tuple : \"\"\"Drive losses component to calculate the losses and gradient, and then drives the net component to back propagate the gradients. :param predictions: The predicted values by the network. :param targets: The target values to be predicted. :return: The loss and gradients of the network. \"\"\" loss = self . loss . loss ( predictions , targets ) grad_from_loss = self . loss . grad ( predictions , targets ) struct_grad = self . net . backward ( grad_from_loss ) return loss , struct_grad def update ( self , grads : np . ndarray ): \"\"\"Drive optimizer component to update the net parameters with the gradients. \"\"\" params = self . net . params self . optimizer . step ( grads , params ) def save ( self , path : str ): \"\"\"Save the model.\"\"\" with open ( path , \"wb\" ) as f : pickle . dump ( self . net . params , f ) def load ( self , path : str ): \"\"\"Load the model.\"\"\" with open ( path , \"rb\" ) as f : params = pickle . load ( f ) self . net . params = params for layer in self . net . layers : layer . is_init = True @property def is_training ( self ): \"\"\"Whether the model is in training mode.\"\"\" return self . net . is_training @is_training . setter def is_training ( self , is_training ): self . net . is_training = is_training is_training property writable \u00b6 Whether the model is in training mode. backward ( predictions , targets ) \u00b6 Drive losses component to calculate the losses and gradient, and then drives the net component to back propagate the gradients. :param predictions: The predicted values by the network. :param targets: The target values to be predicted. :return: The loss and gradients of the network. Source code in iAgents\\Spark\\model.py 31 32 33 34 35 36 37 38 39 40 41 42 43 def backward ( self , predictions : np . ndarray , targets : np . ndarray ) -> tuple : \"\"\"Drive losses component to calculate the losses and gradient, and then drives the net component to back propagate the gradients. :param predictions: The predicted values by the network. :param targets: The target values to be predicted. :return: The loss and gradients of the network. \"\"\" loss = self . loss . loss ( predictions , targets ) grad_from_loss = self . loss . grad ( predictions , targets ) struct_grad = self . net . backward ( grad_from_loss ) return loss , struct_grad forward ( inputs ) \u00b6 Drive forward propagation of net components. :param inputs: The input tensor to the network. :return: The output of the network. Source code in iAgents\\Spark\\model.py 23 24 25 26 27 28 29 def forward ( self , inputs : np . ndarray ) -> np . ndarray : \"\"\"Drive forward propagation of net components. :param inputs: The input tensor to the network. :return: The output of the network. \"\"\" return self . net . forward ( inputs ) load ( path ) \u00b6 Load the model. Source code in iAgents\\Spark\\model.py 57 58 59 60 61 62 63 64 def load ( self , path : str ): \"\"\"Load the model.\"\"\" with open ( path , \"rb\" ) as f : params = pickle . load ( f ) self . net . params = params for layer in self . net . layers : layer . is_init = True save ( path ) \u00b6 Save the model. Source code in iAgents\\Spark\\model.py 52 53 54 55 def save ( self , path : str ): \"\"\"Save the model.\"\"\" with open ( path , \"wb\" ) as f : pickle . dump ( self . net . params , f ) update ( grads ) \u00b6 Drive optimizer component to update the net parameters with the gradients. Source code in iAgents\\Spark\\model.py 45 46 47 48 49 50 def update ( self , grads : np . ndarray ): \"\"\"Drive optimizer component to update the net parameters with the gradients. \"\"\" params = self . net . params self . optimizer . step ( grads , params ) The Net component manages the forward and backpropagation of tensor between layers, and provides interfaces for obtaining parameters, setting parameters, and obtaining gradients. Net \u00b6 Feed-forward Neural Network class. :param layers: a list of Layer objects, in the order they should be connected. Source code in iAgents\\Spark\\net.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class Net : \"\"\"Feed-forward Neural Network class. :param layers: a list of `Layer` objects, in the order they should be connected. \"\"\" def __init__ ( self , layers : list ): self . layers = layers self . _is_training = True def __repr__ ( self ): return \" \\n \" . join ([ str ( layer ) for layer in self . layers ]) def forward ( self , inputs : np . ndarray ) -> np . ndarray : \"\"\"Forward propagation traverses all layers sequentially, with the output of each layer calculated as the input to the next layer. :param inputs: input tensor to the network. :return: result tensor of the network. \"\"\" for layer in self . layers : inputs = layer . forward ( inputs ) return inputs def backward ( self , grad : np . ndarray ) -> StructuredParam : \"\"\"Back propagation traverses all layers in reverse order, using the gradient of each layer as input to the next. :param grad: gradient tensor of the network. :return: structured gradients. \"\"\" # back propagation for layer in reversed ( self . layers ): grad = layer . backward ( grad ) # structured gradients param_grads = [ copy . deepcopy ( layer . grads ) for layer in self . layers ] struct_grads = StructuredParam ( param_grads ) # save the gradients w.r.t the input struct_grads . wrt_input = grad return struct_grads @property def params ( self ): \"\"\"Returns a structured parameter object containing the trainable and non-trainable parameters of all layers in the network. \"\"\" trainable = [ layer . params for layer in self . layers ] non_trainable = [ layer . nt_params for layer in self . layers ] return StructuredParam ( trainable , non_trainable ) @params . setter def params ( self , params ): self . params . values = params . values self . params . nt_values = params . nt_values @property def is_training ( self ): \"\"\"Whether the network is in training mode or not.\"\"\" return self . _is_training @is_training . setter def is_training ( self , is_training ): for layer in self . layers : layer . is_training = is_training self . _is_training = is_training is_training property writable \u00b6 Whether the network is in training mode or not. params property writable \u00b6 Returns a structured parameter object containing the trainable and non-trainable parameters of all layers in the network. backward ( grad ) \u00b6 Back propagation traverses all layers in reverse order, using the gradient of each layer as input to the next. :param grad: gradient tensor of the network. :return: structured gradients. Source code in iAgents\\Spark\\net.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def backward ( self , grad : np . ndarray ) -> StructuredParam : \"\"\"Back propagation traverses all layers in reverse order, using the gradient of each layer as input to the next. :param grad: gradient tensor of the network. :return: structured gradients. \"\"\" # back propagation for layer in reversed ( self . layers ): grad = layer . backward ( grad ) # structured gradients param_grads = [ copy . deepcopy ( layer . grads ) for layer in self . layers ] struct_grads = StructuredParam ( param_grads ) # save the gradients w.r.t the input struct_grads . wrt_input = grad return struct_grads forward ( inputs ) \u00b6 Forward propagation traverses all layers sequentially, with the output of each layer calculated as the input to the next layer. :param inputs: input tensor to the network. :return: result tensor of the network. Source code in iAgents\\Spark\\net.py 25 26 27 28 29 30 31 32 33 34 35 def forward ( self , inputs : np . ndarray ) -> np . ndarray : \"\"\"Forward propagation traverses all layers sequentially, with the output of each layer calculated as the input to the next layer. :param inputs: input tensor to the network. :return: result tensor of the network. \"\"\" for layer in self . layers : inputs = layer . forward ( inputs ) return inputs","title":"Spark"},{"location":"iAgents/#_1","text":"Oasis Agents \u672c\u5355\u5143\u4e3b\u8981\u8ba8\u8bba\u4eba\u5de5\u667a\u80fd\u6280\u672f\u7684\u884c\u4e1a\u5e94\u7528\u65b9\u6848\u3002","title":"\u7eff\u6d32\u667a\u80fd"},{"location":"iAgents/#_2","text":"Spark The Model component is responsible for integrating all the components to form the entire pipeline.","title":"\u7eff\u6d32\u661f\u706b\u667a\u80fd\u6a21\u578b\u6846\u67b6"},{"location":"iAgents/#iAgents.Spark.model.Model","text":"Model class manage the network, loss function and optimizer. :param net: The network component. :param loss: The loss component. :param optimizer: The optimizer component. Source code in iAgents\\Spark\\model.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 class Model : \"\"\"Model class manage the network, loss function and optimizer. :param net: The network component. :param loss: The loss component. :param optimizer: The optimizer component. \"\"\" def __init__ ( self , net , loss , optimizer ): self . net = net self . loss = loss self . optimizer = optimizer def forward ( self , inputs : np . ndarray ) -> np . ndarray : \"\"\"Drive forward propagation of net components. :param inputs: The input tensor to the network. :return: The output of the network. \"\"\" return self . net . forward ( inputs ) def backward ( self , predictions : np . ndarray , targets : np . ndarray ) -> tuple : \"\"\"Drive losses component to calculate the losses and gradient, and then drives the net component to back propagate the gradients. :param predictions: The predicted values by the network. :param targets: The target values to be predicted. :return: The loss and gradients of the network. \"\"\" loss = self . loss . loss ( predictions , targets ) grad_from_loss = self . loss . grad ( predictions , targets ) struct_grad = self . net . backward ( grad_from_loss ) return loss , struct_grad def update ( self , grads : np . ndarray ): \"\"\"Drive optimizer component to update the net parameters with the gradients. \"\"\" params = self . net . params self . optimizer . step ( grads , params ) def save ( self , path : str ): \"\"\"Save the model.\"\"\" with open ( path , \"wb\" ) as f : pickle . dump ( self . net . params , f ) def load ( self , path : str ): \"\"\"Load the model.\"\"\" with open ( path , \"rb\" ) as f : params = pickle . load ( f ) self . net . params = params for layer in self . net . layers : layer . is_init = True @property def is_training ( self ): \"\"\"Whether the model is in training mode.\"\"\" return self . net . is_training @is_training . setter def is_training ( self , is_training ): self . net . is_training = is_training","title":"Model"},{"location":"iAgents/#iAgents.Spark.model.Model.is_training","text":"Whether the model is in training mode.","title":"is_training"},{"location":"iAgents/#iAgents.Spark.model.Model.backward","text":"Drive losses component to calculate the losses and gradient, and then drives the net component to back propagate the gradients. :param predictions: The predicted values by the network. :param targets: The target values to be predicted. :return: The loss and gradients of the network. Source code in iAgents\\Spark\\model.py 31 32 33 34 35 36 37 38 39 40 41 42 43 def backward ( self , predictions : np . ndarray , targets : np . ndarray ) -> tuple : \"\"\"Drive losses component to calculate the losses and gradient, and then drives the net component to back propagate the gradients. :param predictions: The predicted values by the network. :param targets: The target values to be predicted. :return: The loss and gradients of the network. \"\"\" loss = self . loss . loss ( predictions , targets ) grad_from_loss = self . loss . grad ( predictions , targets ) struct_grad = self . net . backward ( grad_from_loss ) return loss , struct_grad","title":"backward"},{"location":"iAgents/#iAgents.Spark.model.Model.forward","text":"Drive forward propagation of net components. :param inputs: The input tensor to the network. :return: The output of the network. Source code in iAgents\\Spark\\model.py 23 24 25 26 27 28 29 def forward ( self , inputs : np . ndarray ) -> np . ndarray : \"\"\"Drive forward propagation of net components. :param inputs: The input tensor to the network. :return: The output of the network. \"\"\" return self . net . forward ( inputs )","title":"forward"},{"location":"iAgents/#iAgents.Spark.model.Model.load","text":"Load the model. Source code in iAgents\\Spark\\model.py 57 58 59 60 61 62 63 64 def load ( self , path : str ): \"\"\"Load the model.\"\"\" with open ( path , \"rb\" ) as f : params = pickle . load ( f ) self . net . params = params for layer in self . net . layers : layer . is_init = True","title":"load"},{"location":"iAgents/#iAgents.Spark.model.Model.save","text":"Save the model. Source code in iAgents\\Spark\\model.py 52 53 54 55 def save ( self , path : str ): \"\"\"Save the model.\"\"\" with open ( path , \"wb\" ) as f : pickle . dump ( self . net . params , f )","title":"save"},{"location":"iAgents/#iAgents.Spark.model.Model.update","text":"Drive optimizer component to update the net parameters with the gradients. Source code in iAgents\\Spark\\model.py 45 46 47 48 49 50 def update ( self , grads : np . ndarray ): \"\"\"Drive optimizer component to update the net parameters with the gradients. \"\"\" params = self . net . params self . optimizer . step ( grads , params ) The Net component manages the forward and backpropagation of tensor between layers, and provides interfaces for obtaining parameters, setting parameters, and obtaining gradients.","title":"update"},{"location":"iAgents/#iAgents.Spark.net.Net","text":"Feed-forward Neural Network class. :param layers: a list of Layer objects, in the order they should be connected. Source code in iAgents\\Spark\\net.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class Net : \"\"\"Feed-forward Neural Network class. :param layers: a list of `Layer` objects, in the order they should be connected. \"\"\" def __init__ ( self , layers : list ): self . layers = layers self . _is_training = True def __repr__ ( self ): return \" \\n \" . join ([ str ( layer ) for layer in self . layers ]) def forward ( self , inputs : np . ndarray ) -> np . ndarray : \"\"\"Forward propagation traverses all layers sequentially, with the output of each layer calculated as the input to the next layer. :param inputs: input tensor to the network. :return: result tensor of the network. \"\"\" for layer in self . layers : inputs = layer . forward ( inputs ) return inputs def backward ( self , grad : np . ndarray ) -> StructuredParam : \"\"\"Back propagation traverses all layers in reverse order, using the gradient of each layer as input to the next. :param grad: gradient tensor of the network. :return: structured gradients. \"\"\" # back propagation for layer in reversed ( self . layers ): grad = layer . backward ( grad ) # structured gradients param_grads = [ copy . deepcopy ( layer . grads ) for layer in self . layers ] struct_grads = StructuredParam ( param_grads ) # save the gradients w.r.t the input struct_grads . wrt_input = grad return struct_grads @property def params ( self ): \"\"\"Returns a structured parameter object containing the trainable and non-trainable parameters of all layers in the network. \"\"\" trainable = [ layer . params for layer in self . layers ] non_trainable = [ layer . nt_params for layer in self . layers ] return StructuredParam ( trainable , non_trainable ) @params . setter def params ( self , params ): self . params . values = params . values self . params . nt_values = params . nt_values @property def is_training ( self ): \"\"\"Whether the network is in training mode or not.\"\"\" return self . _is_training @is_training . setter def is_training ( self , is_training ): for layer in self . layers : layer . is_training = is_training self . _is_training = is_training","title":"Net"},{"location":"iAgents/#iAgents.Spark.net.Net.is_training","text":"Whether the network is in training mode or not.","title":"is_training"},{"location":"iAgents/#iAgents.Spark.net.Net.params","text":"Returns a structured parameter object containing the trainable and non-trainable parameters of all layers in the network.","title":"params"},{"location":"iAgents/#iAgents.Spark.net.Net.backward","text":"Back propagation traverses all layers in reverse order, using the gradient of each layer as input to the next. :param grad: gradient tensor of the network. :return: structured gradients. Source code in iAgents\\Spark\\net.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def backward ( self , grad : np . ndarray ) -> StructuredParam : \"\"\"Back propagation traverses all layers in reverse order, using the gradient of each layer as input to the next. :param grad: gradient tensor of the network. :return: structured gradients. \"\"\" # back propagation for layer in reversed ( self . layers ): grad = layer . backward ( grad ) # structured gradients param_grads = [ copy . deepcopy ( layer . grads ) for layer in self . layers ] struct_grads = StructuredParam ( param_grads ) # save the gradients w.r.t the input struct_grads . wrt_input = grad return struct_grads","title":"backward"},{"location":"iAgents/#iAgents.Spark.net.Net.forward","text":"Forward propagation traverses all layers sequentially, with the output of each layer calculated as the input to the next layer. :param inputs: input tensor to the network. :return: result tensor of the network. Source code in iAgents\\Spark\\net.py 25 26 27 28 29 30 31 32 33 34 35 def forward ( self , inputs : np . ndarray ) -> np . ndarray : \"\"\"Forward propagation traverses all layers sequentially, with the output of each layer calculated as the input to the next layer. :param inputs: input tensor to the network. :return: result tensor of the network. \"\"\" for layer in self . layers : inputs = layer . forward ( inputs ) return inputs","title":"forward"},{"location":"models/annotated/","text":"Class List \u00b6 Here are the classes, structs, unions and interfaces with brief descriptions: namespace DevSupports namespace OpenOasis namespace AdditionalControl class IComparable Interface class provides a unified interface for object comparison. class ISpaceExtension class ITimeExtension Methods that are specific for a time-space component. namespace CommImp namespace IO class LinkLoader Class forLoading components coupling configurations json file. class MeshLoader Default Mesh data loader. class TaskLoader Loading components task configurations yaml file. namespace Numeric class Boundary Abstract boundary class. struct BoundaryCondition Boundary condition struct. class DirichletBoundary Dirichlet boundary. class DoubleSparseMatrix Sparse matrix having double elements. struct EqualFunc struct HashFunc class Index namespace FVM class FvmSolver class Field The abstract field class used to represent numeric field, such as scalar, vector or tensor data. class Laplacian Laplacian operator for the divergence of the gradient of a scalar field. class Matrix class Operator Abstract operator class. class ScalarField Scaler field. class Solver Abstract solver class. class Source class Tensor class TensorField Tensor field. class Vector class VectorField Vector field with default zero vector in 2D or 3D space. namespace Spatial struct Cell Mesh cell data structure. Polygon type for 1D and 2D mesh, Polyhedron type for 3D mesh. struct Coordinate The Coordinate struct contains a (x, y, z) coordinate. struct Face Mesh face data structure. Polyline type for 1D or 2D mesh, Polygon type for 3D mesh. class GeoCalculator The GeoCalculator is a collection of general geometry functions. class Grid Grid encapsulate the mesh data for numerical calculation. class Grid1D class Grid2D Grid formed by flat cells in 2d. class Grid3D struct Mesh Mesh structure. struct Node Mesh node data structure. (Point type). struct XYExtent Extent is a rectangle in xy-space. class XYGeoTools The XYGeoTools class is a collection of general geometry functions. struct XYLine The XYline struct is used for representing a line segment. struct XYPoint XYPoint is simply a x and y coordinate point (has no z coordinate). struct XYPolygon The XYPolygon struct defines a polygon in the XY plane (no z coordinate). struct XYPolyline XYPolyline is a collection of points (at least 2) connected with straigth lines. XYPolylines are typically used for presentation of 1D data, river network. namespace Temporal class TimeBuffer The TimeBuffer class provides temporal buffering functionality. class ExchangeItemChangeEventArgs Class containing the information that will be passed when firing an ExchangeItemValueChanged event. class IAdaptedOutput Extension class for adding data operations on top of an output item. class IAdaptedOutputFactory Factory class for creating instances of IAdaptedOutput items. class IArgument Class for providing arguments for an ILinkableComponent and others. class IBaseExchangeItem Class presenting a item that can be exchanged, either as an input or output. class IByteStateConverter An optional interface to save and transform the model state. class ICategory Class describes one item of a possible categorization. class IDescribable An entity that is describable has a caption (title or heading) and a description. These are not to be used for identification. class IDimension Define the order of each dimension in DimensionBase for a unit. class IElementSet An list of elements having a common type. class IIdentifiable To define a method to get the Id of an OpenOasis entity. class IInput An input item that can accept values for an ILinkableComponent . The input item may have multiple providers. class ILinkableComponent The key interface class for linkable modules connection and data transfer. class IManageState It provides additional methods for handling component state so it can be saved, restored and cleared. class IOutput Output exchange item that can deliver values from an ILinkableComponent . class IQuality Class describes qualitative data, where a value is specified as one category within a number of predefined (possible) categories. class IQuantity Class specifies values as an amount of some unit. class ISpatialDefinition General spatial construct that all other spatial constructions extend from. class ITime Time interface to support a time stamp as well as a time interval. class ITimeSet Set of time stamps or time intervals, used to indicate when an output has and can provide values, and when an input item does or may require values. class IUnit Unit interface describes the physical unit. class IValueDefinition Class describes value definition. class IValueSet Class represents a general(ordered) multi-dimensional set of values. class LinkableComponentStatusChangeEventArgs Class contains the information that will be passed when the ILinkableComponent fires the StatusChanged event. namespace SystHeats class HeatConductionModel namespace Utils namespace std","title":"Class List"},{"location":"models/annotated/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions: namespace DevSupports namespace OpenOasis namespace AdditionalControl class IComparable Interface class provides a unified interface for object comparison. class ISpaceExtension class ITimeExtension Methods that are specific for a time-space component. namespace CommImp namespace IO class LinkLoader Class forLoading components coupling configurations json file. class MeshLoader Default Mesh data loader. class TaskLoader Loading components task configurations yaml file. namespace Numeric class Boundary Abstract boundary class. struct BoundaryCondition Boundary condition struct. class DirichletBoundary Dirichlet boundary. class DoubleSparseMatrix Sparse matrix having double elements. struct EqualFunc struct HashFunc class Index namespace FVM class FvmSolver class Field The abstract field class used to represent numeric field, such as scalar, vector or tensor data. class Laplacian Laplacian operator for the divergence of the gradient of a scalar field. class Matrix class Operator Abstract operator class. class ScalarField Scaler field. class Solver Abstract solver class. class Source class Tensor class TensorField Tensor field. class Vector class VectorField Vector field with default zero vector in 2D or 3D space. namespace Spatial struct Cell Mesh cell data structure. Polygon type for 1D and 2D mesh, Polyhedron type for 3D mesh. struct Coordinate The Coordinate struct contains a (x, y, z) coordinate. struct Face Mesh face data structure. Polyline type for 1D or 2D mesh, Polygon type for 3D mesh. class GeoCalculator The GeoCalculator is a collection of general geometry functions. class Grid Grid encapsulate the mesh data for numerical calculation. class Grid1D class Grid2D Grid formed by flat cells in 2d. class Grid3D struct Mesh Mesh structure. struct Node Mesh node data structure. (Point type). struct XYExtent Extent is a rectangle in xy-space. class XYGeoTools The XYGeoTools class is a collection of general geometry functions. struct XYLine The XYline struct is used for representing a line segment. struct XYPoint XYPoint is simply a x and y coordinate point (has no z coordinate). struct XYPolygon The XYPolygon struct defines a polygon in the XY plane (no z coordinate). struct XYPolyline XYPolyline is a collection of points (at least 2) connected with straigth lines. XYPolylines are typically used for presentation of 1D data, river network. namespace Temporal class TimeBuffer The TimeBuffer class provides temporal buffering functionality. class ExchangeItemChangeEventArgs Class containing the information that will be passed when firing an ExchangeItemValueChanged event. class IAdaptedOutput Extension class for adding data operations on top of an output item. class IAdaptedOutputFactory Factory class for creating instances of IAdaptedOutput items. class IArgument Class for providing arguments for an ILinkableComponent and others. class IBaseExchangeItem Class presenting a item that can be exchanged, either as an input or output. class IByteStateConverter An optional interface to save and transform the model state. class ICategory Class describes one item of a possible categorization. class IDescribable An entity that is describable has a caption (title or heading) and a description. These are not to be used for identification. class IDimension Define the order of each dimension in DimensionBase for a unit. class IElementSet An list of elements having a common type. class IIdentifiable To define a method to get the Id of an OpenOasis entity. class IInput An input item that can accept values for an ILinkableComponent . The input item may have multiple providers. class ILinkableComponent The key interface class for linkable modules connection and data transfer. class IManageState It provides additional methods for handling component state so it can be saved, restored and cleared. class IOutput Output exchange item that can deliver values from an ILinkableComponent . class IQuality Class describes qualitative data, where a value is specified as one category within a number of predefined (possible) categories. class IQuantity Class specifies values as an amount of some unit. class ISpatialDefinition General spatial construct that all other spatial constructions extend from. class ITime Time interface to support a time stamp as well as a time interval. class ITimeSet Set of time stamps or time intervals, used to indicate when an output has and can provide values, and when an input item does or may require values. class IUnit Unit interface describes the physical unit. class IValueDefinition Class describes value definition. class IValueSet Class represents a general(ordered) multi-dimensional set of values. class LinkableComponentStatusChangeEventArgs Class contains the information that will be passed when the ILinkableComponent fires the StatusChanged event. namespace SystHeats class HeatConductionModel namespace Utils namespace std","title":"Class List"},{"location":"models/files/","text":"File List \u00b6 Here is a list of all files with brief descriptions: dir Models dir CommImp dir IO file LinkLoader.cpp file LinkLoader.h file Logger.cpp file Logger.h file MeshLoader.cpp file MeshLoader.h file NetworkLoader.h file OutputCsv.h file TaskLoader.h dir Numeric file Boundary.h file CurlOperator.h file DdtOperator.h file DirichletBoundary.cpp file DirichletBoundary.h file DivOperator.h file Field.h file GradOperator.h file Interps.cpp file Interps.h file LaplacianOperator.cpp file LaplacianOperator.h file Matrix.cpp file Matrix.h dir FVM file FvmSolver.cpp file FvmSolver.h file NeumannBoundary.h file NumericMethods.h file Operator.h file RobinBoundary.h file ScalarField.h file Solver.h file Source.h file Tensor.h file TensorField.h file Vector.h file VectorField.h dir Spatial file Coordinate.cpp file Coordinate.h file GeoCalculator.cpp file GeoCalculator.h file Grid.cpp file Grid.h file Grid1D.cpp file Grid1D.h file Grid2D.cpp file Grid2D.h file Grid3D.cpp file Grid3D.h file MeshStructs.h file XYGeoStructs.cpp file XYGeoStructs.h file XYGeoTools.cpp file XYGeoTools.h dir Temporal file TimeBuffer.cpp file TimeBuffer.h dir Inc file ExchangeItemChangeEventArgs.h file IAdaptedOutput.h file IAdaptedOutputFactory.h file IArgument.h file IBaseExchangeItem.h file IByteStateConverter.h file ICategory.h file IDescribable.h file IDimension.h file IElementSet.h file IIdentifiable.h file IInput.h file ILinkableComponent.h file IManageState.h file IOutput.h file IQuality.h file IQuantity.h file ISpatialDefinition.h file ITime.h file ITimeSet.h file IUnit.h file IValueDefinition.h file IValueSet.h file LinkableComponentStatus.h file LinkableComponentStatusChangeEventArgs.h dir AdditionalControl file IComparable.h file ISpaceExtension.h file ITimeExtension.h dir SystHeats dir HeatConductionModel file HeatConductionModel.cpp file HeatConductionModel.h","title":"File List"},{"location":"models/files/#file-list","text":"Here is a list of all files with brief descriptions: dir Models dir CommImp dir IO file LinkLoader.cpp file LinkLoader.h file Logger.cpp file Logger.h file MeshLoader.cpp file MeshLoader.h file NetworkLoader.h file OutputCsv.h file TaskLoader.h dir Numeric file Boundary.h file CurlOperator.h file DdtOperator.h file DirichletBoundary.cpp file DirichletBoundary.h file DivOperator.h file Field.h file GradOperator.h file Interps.cpp file Interps.h file LaplacianOperator.cpp file LaplacianOperator.h file Matrix.cpp file Matrix.h dir FVM file FvmSolver.cpp file FvmSolver.h file NeumannBoundary.h file NumericMethods.h file Operator.h file RobinBoundary.h file ScalarField.h file Solver.h file Source.h file Tensor.h file TensorField.h file Vector.h file VectorField.h dir Spatial file Coordinate.cpp file Coordinate.h file GeoCalculator.cpp file GeoCalculator.h file Grid.cpp file Grid.h file Grid1D.cpp file Grid1D.h file Grid2D.cpp file Grid2D.h file Grid3D.cpp file Grid3D.h file MeshStructs.h file XYGeoStructs.cpp file XYGeoStructs.h file XYGeoTools.cpp file XYGeoTools.h dir Temporal file TimeBuffer.cpp file TimeBuffer.h dir Inc file ExchangeItemChangeEventArgs.h file IAdaptedOutput.h file IAdaptedOutputFactory.h file IArgument.h file IBaseExchangeItem.h file IByteStateConverter.h file ICategory.h file IDescribable.h file IDimension.h file IElementSet.h file IIdentifiable.h file IInput.h file ILinkableComponent.h file IManageState.h file IOutput.h file IQuality.h file IQuantity.h file ISpatialDefinition.h file ITime.h file ITimeSet.h file IUnit.h file IValueDefinition.h file IValueSet.h file LinkableComponentStatus.h file LinkableComponentStatusChangeEventArgs.h dir AdditionalControl file IComparable.h file ISpaceExtension.h file ITimeExtension.h dir SystHeats dir HeatConductionModel file HeatConductionModel.cpp file HeatConductionModel.h","title":"File List"},{"location":"models/namespace_dev_supports/","text":"Namespace DevSupports \u00b6 Namespace List > DevSupports The documentation for this class was generated from the following file Models/CommImp/Temporal/TimeBuffer.cpp","title":"Namespace DevSupports"},{"location":"models/namespace_dev_supports/#namespace-devsupports","text":"Namespace List > DevSupports The documentation for this class was generated from the following file Models/CommImp/Temporal/TimeBuffer.cpp","title":"Namespace DevSupports"},{"location":"models/namespace_open_oasis/","text":"Namespace OpenOasis \u00b6 Namespace List > OpenOasis More... Namespaces \u00b6 Type Name namespace AdditionalControl namespace CommImp namespace SystHeats Classes \u00b6 Type Name class ExchangeItemChangeEventArgs Class containing the information that will be passed when firing an ExchangeItemValueChanged event. class IAdaptedOutput Extension class for adding data operations on top of an output item. class IAdaptedOutputFactory Factory class for creating instances of IAdaptedOutput items. class IArgument Class for providing arguments for an ILinkableComponent and others. class IBaseExchangeItem Class presenting a item that can be exchanged, either as an input or output. class IByteStateConverter An optional interface to save and transform the model state. class ICategory Class describes one item of a possible categorization. class IDescribable An entity that is describable has a caption (title or heading) and a description. These are not to be used for identification. class IDimension Define the order of each dimension in DimensionBase for a unit. class IElementSet An list of elements having a common type. class IIdentifiable To define a method to get the Id of an OpenOasis entity. class IInput An input item that can accept values for an ILinkableComponent . The input item may have multiple providers. class ILinkableComponent The key interface class for linkable modules connection and data transfer. class IManageState It provides additional methods for handling component state so it can be saved, restored and cleared. class IOutput Output exchange item that can deliver values from an ILinkableComponent . class IQuality Class describes qualitative data, where a value is specified as one category within a number of predefined (possible) categories. class IQuantity Class specifies values as an amount of some unit. class ISpatialDefinition General spatial construct that all other spatial constructions extend from. class ITime Time interface to support a time stamp as well as a time interval. class ITimeSet Set of time stamps or time intervals, used to indicate when an output has and can provide values, and when an input item does or may require values. class IUnit Unit interface describes the physical unit. class IValueDefinition Class describes value definition. class IValueSet Class represents a general(ordered) multi-dimensional set of values. class LinkableComponentStatusChangeEventArgs Class contains the information that will be passed when the ILinkableComponent fires the StatusChanged event. Public Types \u00b6 Type Name enum DimensionBase Enumeration for base dimensions. enum ElementType Shape Type of elements in an IElementSet . enum LinkableComponentStatus Class enumerates the possible statuses that a linkable component can be in. Detailed Description \u00b6 Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IComparable.h @License : Apache-2.0 @Desc : To provide a unified interface for object comparison. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ISpaceExtension.h @License : Apache-2.0 @Desc : Spatial information (usually an element set) on the values. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ITimeExtension.h @License : Apache-2.0 @Desc : Methods that are specific for an time-space component. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ExchangeItemChangeEventArgs.h @License : Apache-2.0 @Desc : To contain the information that will be passed when the IBaseExchangeItem fires the ExchangeItemValueChanged event. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IAdaptedOutput.h @License : Apache-2.0 @Desc : To adds one or more data operations on top of an output item. IAdaptedOutput objects are created by means of an IAdaptedOutputFactory . It is based on the adaptor design pattern.It adapts an IOutput or another IAdaptedOutput to make it suitable for new use or purpose. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IAdaptedOutputFactory.h @License : Apache-2.0 @Desc : Factory to create instance of IAdaptedOutput . Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IArgument.h @License : Apache-2.0 @Desc : To provide an argument interface. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IBaseExchangeItem.h @License : Apache-2.0 @Desc : To provide an item that can be exchanged, either as input or output. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IByteStateConverter.h @License : Apache-2.0 @Desc : An optional complement to support state management. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ICategory.h @License : Apache-2.0 @Desc : To describe one item of a possible categorization. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IDescribable.h @License : Apache-2.0 @Desc : To provide descriptive information on an OpenOasis entity. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IDimension.h @License : Apache-2.0 @Desc : To define the order of dimension in each DimensionBase for a unit. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IElementSet.h @License : Apache-2.0 @Desc : To provide an ordered list of elements for data exchanging. Data exchange between components is nearly always related to one or more elements in a space, either geo-referenced or not. An elementset can be a list of 2D or 3D spatial elements or as a special case, a list of ID based (non spatial) elements. Possible element types are defined in ElementType . For 3D elements (i.e. polyhedron) the shape can be queried by face. When the elementset is geo-referenced, coordinates (X, Y, Z) can be obtained for each node of an element. A geo-referenced elementset needs to have a valid \"SpatialReferenceSystem\" property set in a ISpatialDefinition . This is a string that specifies the OGC WKT representation of a spatial reference. An empty string indicates that there in no spatial reference, which is only valid if the ElementType is IdBased . While an IElementSet can be used to query the geometric description of a model schematization, it does not necessarily provide all topological knowledge on inter-element connections. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IIdentifiable.h @License : Apache-2.0 @Desc : To provide the id of an OpenOasis entity. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IInput.h @License : Apache-2.0 @Desc : To provide an input item that can accept values for an ILinkableComponent object. This item is a combination of an IValueDefinition , an IElementSet , and an ITimeSet . This combination specifies which type of data is required, where and when, as input for an ILinkableComponent . Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ILinkableComponent.h @License : Apache-2.0 @Desc : To provide key interface for module connection and data transfer. An OpenOasis compliant component must implement the ILinkableComponent interface according to specifications provided from OpenOasis docs; An OpenOasis compliant component can also comply to one ore more extensions, by implementing the ILinkableComponent interface and the extension interfaces, according to the specifications; Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IManageState.h @License : Apache-2.0 @Desc : To provide an optional interface to handling component state so it can be saved, restored and cleared. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IOutput.h @License : Apache-2.0 @Desc : To provide an output exchange item that can deliver values from an ILinkableComponent . Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IQuality.h @License : Apache-2.0 @Desc : To describe qualitative data, where a value is specified as one category within a number of predefined (possible) categories. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IQuantity.h @License : Apache-2.0 @Desc : Specify values as an amount of some unit. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ISpatialDefinition.h @License : Apache-2.0 @Desc : To provide a general spatial construct that all other spatial constructions extend from. Data in component is often related to spatial coordinates, either georeferenced or not. Although most models encapsulate data with a static spatial definition, some advanced models might contain dynamic spatial definitions (e.g. waves, moving grids). A Version number has been introduced to enable tracking of spatial changes over time. If the version changes, the spatial definition might need to be queried again during the computation process. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ITime.h @License : Apache-2.0 @Desc : Time interface to support a time stamp as well as a time interval. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ITimeSet.h @License : Apache-2.0 @Desc : A set of time stamps or time intervals, used to indicate when an output item has values and can provide values, and when an input item does or may require values. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IUnit.h @License : Apache-2.0 @Desc : To describe the physical unit of IQuantity . Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IValueDefinition.h @License : Apache-2.0 @Desc : To provide value definition description of an OpenOasis entity. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IValueSet.h @License : Apache-2.0 @Desc : To represent a general multi-dimensional set of values. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : LinkableComponentStatus.h @License : Apache-2.0 @Desc : To enumerate the possible statuses that a linkable component can be. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : LinkableComponentStatusChangeEventArgs.h @License : Apache-2.0 @Desc : To contain the information that will be passed when the ILinkableComponent fires the StatusChanged event. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : HeatConductionModel.h @License : Apache-2.0 @Desc : A dummy heat conduction model used for example purposes. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : Logger.h @License : Apache-2.0 @Desc : Provide logger. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : Tensor.h @License : Apache-2.0 @Desc : Define Tensor template class for numerical calculation. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : Vector.h @License : Apache-2.0 @Desc : Define Vector template class for numerical calculation. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : TimeBuffer.h @License : Apache-2.0 @Desc : To provide temporal buffering functionalities. The TimeBuffer class provides buffering functionalities that will store values needed for a particular output item in memory and functionality that will interpolate, extrapolate and aggregate values from these values. The content of the TimeBuffer is lists of corresponding times and ValueSets, where times can be TimeStamps or TimeSpans and the ValueSets are double[]. TimeBuffer objects may not contain mixtures of TimeSpans and TimeStamps. The number of Times (TimeSpans or TimeStamps) must equal the number of value sets (double[]) in the TimeBuffer. When time spans are put in the buffer, it is assumed that there aren't holes between the spans, i.e. a time setup of: |-|-| |-|-| a b c d e f where data is missing between c and d isn't allowed (a value of 0 is assumed in such an interval). Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : GeoCalculator.h @License : Apache-2.0 @Desc : A collection of general geometry functions. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Grid1D.h @License : Apache-2.0 @Desc : Grid in river net used for numerical calculation. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Grid2D.h @License : Apache-2.0 @Desc : Grid formed by flat cells in 2d used for numerical calculation. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Grid3D.h @License : Apache-2.0 @Desc : Grid in 3d used for numerical calculation. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : MeshStructs.h @License : Apache-2.0 @Desc : Definitions of mesh related structures. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : XYGeoStructs.h @License : Apache-2.0 @Desc : To provide basic plane geometry data structures (no z coordinate). Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : XYGeoTools.h @License : Apache-2.0 @Desc : The XYGeoTools class is a collection of general geometry functions. Public Types Documentation \u00b6 enum DimensionBase \u00b6 enum OpenOasis :: DimensionBase { Length , Mass , Time , ElectricCurrent , Temperature , AmountOfSubstance , LuminousIntensity , Currency }; enum ElementType \u00b6 enum OpenOasis :: ElementType { IdBased , Point , Polyline , Polygon , Polyhedron }; enum LinkableComponentStatus \u00b6 enum OpenOasis :: LinkableComponentStatus { Created , Initializing , Initialized , Validating , Valid , WaitingForData , Invalid , Preparing , Updating , Updated , Done , Finishing , Finished , Failed }; The documentation for this class was generated from the following file Models/Inc/AdditionalControl/IComparable.h","title":"Oasis API"},{"location":"models/namespace_open_oasis/#namespace-openoasis","text":"Namespace List > OpenOasis More...","title":"Namespace OpenOasis"},{"location":"models/namespace_open_oasis/#namespaces","text":"Type Name namespace AdditionalControl namespace CommImp namespace SystHeats","title":"Namespaces"},{"location":"models/namespace_open_oasis/#classes","text":"Type Name class ExchangeItemChangeEventArgs Class containing the information that will be passed when firing an ExchangeItemValueChanged event. class IAdaptedOutput Extension class for adding data operations on top of an output item. class IAdaptedOutputFactory Factory class for creating instances of IAdaptedOutput items. class IArgument Class for providing arguments for an ILinkableComponent and others. class IBaseExchangeItem Class presenting a item that can be exchanged, either as an input or output. class IByteStateConverter An optional interface to save and transform the model state. class ICategory Class describes one item of a possible categorization. class IDescribable An entity that is describable has a caption (title or heading) and a description. These are not to be used for identification. class IDimension Define the order of each dimension in DimensionBase for a unit. class IElementSet An list of elements having a common type. class IIdentifiable To define a method to get the Id of an OpenOasis entity. class IInput An input item that can accept values for an ILinkableComponent . The input item may have multiple providers. class ILinkableComponent The key interface class for linkable modules connection and data transfer. class IManageState It provides additional methods for handling component state so it can be saved, restored and cleared. class IOutput Output exchange item that can deliver values from an ILinkableComponent . class IQuality Class describes qualitative data, where a value is specified as one category within a number of predefined (possible) categories. class IQuantity Class specifies values as an amount of some unit. class ISpatialDefinition General spatial construct that all other spatial constructions extend from. class ITime Time interface to support a time stamp as well as a time interval. class ITimeSet Set of time stamps or time intervals, used to indicate when an output has and can provide values, and when an input item does or may require values. class IUnit Unit interface describes the physical unit. class IValueDefinition Class describes value definition. class IValueSet Class represents a general(ordered) multi-dimensional set of values. class LinkableComponentStatusChangeEventArgs Class contains the information that will be passed when the ILinkableComponent fires the StatusChanged event.","title":"Classes"},{"location":"models/namespace_open_oasis/#public-types","text":"Type Name enum DimensionBase Enumeration for base dimensions. enum ElementType Shape Type of elements in an IElementSet . enum LinkableComponentStatus Class enumerates the possible statuses that a linkable component can be in.","title":"Public Types"},{"location":"models/namespace_open_oasis/#detailed-description","text":"Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IComparable.h @License : Apache-2.0 @Desc : To provide a unified interface for object comparison. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ISpaceExtension.h @License : Apache-2.0 @Desc : Spatial information (usually an element set) on the values. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ITimeExtension.h @License : Apache-2.0 @Desc : Methods that are specific for an time-space component. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ExchangeItemChangeEventArgs.h @License : Apache-2.0 @Desc : To contain the information that will be passed when the IBaseExchangeItem fires the ExchangeItemValueChanged event. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IAdaptedOutput.h @License : Apache-2.0 @Desc : To adds one or more data operations on top of an output item. IAdaptedOutput objects are created by means of an IAdaptedOutputFactory . It is based on the adaptor design pattern.It adapts an IOutput or another IAdaptedOutput to make it suitable for new use or purpose. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IAdaptedOutputFactory.h @License : Apache-2.0 @Desc : Factory to create instance of IAdaptedOutput . Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IArgument.h @License : Apache-2.0 @Desc : To provide an argument interface. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IBaseExchangeItem.h @License : Apache-2.0 @Desc : To provide an item that can be exchanged, either as input or output. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IByteStateConverter.h @License : Apache-2.0 @Desc : An optional complement to support state management. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ICategory.h @License : Apache-2.0 @Desc : To describe one item of a possible categorization. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IDescribable.h @License : Apache-2.0 @Desc : To provide descriptive information on an OpenOasis entity. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IDimension.h @License : Apache-2.0 @Desc : To define the order of dimension in each DimensionBase for a unit. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IElementSet.h @License : Apache-2.0 @Desc : To provide an ordered list of elements for data exchanging. Data exchange between components is nearly always related to one or more elements in a space, either geo-referenced or not. An elementset can be a list of 2D or 3D spatial elements or as a special case, a list of ID based (non spatial) elements. Possible element types are defined in ElementType . For 3D elements (i.e. polyhedron) the shape can be queried by face. When the elementset is geo-referenced, coordinates (X, Y, Z) can be obtained for each node of an element. A geo-referenced elementset needs to have a valid \"SpatialReferenceSystem\" property set in a ISpatialDefinition . This is a string that specifies the OGC WKT representation of a spatial reference. An empty string indicates that there in no spatial reference, which is only valid if the ElementType is IdBased . While an IElementSet can be used to query the geometric description of a model schematization, it does not necessarily provide all topological knowledge on inter-element connections. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IIdentifiable.h @License : Apache-2.0 @Desc : To provide the id of an OpenOasis entity. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IInput.h @License : Apache-2.0 @Desc : To provide an input item that can accept values for an ILinkableComponent object. This item is a combination of an IValueDefinition , an IElementSet , and an ITimeSet . This combination specifies which type of data is required, where and when, as input for an ILinkableComponent . Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ILinkableComponent.h @License : Apache-2.0 @Desc : To provide key interface for module connection and data transfer. An OpenOasis compliant component must implement the ILinkableComponent interface according to specifications provided from OpenOasis docs; An OpenOasis compliant component can also comply to one ore more extensions, by implementing the ILinkableComponent interface and the extension interfaces, according to the specifications; Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IManageState.h @License : Apache-2.0 @Desc : To provide an optional interface to handling component state so it can be saved, restored and cleared. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IOutput.h @License : Apache-2.0 @Desc : To provide an output exchange item that can deliver values from an ILinkableComponent . Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IQuality.h @License : Apache-2.0 @Desc : To describe qualitative data, where a value is specified as one category within a number of predefined (possible) categories. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IQuantity.h @License : Apache-2.0 @Desc : Specify values as an amount of some unit. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ISpatialDefinition.h @License : Apache-2.0 @Desc : To provide a general spatial construct that all other spatial constructions extend from. Data in component is often related to spatial coordinates, either georeferenced or not. Although most models encapsulate data with a static spatial definition, some advanced models might contain dynamic spatial definitions (e.g. waves, moving grids). A Version number has been introduced to enable tracking of spatial changes over time. If the version changes, the spatial definition might need to be queried again during the computation process. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ITime.h @License : Apache-2.0 @Desc : Time interface to support a time stamp as well as a time interval. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ITimeSet.h @License : Apache-2.0 @Desc : A set of time stamps or time intervals, used to indicate when an output item has values and can provide values, and when an input item does or may require values. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IUnit.h @License : Apache-2.0 @Desc : To describe the physical unit of IQuantity . Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IValueDefinition.h @License : Apache-2.0 @Desc : To provide value definition description of an OpenOasis entity. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : IValueSet.h @License : Apache-2.0 @Desc : To represent a general multi-dimensional set of values. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : LinkableComponentStatus.h @License : Apache-2.0 @Desc : To enumerate the possible statuses that a linkable component can be. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : LinkableComponentStatusChangeEventArgs.h @License : Apache-2.0 @Desc : To contain the information that will be passed when the ILinkableComponent fires the StatusChanged event. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : HeatConductionModel.h @License : Apache-2.0 @Desc : A dummy heat conduction model used for example purposes. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : Logger.h @License : Apache-2.0 @Desc : Provide logger. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : Tensor.h @License : Apache-2.0 @Desc : Define Tensor template class for numerical calculation. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : Vector.h @License : Apache-2.0 @Desc : Define Vector template class for numerical calculation. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : TimeBuffer.h @License : Apache-2.0 @Desc : To provide temporal buffering functionalities. The TimeBuffer class provides buffering functionalities that will store values needed for a particular output item in memory and functionality that will interpolate, extrapolate and aggregate values from these values. The content of the TimeBuffer is lists of corresponding times and ValueSets, where times can be TimeStamps or TimeSpans and the ValueSets are double[]. TimeBuffer objects may not contain mixtures of TimeSpans and TimeStamps. The number of Times (TimeSpans or TimeStamps) must equal the number of value sets (double[]) in the TimeBuffer. When time spans are put in the buffer, it is assumed that there aren't holes between the spans, i.e. a time setup of: |-|-| |-|-| a b c d e f where data is missing between c and d isn't allowed (a value of 0 is assumed in such an interval). Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : GeoCalculator.h @License : Apache-2.0 @Desc : A collection of general geometry functions. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Grid1D.h @License : Apache-2.0 @Desc : Grid in river net used for numerical calculation. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Grid2D.h @License : Apache-2.0 @Desc : Grid formed by flat cells in 2d used for numerical calculation. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Grid3D.h @License : Apache-2.0 @Desc : Grid in 3d used for numerical calculation. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : MeshStructs.h @License : Apache-2.0 @Desc : Definitions of mesh related structures. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : XYGeoStructs.h @License : Apache-2.0 @Desc : To provide basic plane geometry data structures (no z coordinate). Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : XYGeoTools.h @License : Apache-2.0 @Desc : The XYGeoTools class is a collection of general geometry functions.","title":"Detailed Description"},{"location":"models/namespace_open_oasis/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"models/namespace_open_oasis/#enum-dimensionbase","text":"enum OpenOasis :: DimensionBase { Length , Mass , Time , ElectricCurrent , Temperature , AmountOfSubstance , LuminousIntensity , Currency };","title":"enum DimensionBase"},{"location":"models/namespace_open_oasis/#enum-elementtype","text":"enum OpenOasis :: ElementType { IdBased , Point , Polyline , Polygon , Polyhedron };","title":"enum ElementType"},{"location":"models/namespace_open_oasis/#enum-linkablecomponentstatus","text":"enum OpenOasis :: LinkableComponentStatus { Created , Initializing , Initialized , Validating , Valid , WaitingForData , Invalid , Preparing , Updating , Updated , Done , Finishing , Finished , Failed }; The documentation for this class was generated from the following file Models/Inc/AdditionalControl/IComparable.h","title":"enum LinkableComponentStatus"},{"location":"models/namespace_open_oasis_1_1_additional_control/","text":"Namespace OpenOasis::AdditionalControl \u00b6 Namespace List > OpenOasis > AdditionalControl Classes \u00b6 Type Name class IComparable Interface class provides a unified interface for object comparison. class ISpaceExtension class ITimeExtension Methods that are specific for a time-space component. The documentation for this class was generated from the following file Models/Inc/AdditionalControl/IComparable.h","title":"Namespace OpenOasis::AdditionalControl"},{"location":"models/namespace_open_oasis_1_1_additional_control/#namespace-openoasisadditionalcontrol","text":"Namespace List > OpenOasis > AdditionalControl","title":"Namespace OpenOasis::AdditionalControl"},{"location":"models/namespace_open_oasis_1_1_additional_control/#classes","text":"Type Name class IComparable Interface class provides a unified interface for object comparison. class ISpaceExtension class ITimeExtension Methods that are specific for a time-space component. The documentation for this class was generated from the following file Models/Inc/AdditionalControl/IComparable.h","title":"Classes"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_comparable/","text":"Class OpenOasis::AdditionalControl::IComparable \u00b6 ClassList > OpenOasis > AdditionalControl > IComparable Interface class provides a unified interface for object comparison. #include <IComparable.h> Public Functions \u00b6 Type Name virtual int CompareTo (const std::shared_ptr< IComparable > & obj) const = 0 Compare the two comparable objections. Public Functions Documentation \u00b6 function CompareTo \u00b6 Compare the two comparable objections. virtual int OpenOasis :: AdditionalControl :: IComparable :: CompareTo ( const std :: shared_ptr < IComparable > & obj ) const = 0 if this > obj, return +1; if this = obj, return 0; if this < obj, return -1; Parameters: obj A comparable object. Returns: The comparison result. Exception: If the two objects were not comparable, an exception thrown. The documentation for this class was generated from the following file Models/Inc/AdditionalControl/IComparable.h","title":"Class OpenOasis::AdditionalControl::IComparable"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_comparable/#class-openoasisadditionalcontrolicomparable","text":"ClassList > OpenOasis > AdditionalControl > IComparable Interface class provides a unified interface for object comparison. #include <IComparable.h>","title":"Class OpenOasis::AdditionalControl::IComparable"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_comparable/#public-functions","text":"Type Name virtual int CompareTo (const std::shared_ptr< IComparable > & obj) const = 0 Compare the two comparable objections.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_comparable/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_comparable/#function-compareto","text":"Compare the two comparable objections. virtual int OpenOasis :: AdditionalControl :: IComparable :: CompareTo ( const std :: shared_ptr < IComparable > & obj ) const = 0 if this > obj, return +1; if this = obj, return 0; if this < obj, return -1; Parameters: obj A comparable object. Returns: The comparison result. Exception: If the two objects were not comparable, an exception thrown. The documentation for this class was generated from the following file Models/Inc/AdditionalControl/IComparable.h","title":"function CompareTo"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_space_extension/","text":"Class OpenOasis::AdditionalControl::ISpaceExtension \u00b6 ClassList > OpenOasis > AdditionalControl > ISpaceExtension Public Functions \u00b6 Type Name virtual std::shared_ptr< ISpatialDefinition > GetSpatialDefinition () const = 0 Spatial information (usually an element set) on the values that are available in an output exchange item or required by an input exchange item. Public Functions Documentation \u00b6 function GetSpatialDefinition \u00b6 virtual std :: shared_ptr < ISpatialDefinition > OpenOasis :: AdditionalControl :: ISpaceExtension :: GetSpatialDefinition () const = 0 The documentation for this class was generated from the following file Models/Inc/AdditionalControl/ISpaceExtension.h","title":"Class OpenOasis::AdditionalControl::ISpaceExtension"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_space_extension/#class-openoasisadditionalcontrolispaceextension","text":"ClassList > OpenOasis > AdditionalControl > ISpaceExtension","title":"Class OpenOasis::AdditionalControl::ISpaceExtension"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_space_extension/#public-functions","text":"Type Name virtual std::shared_ptr< ISpatialDefinition > GetSpatialDefinition () const = 0 Spatial information (usually an element set) on the values that are available in an output exchange item or required by an input exchange item.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_space_extension/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_space_extension/#function-getspatialdefinition","text":"virtual std :: shared_ptr < ISpatialDefinition > OpenOasis :: AdditionalControl :: ISpaceExtension :: GetSpatialDefinition () const = 0 The documentation for this class was generated from the following file Models/Inc/AdditionalControl/ISpaceExtension.h","title":"function GetSpatialDefinition"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_time_extension/","text":"Class OpenOasis::AdditionalControl::ITimeExtension \u00b6 ClassList > OpenOasis > AdditionalControl > ITimeExtension Methods that are specific for a time-space component. #include <ITimeExtension.h> Public Functions \u00b6 Type Name virtual std::shared_ptr< ITime > GetCurrTime () const = 0 The property describes what time stamp the component is at. virtual std::shared_ptr< ITimeSet > GetTimeExtent () const = 0 The property describes in what time span the component can operate. This can be used to support the user when creating a composition. Public Functions Documentation \u00b6 function GetCurrTime \u00b6 virtual std :: shared_ptr < ITime > OpenOasis :: AdditionalControl :: ITimeExtension :: GetCurrTime () const = 0 function GetTimeExtent \u00b6 virtual std :: shared_ptr < ITimeSet > OpenOasis :: AdditionalControl :: ITimeExtension :: GetTimeExtent () const = 0 The documentation for this class was generated from the following file Models/Inc/AdditionalControl/ITimeExtension.h","title":"Class OpenOasis::AdditionalControl::ITimeExtension"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_time_extension/#class-openoasisadditionalcontrolitimeextension","text":"ClassList > OpenOasis > AdditionalControl > ITimeExtension Methods that are specific for a time-space component. #include <ITimeExtension.h>","title":"Class OpenOasis::AdditionalControl::ITimeExtension"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_time_extension/#public-functions","text":"Type Name virtual std::shared_ptr< ITime > GetCurrTime () const = 0 The property describes what time stamp the component is at. virtual std::shared_ptr< ITimeSet > GetTimeExtent () const = 0 The property describes in what time span the component can operate. This can be used to support the user when creating a composition.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_time_extension/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_time_extension/#function-getcurrtime","text":"virtual std :: shared_ptr < ITime > OpenOasis :: AdditionalControl :: ITimeExtension :: GetCurrTime () const = 0","title":"function GetCurrTime"},{"location":"models/class_open_oasis_1_1_additional_control_1_1_i_time_extension/#function-gettimeextent","text":"virtual std :: shared_ptr < ITimeSet > OpenOasis :: AdditionalControl :: ITimeExtension :: GetTimeExtent () const = 0 The documentation for this class was generated from the following file Models/Inc/AdditionalControl/ITimeExtension.h","title":"function GetTimeExtent"},{"location":"models/namespace_open_oasis_1_1_comm_imp/","text":"Namespace OpenOasis::CommImp \u00b6 Namespace List > OpenOasis > CommImp Namespaces \u00b6 Type Name namespace IO namespace Numeric namespace Spatial namespace Temporal The documentation for this class was generated from the following file Models/CommImp/IO/LinkLoader.cpp","title":"Namespace OpenOasis::CommImp"},{"location":"models/namespace_open_oasis_1_1_comm_imp/#namespace-openoasiscommimp","text":"Namespace List > OpenOasis > CommImp","title":"Namespace OpenOasis::CommImp"},{"location":"models/namespace_open_oasis_1_1_comm_imp/#namespaces","text":"Type Name namespace IO namespace Numeric namespace Spatial namespace Temporal The documentation for this class was generated from the following file Models/CommImp/IO/LinkLoader.cpp","title":"Namespaces"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/","text":"Namespace OpenOasis::CommImp::IO \u00b6 Namespace List > OpenOasis > CommImp > IO More... Classes \u00b6 Type Name class LinkLoader Class forLoading components coupling configurations json file. class MeshLoader Default Mesh data loader. class TaskLoader Loading components task configurations yaml file. Public Static Attributes \u00b6 Type Name int DEFAULT_FILE_NUM = = 9 const string DEFAULT_LOGGER_ID = = \"OasisLog\" int DEFAULT_LOGGER_SIZE = = 1024 * 1024 * 5 unordered_map< string, shared_ptr< spdlog::logger > > OasisLoggers = = { {DEFAULT_LOGGER_ID, spdlog::rotating_logger_mt( DEFAULT_LOGGER_ID, DEFAULT_LOGGER_ID, DEFAULT_LOGGER_SIZE, DEFAULT_FILE_NUM)}} shared_ptr< spdlog::logger > logger = = GetLogger() mutex mtx Public Functions \u00b6 Type Name shared_ptr< spdlog::logger > GetLogger (const string & loggerId) std::shared_ptr< spdlog::logger > GetLogger (const std::string & loggerId=\"OasisLog\") To get rotating logger with specified id. Detailed Description \u00b6 @File : LinkLoader.cpp @Brief : To provide unified interfaces for loading coupling configurations. Copyright (C) 2024, The OpenOasis Contributors. Join us in the Oasis! @File : LinkLoader.h @License : Apache-2.0 @Desc : To provide unified interfaces for loading coupling configurations. Coupling between components requires clarification of several issues, including: * Which coupling mode is used, i.e., loop-mode or pull-mode? * Which two components are coupled? * Which component objects are coupled? * Which object states are coupled? * During which period of coupling? * What coupling adaptation operations are used? A component connection configuration needs to describe the above issues clearly, which is designed in the following format: { \"comps\" : { \"comp1\" : { \"description\" : \"{some description about comp1}\" , \"type\" : \"{component type of comp1}\" , \"task\" : \"{path_to_taskfile}/task.yaml\" , \"dll\" : \"{path_to_dllfile}/OasisFlows.dll\" , \"link\" : false }, \"comp2\" : { \"description\" : \"{some description about comp2}\" , \"type\" : \"{component type of comp2}\" , \"task\" : \"{path_to_taskfile}/task.yaml\" , \"dll\" : \"{path_to_dllfile}/OasisFlows.dll\" , \"link\" : false }, ... }, \"links\" : { \"link_comp1_to_comp2\" : { \"description\" : \"{some description about the coupling link}\" , \"pipelines\" : [ { \"src_component\" : \"{name of the source component}\" , \"src_state\" : \"{state of the source element}\" , \"src_elements\" : [ { \"id\" : \"c1_e1\" , \"type\" : \"{type of the specified element}\" }, { \"id\" : \"c1_e2\" , \"type\" : \"{type of the specified element}\" }, ... ], \"tar_component\" : \"{name of the target component}\" , \"tar_element\" : { \"id\" : \"c2_e1\" , \"type\" : \"{type of the specified element}\" }, \"temporal_operators\" : \"accumulate\" , \"spatial_operators\" : \"average\" } ... ], \"link_mode\" : \"pull\" , \"params\" : { \"max_iter_steps\" : \"25\" , \"tolerance\" : \"0.001\" , ... } }, ... } } @File : Logger.cpp @Brief : Provide logger. @File : MeshLoader.cpp @Brief : Loading mesh data from files. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : MeshLoader.h @License : Apache-2.0 @Desc : Loading mesh data from files. The default mesh loader predefined a fixed set of csv files for storing mesh data, including : nodes.csv, used for storing node coordinates data, formated as : \"nId, x, y, z\" faces.csv, used for storing face nodes index data, formated as : \"fId, nId1, nId2\" cells.csv, used for storing cell faces index data, formated as : \"cId, fId1, fId2, fId3, ...\" And more : zones.csv, used for storing zone faces index data, formated as : \"zId, fId1, fId2, fId3, ...\" patches.csv, used for storing patch faces indexes, formated as : \"pId, fId1, fId2, fId3, ...\" Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : NetworkLoader.h @License : Apache-2.0 @Desc : Loading river, pipe or mixed network data from files. Copyright (C) 2024, The OpenOasis Contributors. Join us in the Oasis! @File : OutputCsv.h @License : Apache-2.0 @Desc : To provide unified output interface for the csv format. Copyright (C) 2024, The OpenOasis Contributors. Join us in the Oasis! @File : TaskLoader.h @License : Apache-2.0 @Desc : To provide a unified interface for loading model tasks. Public Static Attributes Documentation \u00b6 variable DEFAULT_FILE_NUM \u00b6 int OpenOasis :: CommImp :: IO :: DEFAULT_FILE_NUM ; variable DEFAULT_LOGGER_ID \u00b6 const string OpenOasis :: CommImp :: IO :: DEFAULT_LOGGER_ID ; variable DEFAULT_LOGGER_SIZE \u00b6 int OpenOasis :: CommImp :: IO :: DEFAULT_LOGGER_SIZE ; variable OasisLoggers \u00b6 unordered_map < string , shared_ptr < spdlog :: logger > > OpenOasis :: CommImp :: IO :: OasisLoggers ; variable logger \u00b6 shared_ptr < spdlog :: logger > OpenOasis :: CommImp :: IO :: logger ; variable mtx \u00b6 mutex OpenOasis :: CommImp :: IO :: mtx ; Public Functions Documentation \u00b6 function GetLogger \u00b6 shared_ptr < spdlog :: logger > OpenOasis :: CommImp :: IO :: GetLogger ( const string & loggerId ) function GetLogger \u00b6 std :: shared_ptr < spdlog :: logger > OpenOasis :: CommImp :: IO :: GetLogger ( const std :: string & loggerId = \"OasisLog\" ) The documentation for this class was generated from the following file Models/CommImp/IO/LinkLoader.cpp","title":"Namespace OpenOasis::CommImp::IO"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#namespace-openoasiscommimpio","text":"Namespace List > OpenOasis > CommImp > IO More...","title":"Namespace OpenOasis::CommImp::IO"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#classes","text":"Type Name class LinkLoader Class forLoading components coupling configurations json file. class MeshLoader Default Mesh data loader. class TaskLoader Loading components task configurations yaml file.","title":"Classes"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#public-static-attributes","text":"Type Name int DEFAULT_FILE_NUM = = 9 const string DEFAULT_LOGGER_ID = = \"OasisLog\" int DEFAULT_LOGGER_SIZE = = 1024 * 1024 * 5 unordered_map< string, shared_ptr< spdlog::logger > > OasisLoggers = = { {DEFAULT_LOGGER_ID, spdlog::rotating_logger_mt( DEFAULT_LOGGER_ID, DEFAULT_LOGGER_ID, DEFAULT_LOGGER_SIZE, DEFAULT_FILE_NUM)}} shared_ptr< spdlog::logger > logger = = GetLogger() mutex mtx","title":"Public Static Attributes"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#public-functions","text":"Type Name shared_ptr< spdlog::logger > GetLogger (const string & loggerId) std::shared_ptr< spdlog::logger > GetLogger (const std::string & loggerId=\"OasisLog\") To get rotating logger with specified id.","title":"Public Functions"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#detailed-description","text":"@File : LinkLoader.cpp @Brief : To provide unified interfaces for loading coupling configurations. Copyright (C) 2024, The OpenOasis Contributors. Join us in the Oasis! @File : LinkLoader.h @License : Apache-2.0 @Desc : To provide unified interfaces for loading coupling configurations. Coupling between components requires clarification of several issues, including: * Which coupling mode is used, i.e., loop-mode or pull-mode? * Which two components are coupled? * Which component objects are coupled? * Which object states are coupled? * During which period of coupling? * What coupling adaptation operations are used? A component connection configuration needs to describe the above issues clearly, which is designed in the following format: { \"comps\" : { \"comp1\" : { \"description\" : \"{some description about comp1}\" , \"type\" : \"{component type of comp1}\" , \"task\" : \"{path_to_taskfile}/task.yaml\" , \"dll\" : \"{path_to_dllfile}/OasisFlows.dll\" , \"link\" : false }, \"comp2\" : { \"description\" : \"{some description about comp2}\" , \"type\" : \"{component type of comp2}\" , \"task\" : \"{path_to_taskfile}/task.yaml\" , \"dll\" : \"{path_to_dllfile}/OasisFlows.dll\" , \"link\" : false }, ... }, \"links\" : { \"link_comp1_to_comp2\" : { \"description\" : \"{some description about the coupling link}\" , \"pipelines\" : [ { \"src_component\" : \"{name of the source component}\" , \"src_state\" : \"{state of the source element}\" , \"src_elements\" : [ { \"id\" : \"c1_e1\" , \"type\" : \"{type of the specified element}\" }, { \"id\" : \"c1_e2\" , \"type\" : \"{type of the specified element}\" }, ... ], \"tar_component\" : \"{name of the target component}\" , \"tar_element\" : { \"id\" : \"c2_e1\" , \"type\" : \"{type of the specified element}\" }, \"temporal_operators\" : \"accumulate\" , \"spatial_operators\" : \"average\" } ... ], \"link_mode\" : \"pull\" , \"params\" : { \"max_iter_steps\" : \"25\" , \"tolerance\" : \"0.001\" , ... } }, ... } } @File : Logger.cpp @Brief : Provide logger. @File : MeshLoader.cpp @Brief : Loading mesh data from files. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : MeshLoader.h @License : Apache-2.0 @Desc : Loading mesh data from files. The default mesh loader predefined a fixed set of csv files for storing mesh data, including : nodes.csv, used for storing node coordinates data, formated as : \"nId, x, y, z\" faces.csv, used for storing face nodes index data, formated as : \"fId, nId1, nId2\" cells.csv, used for storing cell faces index data, formated as : \"cId, fId1, fId2, fId3, ...\" And more : zones.csv, used for storing zone faces index data, formated as : \"zId, fId1, fId2, fId3, ...\" patches.csv, used for storing patch faces indexes, formated as : \"pId, fId1, fId2, fId3, ...\" Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : NetworkLoader.h @License : Apache-2.0 @Desc : Loading river, pipe or mixed network data from files. Copyright (C) 2024, The OpenOasis Contributors. Join us in the Oasis! @File : OutputCsv.h @License : Apache-2.0 @Desc : To provide unified output interface for the csv format. Copyright (C) 2024, The OpenOasis Contributors. Join us in the Oasis! @File : TaskLoader.h @License : Apache-2.0 @Desc : To provide a unified interface for loading model tasks.","title":"Detailed Description"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#variable-default_file_num","text":"int OpenOasis :: CommImp :: IO :: DEFAULT_FILE_NUM ;","title":"variable DEFAULT_FILE_NUM"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#variable-default_logger_id","text":"const string OpenOasis :: CommImp :: IO :: DEFAULT_LOGGER_ID ;","title":"variable DEFAULT_LOGGER_ID"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#variable-default_logger_size","text":"int OpenOasis :: CommImp :: IO :: DEFAULT_LOGGER_SIZE ;","title":"variable DEFAULT_LOGGER_SIZE"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#variable-oasisloggers","text":"unordered_map < string , shared_ptr < spdlog :: logger > > OpenOasis :: CommImp :: IO :: OasisLoggers ;","title":"variable OasisLoggers"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#variable-logger","text":"shared_ptr < spdlog :: logger > OpenOasis :: CommImp :: IO :: logger ;","title":"variable logger"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#variable-mtx","text":"mutex OpenOasis :: CommImp :: IO :: mtx ;","title":"variable mtx"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#function-getlogger","text":"shared_ptr < spdlog :: logger > OpenOasis :: CommImp :: IO :: GetLogger ( const string & loggerId )","title":"function GetLogger"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_i_o/#function-getlogger_1","text":"std :: shared_ptr < spdlog :: logger > OpenOasis :: CommImp :: IO :: GetLogger ( const std :: string & loggerId = \"OasisLog\" ) The documentation for this class was generated from the following file Models/CommImp/IO/LinkLoader.cpp","title":"function GetLogger"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/","text":"Class OpenOasis::CommImp::IO::LinkLoader \u00b6 ClassList > OpenOasis > CommImp > IO > LinkLoader Class forLoading components coupling configurations json file. #include <LinkLoader.h> Public Types \u00b6 Type Name typedef std::array< std::string, 3 > ComponentInfo typedef std::array< std::string, 5 > ElementInfo Public Functions \u00b6 Type Name std::vector< std::string > GetComponentIds () const ComponentInfo GetComponentInfo (const std::string & compId) const std::vector< ElementInfo > GetComponentInputs (const std::string & compId) const std::vector< ElementInfo > GetComponentOutputs (const std::string & compId) const std::unordered_map< std::string, std::vector< ElementInfo > > GetInputProviders (const std::string & compId, const ElementInfo & input) const std::multimap< std::string, std::string > GetIteratorConfigs (const std::string & iterId) const Gets the iterator configurations of specified iterator group. std::unordered_map< std::string, std::vector< std::string > > GetIteratorGroups () const Gets iterator groups consisted of components. std::unordered_map< std::string, std::vector< ElementInfo > > GetOutputConsumers (const std::string & compId, const ElementInfo & output) const LinkLoader (const std::string & json) void Load () Public Types Documentation \u00b6 typedef ComponentInfo \u00b6 using OpenOasis :: CommImp :: IO :: LinkLoader :: ComponentInfo = std :: array < std :: string , 3 > ; typedef ElementInfo \u00b6 using OpenOasis :: CommImp :: IO :: LinkLoader :: ElementInfo = std :: array < std :: string , 5 > ; Public Functions Documentation \u00b6 function GetComponentIds \u00b6 std :: vector < std :: string > OpenOasis :: CommImp :: IO :: LinkLoader :: GetComponentIds () const function GetComponentInfo \u00b6 ComponentInfo OpenOasis :: CommImp :: IO :: LinkLoader :: GetComponentInfo ( const std :: string & compId ) const function GetComponentInputs \u00b6 std :: vector < ElementInfo > OpenOasis :: CommImp :: IO :: LinkLoader :: GetComponentInputs ( const std :: string & compId ) const function GetComponentOutputs \u00b6 std :: vector < ElementInfo > OpenOasis :: CommImp :: IO :: LinkLoader :: GetComponentOutputs ( const std :: string & compId ) const function GetInputProviders \u00b6 std :: unordered_map < std :: string , std :: vector < ElementInfo > > OpenOasis :: CommImp :: IO :: LinkLoader :: GetInputProviders ( const std :: string & compId , const ElementInfo & input ) const function GetIteratorConfigs \u00b6 std :: multimap < std :: string , std :: string > OpenOasis :: CommImp :: IO :: LinkLoader :: GetIteratorConfigs ( const std :: string & iterId ) const function GetIteratorGroups \u00b6 Gets iterator groups consisted of components. std :: unordered_map < std :: string , std :: vector < std :: string > > OpenOasis :: CommImp :: IO :: LinkLoader :: GetIteratorGroups () const Returns: The iterator groups, where each group contains a set of components. function GetOutputConsumers \u00b6 std :: unordered_map < std :: string , std :: vector < ElementInfo > > OpenOasis :: CommImp :: IO :: LinkLoader :: GetOutputConsumers ( const std :: string & compId , const ElementInfo & output ) const function LinkLoader \u00b6 inline OpenOasis :: CommImp :: IO :: LinkLoader :: LinkLoader ( const std :: string & json ) function Load \u00b6 void OpenOasis :: CommImp :: IO :: LinkLoader :: Load () The documentation for this class was generated from the following file Models/CommImp/IO/LinkLoader.h","title":"Class OpenOasis::CommImp::IO::LinkLoader"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#class-openoasiscommimpiolinkloader","text":"ClassList > OpenOasis > CommImp > IO > LinkLoader Class forLoading components coupling configurations json file. #include <LinkLoader.h>","title":"Class OpenOasis::CommImp::IO::LinkLoader"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#public-types","text":"Type Name typedef std::array< std::string, 3 > ComponentInfo typedef std::array< std::string, 5 > ElementInfo","title":"Public Types"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#public-functions","text":"Type Name std::vector< std::string > GetComponentIds () const ComponentInfo GetComponentInfo (const std::string & compId) const std::vector< ElementInfo > GetComponentInputs (const std::string & compId) const std::vector< ElementInfo > GetComponentOutputs (const std::string & compId) const std::unordered_map< std::string, std::vector< ElementInfo > > GetInputProviders (const std::string & compId, const ElementInfo & input) const std::multimap< std::string, std::string > GetIteratorConfigs (const std::string & iterId) const Gets the iterator configurations of specified iterator group. std::unordered_map< std::string, std::vector< std::string > > GetIteratorGroups () const Gets iterator groups consisted of components. std::unordered_map< std::string, std::vector< ElementInfo > > GetOutputConsumers (const std::string & compId, const ElementInfo & output) const LinkLoader (const std::string & json) void Load ()","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#typedef-componentinfo","text":"using OpenOasis :: CommImp :: IO :: LinkLoader :: ComponentInfo = std :: array < std :: string , 3 > ;","title":"typedef ComponentInfo"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#typedef-elementinfo","text":"using OpenOasis :: CommImp :: IO :: LinkLoader :: ElementInfo = std :: array < std :: string , 5 > ;","title":"typedef ElementInfo"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#function-getcomponentids","text":"std :: vector < std :: string > OpenOasis :: CommImp :: IO :: LinkLoader :: GetComponentIds () const","title":"function GetComponentIds"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#function-getcomponentinfo","text":"ComponentInfo OpenOasis :: CommImp :: IO :: LinkLoader :: GetComponentInfo ( const std :: string & compId ) const","title":"function GetComponentInfo"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#function-getcomponentinputs","text":"std :: vector < ElementInfo > OpenOasis :: CommImp :: IO :: LinkLoader :: GetComponentInputs ( const std :: string & compId ) const","title":"function GetComponentInputs"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#function-getcomponentoutputs","text":"std :: vector < ElementInfo > OpenOasis :: CommImp :: IO :: LinkLoader :: GetComponentOutputs ( const std :: string & compId ) const","title":"function GetComponentOutputs"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#function-getinputproviders","text":"std :: unordered_map < std :: string , std :: vector < ElementInfo > > OpenOasis :: CommImp :: IO :: LinkLoader :: GetInputProviders ( const std :: string & compId , const ElementInfo & input ) const","title":"function GetInputProviders"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#function-getiteratorconfigs","text":"std :: multimap < std :: string , std :: string > OpenOasis :: CommImp :: IO :: LinkLoader :: GetIteratorConfigs ( const std :: string & iterId ) const","title":"function GetIteratorConfigs"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#function-getiteratorgroups","text":"Gets iterator groups consisted of components. std :: unordered_map < std :: string , std :: vector < std :: string > > OpenOasis :: CommImp :: IO :: LinkLoader :: GetIteratorGroups () const Returns: The iterator groups, where each group contains a set of components.","title":"function GetIteratorGroups"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#function-getoutputconsumers","text":"std :: unordered_map < std :: string , std :: vector < ElementInfo > > OpenOasis :: CommImp :: IO :: LinkLoader :: GetOutputConsumers ( const std :: string & compId , const ElementInfo & output ) const","title":"function GetOutputConsumers"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#function-linkloader","text":"inline OpenOasis :: CommImp :: IO :: LinkLoader :: LinkLoader ( const std :: string & json )","title":"function LinkLoader"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_link_loader/#function-load","text":"void OpenOasis :: CommImp :: IO :: LinkLoader :: Load () The documentation for this class was generated from the following file Models/CommImp/IO/LinkLoader.h","title":"function Load"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/","text":"Class OpenOasis::CommImp::IO::MeshLoader \u00b6 ClassList > OpenOasis > CommImp > IO > MeshLoader Default Mesh data loader. More... #include <MeshLoader.h> Public Functions \u00b6 Type Name virtual std::unordered_map< int, Coordinate > & GetCellCoordinates () virtual std::unordered_map< int, std::vector< int > > & GetCellFaces () virtual std::unordered_map< int, Coordinate > & GetFaceCoordinates () virtual std::unordered_map< int, std::vector< int > > & GetFaceNodes () virtual std::unordered_map< int, Coordinate > & GetNodeCoordinates () virtual std::unordered_map< std::string, std::vector< int > > & GetPatches () virtual std::unordered_map< std::string, std::vector< int > > & GetZones () virtual void Load () MeshLoader (const std::string & meshDir) ~MeshLoader () Protected Functions \u00b6 Type Name void CheckIds (const std::vector< std::string > & ids, const std::string & meta) void GenerateCellCoordinates () void GenerateFaceCoordinates () void LoadCells (const std::string & file=\"cells.csv\") void LoadFaces (const std::string & file=\"faces.csv\") void LoadNodes (const std::string & file=\"nodes.csv\") void LoadPatches (const std::string & file=\"patches.csv\") void LoadZones (const std::string & file=\"zones.csv\") Detailed Description \u00b6 In default mode, coordinates are defined on nodes. Public Functions Documentation \u00b6 function GetCellCoordinates \u00b6 virtual std :: unordered_map < int , Coordinate > & OpenOasis :: CommImp :: IO :: MeshLoader :: GetCellCoordinates () function GetCellFaces \u00b6 virtual std :: unordered_map < int , std :: vector < int > > & OpenOasis :: CommImp :: IO :: MeshLoader :: GetCellFaces () function GetFaceCoordinates \u00b6 virtual std :: unordered_map < int , Coordinate > & OpenOasis :: CommImp :: IO :: MeshLoader :: GetFaceCoordinates () function GetFaceNodes \u00b6 virtual std :: unordered_map < int , std :: vector < int > > & OpenOasis :: CommImp :: IO :: MeshLoader :: GetFaceNodes () function GetNodeCoordinates \u00b6 virtual std :: unordered_map < int , Coordinate > & OpenOasis :: CommImp :: IO :: MeshLoader :: GetNodeCoordinates () function GetPatches \u00b6 virtual std :: unordered_map < std :: string , std :: vector < int > > & OpenOasis :: CommImp :: IO :: MeshLoader :: GetPatches () function GetZones \u00b6 virtual std :: unordered_map < std :: string , std :: vector < int > > & OpenOasis :: CommImp :: IO :: MeshLoader :: GetZones () function Load \u00b6 virtual void OpenOasis :: CommImp :: IO :: MeshLoader :: Load () function MeshLoader \u00b6 OpenOasis :: CommImp :: IO :: MeshLoader :: MeshLoader ( const std :: string & meshDir ) function ~MeshLoader \u00b6 inline OpenOasis :: CommImp :: IO :: MeshLoader ::~ MeshLoader () Protected Functions Documentation \u00b6 function CheckIds \u00b6 void OpenOasis :: CommImp :: IO :: MeshLoader :: CheckIds ( const std :: vector < std :: string > & ids , const std :: string & meta ) function GenerateCellCoordinates \u00b6 void OpenOasis :: CommImp :: IO :: MeshLoader :: GenerateCellCoordinates () function GenerateFaceCoordinates \u00b6 void OpenOasis :: CommImp :: IO :: MeshLoader :: GenerateFaceCoordinates () function LoadCells \u00b6 void OpenOasis :: CommImp :: IO :: MeshLoader :: LoadCells ( const std :: string & file = \"cells.csv\" ) function LoadFaces \u00b6 void OpenOasis :: CommImp :: IO :: MeshLoader :: LoadFaces ( const std :: string & file = \"faces.csv\" ) function LoadNodes \u00b6 void OpenOasis :: CommImp :: IO :: MeshLoader :: LoadNodes ( const std :: string & file = \"nodes.csv\" ) function LoadPatches \u00b6 void OpenOasis :: CommImp :: IO :: MeshLoader :: LoadPatches ( const std :: string & file = \"patches.csv\" ) function LoadZones \u00b6 void OpenOasis :: CommImp :: IO :: MeshLoader :: LoadZones ( const std :: string & file = \"zones.csv\" ) The documentation for this class was generated from the following file Models/CommImp/IO/MeshLoader.h","title":"Class OpenOasis::CommImp::IO::MeshLoader"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#class-openoasiscommimpiomeshloader","text":"ClassList > OpenOasis > CommImp > IO > MeshLoader Default Mesh data loader. More... #include <MeshLoader.h>","title":"Class OpenOasis::CommImp::IO::MeshLoader"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#public-functions","text":"Type Name virtual std::unordered_map< int, Coordinate > & GetCellCoordinates () virtual std::unordered_map< int, std::vector< int > > & GetCellFaces () virtual std::unordered_map< int, Coordinate > & GetFaceCoordinates () virtual std::unordered_map< int, std::vector< int > > & GetFaceNodes () virtual std::unordered_map< int, Coordinate > & GetNodeCoordinates () virtual std::unordered_map< std::string, std::vector< int > > & GetPatches () virtual std::unordered_map< std::string, std::vector< int > > & GetZones () virtual void Load () MeshLoader (const std::string & meshDir) ~MeshLoader ()","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#protected-functions","text":"Type Name void CheckIds (const std::vector< std::string > & ids, const std::string & meta) void GenerateCellCoordinates () void GenerateFaceCoordinates () void LoadCells (const std::string & file=\"cells.csv\") void LoadFaces (const std::string & file=\"faces.csv\") void LoadNodes (const std::string & file=\"nodes.csv\") void LoadPatches (const std::string & file=\"patches.csv\") void LoadZones (const std::string & file=\"zones.csv\")","title":"Protected Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#detailed-description","text":"In default mode, coordinates are defined on nodes.","title":"Detailed Description"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-getcellcoordinates","text":"virtual std :: unordered_map < int , Coordinate > & OpenOasis :: CommImp :: IO :: MeshLoader :: GetCellCoordinates ()","title":"function GetCellCoordinates"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-getcellfaces","text":"virtual std :: unordered_map < int , std :: vector < int > > & OpenOasis :: CommImp :: IO :: MeshLoader :: GetCellFaces ()","title":"function GetCellFaces"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-getfacecoordinates","text":"virtual std :: unordered_map < int , Coordinate > & OpenOasis :: CommImp :: IO :: MeshLoader :: GetFaceCoordinates ()","title":"function GetFaceCoordinates"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-getfacenodes","text":"virtual std :: unordered_map < int , std :: vector < int > > & OpenOasis :: CommImp :: IO :: MeshLoader :: GetFaceNodes ()","title":"function GetFaceNodes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-getnodecoordinates","text":"virtual std :: unordered_map < int , Coordinate > & OpenOasis :: CommImp :: IO :: MeshLoader :: GetNodeCoordinates ()","title":"function GetNodeCoordinates"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-getpatches","text":"virtual std :: unordered_map < std :: string , std :: vector < int > > & OpenOasis :: CommImp :: IO :: MeshLoader :: GetPatches ()","title":"function GetPatches"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-getzones","text":"virtual std :: unordered_map < std :: string , std :: vector < int > > & OpenOasis :: CommImp :: IO :: MeshLoader :: GetZones ()","title":"function GetZones"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-load","text":"virtual void OpenOasis :: CommImp :: IO :: MeshLoader :: Load ()","title":"function Load"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-meshloader","text":"OpenOasis :: CommImp :: IO :: MeshLoader :: MeshLoader ( const std :: string & meshDir )","title":"function MeshLoader"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-meshloader_1","text":"inline OpenOasis :: CommImp :: IO :: MeshLoader ::~ MeshLoader ()","title":"function ~MeshLoader"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-checkids","text":"void OpenOasis :: CommImp :: IO :: MeshLoader :: CheckIds ( const std :: vector < std :: string > & ids , const std :: string & meta )","title":"function CheckIds"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-generatecellcoordinates","text":"void OpenOasis :: CommImp :: IO :: MeshLoader :: GenerateCellCoordinates ()","title":"function GenerateCellCoordinates"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-generatefacecoordinates","text":"void OpenOasis :: CommImp :: IO :: MeshLoader :: GenerateFaceCoordinates ()","title":"function GenerateFaceCoordinates"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-loadcells","text":"void OpenOasis :: CommImp :: IO :: MeshLoader :: LoadCells ( const std :: string & file = \"cells.csv\" )","title":"function LoadCells"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-loadfaces","text":"void OpenOasis :: CommImp :: IO :: MeshLoader :: LoadFaces ( const std :: string & file = \"faces.csv\" )","title":"function LoadFaces"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-loadnodes","text":"void OpenOasis :: CommImp :: IO :: MeshLoader :: LoadNodes ( const std :: string & file = \"nodes.csv\" )","title":"function LoadNodes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-loadpatches","text":"void OpenOasis :: CommImp :: IO :: MeshLoader :: LoadPatches ( const std :: string & file = \"patches.csv\" )","title":"function LoadPatches"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_mesh_loader/#function-loadzones","text":"void OpenOasis :: CommImp :: IO :: MeshLoader :: LoadZones ( const std :: string & file = \"zones.csv\" ) The documentation for this class was generated from the following file Models/CommImp/IO/MeshLoader.h","title":"function LoadZones"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_task_loader/","text":"Class OpenOasis::CommImp::IO::TaskLoader \u00b6 ClassList > OpenOasis > CommImp > IO > TaskLoader Loading components task configurations yaml file. #include <TaskLoader.h> The documentation for this class was generated from the following file Models/CommImp/IO/TaskLoader.h","title":"Class OpenOasis::CommImp::IO::TaskLoader"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_i_o_1_1_task_loader/#class-openoasiscommimpiotaskloader","text":"ClassList > OpenOasis > CommImp > IO > TaskLoader Loading components task configurations yaml file. #include <TaskLoader.h> The documentation for this class was generated from the following file Models/CommImp/IO/TaskLoader.h","title":"Class OpenOasis::CommImp::IO::TaskLoader"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/","text":"Namespace OpenOasis::CommImp::Numeric \u00b6 Namespace List > OpenOasis > CommImp > Numeric More... Namespaces \u00b6 Type Name namespace FVM Classes \u00b6 Type Name class Boundary Abstract boundary class. struct BoundaryCondition Boundary condition struct. class DirichletBoundary Dirichlet boundary. class DoubleSparseMatrix Sparse matrix having double elements. class Field <typename T> The abstract field class used to represent numeric field, such as scalar, vector or tensor data. class Laplacian Laplacian operator for the divergence of the gradient of a scalar field. class Matrix <typename T> class Operator Abstract operator class. class ScalarField <typename T> Scaler field. class Solver Abstract solver class. class Source class Tensor <typename T> class TensorField <typename T> Tensor field. class Vector <typename T, N> class VectorField <typename T, N> Vector field with default zero vector in 2D or 3D space. Public Types \u00b6 Type Name enum FieldDomain enum FieldType typedef std::tuple< Matrix < real >, std::vector< real > > LinearEqs Linear equations consisting of coefficient matrix and source term vector. typedef ScalarField < double > ScalarFieldDbl typedef ScalarField < Utils::real > ScalarFieldFp typedef ScalarField < int > ScalarFieldInt enum SolverStatus typedef TensorField < double > TensorFieldDbl typedef TensorField < Utils::real > TensorFieldFp typedef TensorField < int > TensorFieldInt typedef VectorField < double, 2 > VectorFieldDbl2D typedef VectorField < double, 3 > VectorFieldDbl3D typedef VectorField < Utils::real, 3 > VectorFieldFp typedef VectorField < int, 2 > VectorFieldInt2D typedef VectorField < int, 3 > VectorFieldInt3D Detailed Description \u00b6 Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Boundary.h @License : Apache-2.0 @Desc : Abstract boundary class. @File : DirichletBoundary.cpp @Brief : Dirichlet boundary. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : DirichletBoundary.h @License : Apache-2.0 @Desc : Dirichlet boundary. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Field.h @License : Apache-2.0 @Desc : Abstract field class. @File : LaplacianOperator.cpp @Brief : Laplacian Operator . Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : LaplacianOperator.h @License : Apache-2.0 @Desc : Laplacian Operator . @File : Matrix.cpp @Brief : To provide matrix interface and a common implementation. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : Matrix.h @License : Apache-2.0 @Desc : Define Matrix template class for numerical calculation. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Operator.h @License : Apache-2.0 @Desc : Abstract operator class. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ScalarField.h @License : Apache-2.0 @Desc : ScalarField for the definition and calculation of scalar fields. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Solver.h @License : Apache-2.0 @Desc : Abstract solver class to provide unified interfaces. Solver 's responsible for parsing the equation expression to be solved, and discretizing the equation items in the computational domain, combining them into a matrix, and solving it. Solver is also responsible for initializing the relevant field quantities, and providing specific discrete and stepping scheme. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Source.h @License : Apache-2.0 @Desc : Abstract Source class for definition of source vector. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : TensorField.h @License : Apache-2.0 @Desc : TensorField for the definition and calculation of tensor fields. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : VectorField.h @License : Apache-2.0 @Desc : VectorField for the definition and calculation of vector fields. Public Types Documentation \u00b6 enum FieldDomain \u00b6 enum OpenOasis :: CommImp :: Numeric :: FieldDomain { NONE , NODE , FACE , CELL }; enum FieldType \u00b6 enum OpenOasis :: CommImp :: Numeric :: FieldType { NONE , SCALAR , VECTOR , TENSOR }; typedef LinearEqs \u00b6 using OpenOasis :: CommImp :: Numeric :: LinearEqs = typedef std :: tuple < Matrix < real > , std :: vector < real > > ; typedef ScalarFieldDbl \u00b6 using OpenOasis :: CommImp :: Numeric :: ScalarFieldDbl = typedef ScalarField < double > ; typedef ScalarFieldFp \u00b6 using OpenOasis :: CommImp :: Numeric :: ScalarFieldFp = typedef ScalarField < Utils :: real > ; typedef ScalarFieldInt \u00b6 using OpenOasis :: CommImp :: Numeric :: ScalarFieldInt = typedef ScalarField < int > ; enum SolverStatus \u00b6 enum OpenOasis :: CommImp :: Numeric :: SolverStatus { Created , Initialized , Parsed , Discretized , Updated , Solved , Failed }; typedef TensorFieldDbl \u00b6 using OpenOasis :: CommImp :: Numeric :: TensorFieldDbl = typedef TensorField < double > ; typedef TensorFieldFp \u00b6 using OpenOasis :: CommImp :: Numeric :: TensorFieldFp = typedef TensorField < Utils :: real > ; typedef TensorFieldInt \u00b6 using OpenOasis :: CommImp :: Numeric :: TensorFieldInt = typedef TensorField < int > ; typedef VectorFieldDbl2D \u00b6 using OpenOasis :: CommImp :: Numeric :: VectorFieldDbl2D = typedef VectorField < double , 2 > ; typedef VectorFieldDbl3D \u00b6 using OpenOasis :: CommImp :: Numeric :: VectorFieldDbl3D = typedef VectorField < double , 3 > ; typedef VectorFieldFp \u00b6 using OpenOasis :: CommImp :: Numeric :: VectorFieldFp = typedef VectorField < Utils :: real , 3 > ; typedef VectorFieldInt2D \u00b6 using OpenOasis :: CommImp :: Numeric :: VectorFieldInt2D = typedef VectorField < int , 2 > ; typedef VectorFieldInt3D \u00b6 using OpenOasis :: CommImp :: Numeric :: VectorFieldInt3D = typedef VectorField < int , 3 > ; The documentation for this class was generated from the following file Models/CommImp/Numeric/Boundary.h","title":"Solvers"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#namespace-openoasiscommimpnumeric","text":"Namespace List > OpenOasis > CommImp > Numeric More...","title":"Namespace OpenOasis::CommImp::Numeric"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#namespaces","text":"Type Name namespace FVM","title":"Namespaces"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#classes","text":"Type Name class Boundary Abstract boundary class. struct BoundaryCondition Boundary condition struct. class DirichletBoundary Dirichlet boundary. class DoubleSparseMatrix Sparse matrix having double elements. class Field <typename T> The abstract field class used to represent numeric field, such as scalar, vector or tensor data. class Laplacian Laplacian operator for the divergence of the gradient of a scalar field. class Matrix <typename T> class Operator Abstract operator class. class ScalarField <typename T> Scaler field. class Solver Abstract solver class. class Source class Tensor <typename T> class TensorField <typename T> Tensor field. class Vector <typename T, N> class VectorField <typename T, N> Vector field with default zero vector in 2D or 3D space.","title":"Classes"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#public-types","text":"Type Name enum FieldDomain enum FieldType typedef std::tuple< Matrix < real >, std::vector< real > > LinearEqs Linear equations consisting of coefficient matrix and source term vector. typedef ScalarField < double > ScalarFieldDbl typedef ScalarField < Utils::real > ScalarFieldFp typedef ScalarField < int > ScalarFieldInt enum SolverStatus typedef TensorField < double > TensorFieldDbl typedef TensorField < Utils::real > TensorFieldFp typedef TensorField < int > TensorFieldInt typedef VectorField < double, 2 > VectorFieldDbl2D typedef VectorField < double, 3 > VectorFieldDbl3D typedef VectorField < Utils::real, 3 > VectorFieldFp typedef VectorField < int, 2 > VectorFieldInt2D typedef VectorField < int, 3 > VectorFieldInt3D","title":"Public Types"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#detailed-description","text":"Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Boundary.h @License : Apache-2.0 @Desc : Abstract boundary class. @File : DirichletBoundary.cpp @Brief : Dirichlet boundary. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : DirichletBoundary.h @License : Apache-2.0 @Desc : Dirichlet boundary. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Field.h @License : Apache-2.0 @Desc : Abstract field class. @File : LaplacianOperator.cpp @Brief : Laplacian Operator . Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : LaplacianOperator.h @License : Apache-2.0 @Desc : Laplacian Operator . @File : Matrix.cpp @Brief : To provide matrix interface and a common implementation. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : Matrix.h @License : Apache-2.0 @Desc : Define Matrix template class for numerical calculation. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Operator.h @License : Apache-2.0 @Desc : Abstract operator class. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : ScalarField.h @License : Apache-2.0 @Desc : ScalarField for the definition and calculation of scalar fields. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Solver.h @License : Apache-2.0 @Desc : Abstract solver class to provide unified interfaces. Solver 's responsible for parsing the equation expression to be solved, and discretizing the equation items in the computational domain, combining them into a matrix, and solving it. Solver is also responsible for initializing the relevant field quantities, and providing specific discrete and stepping scheme. Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : Source.h @License : Apache-2.0 @Desc : Abstract Source class for definition of source vector. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : TensorField.h @License : Apache-2.0 @Desc : TensorField for the definition and calculation of tensor fields. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : VectorField.h @License : Apache-2.0 @Desc : VectorField for the definition and calculation of vector fields.","title":"Detailed Description"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#enum-fielddomain","text":"enum OpenOasis :: CommImp :: Numeric :: FieldDomain { NONE , NODE , FACE , CELL };","title":"enum FieldDomain"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#enum-fieldtype","text":"enum OpenOasis :: CommImp :: Numeric :: FieldType { NONE , SCALAR , VECTOR , TENSOR };","title":"enum FieldType"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#typedef-lineareqs","text":"using OpenOasis :: CommImp :: Numeric :: LinearEqs = typedef std :: tuple < Matrix < real > , std :: vector < real > > ;","title":"typedef LinearEqs"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#typedef-scalarfielddbl","text":"using OpenOasis :: CommImp :: Numeric :: ScalarFieldDbl = typedef ScalarField < double > ;","title":"typedef ScalarFieldDbl"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#typedef-scalarfieldfp","text":"using OpenOasis :: CommImp :: Numeric :: ScalarFieldFp = typedef ScalarField < Utils :: real > ;","title":"typedef ScalarFieldFp"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#typedef-scalarfieldint","text":"using OpenOasis :: CommImp :: Numeric :: ScalarFieldInt = typedef ScalarField < int > ;","title":"typedef ScalarFieldInt"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#enum-solverstatus","text":"enum OpenOasis :: CommImp :: Numeric :: SolverStatus { Created , Initialized , Parsed , Discretized , Updated , Solved , Failed };","title":"enum SolverStatus"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#typedef-tensorfielddbl","text":"using OpenOasis :: CommImp :: Numeric :: TensorFieldDbl = typedef TensorField < double > ;","title":"typedef TensorFieldDbl"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#typedef-tensorfieldfp","text":"using OpenOasis :: CommImp :: Numeric :: TensorFieldFp = typedef TensorField < Utils :: real > ;","title":"typedef TensorFieldFp"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#typedef-tensorfieldint","text":"using OpenOasis :: CommImp :: Numeric :: TensorFieldInt = typedef TensorField < int > ;","title":"typedef TensorFieldInt"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#typedef-vectorfielddbl2d","text":"using OpenOasis :: CommImp :: Numeric :: VectorFieldDbl2D = typedef VectorField < double , 2 > ;","title":"typedef VectorFieldDbl2D"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#typedef-vectorfielddbl3d","text":"using OpenOasis :: CommImp :: Numeric :: VectorFieldDbl3D = typedef VectorField < double , 3 > ;","title":"typedef VectorFieldDbl3D"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#typedef-vectorfieldfp","text":"using OpenOasis :: CommImp :: Numeric :: VectorFieldFp = typedef VectorField < Utils :: real , 3 > ;","title":"typedef VectorFieldFp"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#typedef-vectorfieldint2d","text":"using OpenOasis :: CommImp :: Numeric :: VectorFieldInt2D = typedef VectorField < int , 2 > ;","title":"typedef VectorFieldInt2D"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric/#typedef-vectorfieldint3d","text":"using OpenOasis :: CommImp :: Numeric :: VectorFieldInt3D = typedef VectorField < int , 3 > ; The documentation for this class was generated from the following file Models/CommImp/Numeric/Boundary.h","title":"typedef VectorFieldInt3D"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary/","text":"Class OpenOasis::CommImp::Numeric::Boundary \u00b6 ClassList > OpenOasis > CommImp > Numeric > Boundary Abstract boundary class. #include <Boundary.h> Inherited by the following classes: OpenOasis::CommImp::Numeric::DirichletBoundary Public Functions \u00b6 Type Name virtual BoundaryCondition GetBoundaryCondition () = 0 virtual std::string GetType () const = 0 virtual void SetBoundaryFlux (real flux) = 0 virtual void SetBoundaryValue (real value) = 0 Public Functions Documentation \u00b6 function GetBoundaryCondition \u00b6 virtual BoundaryCondition OpenOasis :: CommImp :: Numeric :: Boundary :: GetBoundaryCondition () = 0 function GetType \u00b6 virtual std :: string OpenOasis :: CommImp :: Numeric :: Boundary :: GetType () const = 0 function SetBoundaryFlux \u00b6 virtual void OpenOasis :: CommImp :: Numeric :: Boundary :: SetBoundaryFlux ( real flux ) = 0 function SetBoundaryValue \u00b6 virtual void OpenOasis :: CommImp :: Numeric :: Boundary :: SetBoundaryValue ( real value ) = 0 The documentation for this class was generated from the following file Models/CommImp/Numeric/Boundary.h","title":"Class OpenOasis::CommImp::Numeric::Boundary"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary/#class-openoasiscommimpnumericboundary","text":"ClassList > OpenOasis > CommImp > Numeric > Boundary Abstract boundary class. #include <Boundary.h> Inherited by the following classes: OpenOasis::CommImp::Numeric::DirichletBoundary","title":"Class OpenOasis::CommImp::Numeric::Boundary"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary/#public-functions","text":"Type Name virtual BoundaryCondition GetBoundaryCondition () = 0 virtual std::string GetType () const = 0 virtual void SetBoundaryFlux (real flux) = 0 virtual void SetBoundaryValue (real value) = 0","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary/#function-getboundarycondition","text":"virtual BoundaryCondition OpenOasis :: CommImp :: Numeric :: Boundary :: GetBoundaryCondition () = 0","title":"function GetBoundaryCondition"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary/#function-gettype","text":"virtual std :: string OpenOasis :: CommImp :: Numeric :: Boundary :: GetType () const = 0","title":"function GetType"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary/#function-setboundaryflux","text":"virtual void OpenOasis :: CommImp :: Numeric :: Boundary :: SetBoundaryFlux ( real flux ) = 0","title":"function SetBoundaryFlux"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary/#function-setboundaryvalue","text":"virtual void OpenOasis :: CommImp :: Numeric :: Boundary :: SetBoundaryValue ( real value ) = 0 The documentation for this class was generated from the following file Models/CommImp/Numeric/Boundary.h","title":"function SetBoundaryValue"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary_condition/","text":"Struct OpenOasis::CommImp::Numeric::BoundaryCondition \u00b6 ClassList > OpenOasis > CommImp > Numeric > BoundaryCondition Boundary condition struct. #include <Boundary.h> Public Attributes \u00b6 Type Name real flux = = NAN std::string type real value = = NAN Public Attributes Documentation \u00b6 variable flux \u00b6 real OpenOasis :: CommImp :: Numeric :: BoundaryCondition :: flux ; variable type \u00b6 std :: string OpenOasis :: CommImp :: Numeric :: BoundaryCondition :: type ; variable value \u00b6 real OpenOasis :: CommImp :: Numeric :: BoundaryCondition :: value ; The documentation for this class was generated from the following file Models/CommImp/Numeric/Boundary.h","title":"Struct OpenOasis::CommImp::Numeric::BoundaryCondition"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary_condition/#struct-openoasiscommimpnumericboundarycondition","text":"ClassList > OpenOasis > CommImp > Numeric > BoundaryCondition Boundary condition struct. #include <Boundary.h>","title":"Struct OpenOasis::CommImp::Numeric::BoundaryCondition"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary_condition/#public-attributes","text":"Type Name real flux = = NAN std::string type real value = = NAN","title":"Public Attributes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary_condition/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary_condition/#variable-flux","text":"real OpenOasis :: CommImp :: Numeric :: BoundaryCondition :: flux ;","title":"variable flux"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary_condition/#variable-type","text":"std :: string OpenOasis :: CommImp :: Numeric :: BoundaryCondition :: type ;","title":"variable type"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_boundary_condition/#variable-value","text":"real OpenOasis :: CommImp :: Numeric :: BoundaryCondition :: value ; The documentation for this class was generated from the following file Models/CommImp/Numeric/Boundary.h","title":"variable value"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_dirichlet_boundary/","text":"Class OpenOasis::CommImp::Numeric::DirichletBoundary \u00b6 ClassList > OpenOasis > CommImp > Numeric > DirichletBoundary Dirichlet boundary. #include <DirichletBoundary.h> Inherits the following classes: OpenOasis::CommImp::Numeric::Boundary Public Functions \u00b6 Type Name DirichletBoundary () DirichletBoundary (real value) DirichletBoundary (const DirichletBoundary & other) virtual BoundaryCondition GetBoundaryCondition () override virtual std::string GetType () override const virtual void SetBoundaryFlux (real flux) override virtual void SetBoundaryValue (real value) override Public Functions inherited from OpenOasis::CommImp::Numeric::Boundary \u00b6 See OpenOasis::CommImp::Numeric::Boundary Type Name virtual BoundaryCondition GetBoundaryCondition () = 0 virtual std::string GetType () const = 0 virtual void SetBoundaryFlux (real flux) = 0 virtual void SetBoundaryValue (real value) = 0 Public Functions Documentation \u00b6 function DirichletBoundary [\u2153] \u00b6 OpenOasis :: CommImp :: Numeric :: DirichletBoundary :: DirichletBoundary () function DirichletBoundary [\u2154] \u00b6 OpenOasis :: CommImp :: Numeric :: DirichletBoundary :: DirichletBoundary ( real value ) function DirichletBoundary [3/3] \u00b6 OpenOasis :: CommImp :: Numeric :: DirichletBoundary :: DirichletBoundary ( const DirichletBoundary & other ) function GetBoundaryCondition \u00b6 virtual BoundaryCondition OpenOasis :: CommImp :: Numeric :: DirichletBoundary :: GetBoundaryCondition () override Implements OpenOasis::CommImp::Numeric::Boundary::GetBoundaryCondition function GetType \u00b6 virtual std :: string OpenOasis :: CommImp :: Numeric :: DirichletBoundary :: GetType () override const Implements OpenOasis::CommImp::Numeric::Boundary::GetType function SetBoundaryFlux \u00b6 virtual void OpenOasis :: CommImp :: Numeric :: DirichletBoundary :: SetBoundaryFlux ( real flux ) override Implements OpenOasis::CommImp::Numeric::Boundary::SetBoundaryFlux function SetBoundaryValue \u00b6 virtual void OpenOasis :: CommImp :: Numeric :: DirichletBoundary :: SetBoundaryValue ( real value ) override Implements OpenOasis::CommImp::Numeric::Boundary::SetBoundaryValue The documentation for this class was generated from the following file Models/CommImp/Numeric/DirichletBoundary.h","title":"Class OpenOasis::CommImp::Numeric::DirichletBoundary"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_dirichlet_boundary/#class-openoasiscommimpnumericdirichletboundary","text":"ClassList > OpenOasis > CommImp > Numeric > DirichletBoundary Dirichlet boundary. #include <DirichletBoundary.h> Inherits the following classes: OpenOasis::CommImp::Numeric::Boundary","title":"Class OpenOasis::CommImp::Numeric::DirichletBoundary"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_dirichlet_boundary/#public-functions","text":"Type Name DirichletBoundary () DirichletBoundary (real value) DirichletBoundary (const DirichletBoundary & other) virtual BoundaryCondition GetBoundaryCondition () override virtual std::string GetType () override const virtual void SetBoundaryFlux (real flux) override virtual void SetBoundaryValue (real value) override","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_dirichlet_boundary/#public-functions-inherited-from-openoasiscommimpnumericboundary","text":"See OpenOasis::CommImp::Numeric::Boundary Type Name virtual BoundaryCondition GetBoundaryCondition () = 0 virtual std::string GetType () const = 0 virtual void SetBoundaryFlux (real flux) = 0 virtual void SetBoundaryValue (real value) = 0","title":"Public Functions inherited from OpenOasis::CommImp::Numeric::Boundary"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_dirichlet_boundary/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_dirichlet_boundary/#function-dirichletboundary-13","text":"OpenOasis :: CommImp :: Numeric :: DirichletBoundary :: DirichletBoundary ()","title":"function DirichletBoundary [&#8531;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_dirichlet_boundary/#function-dirichletboundary-23","text":"OpenOasis :: CommImp :: Numeric :: DirichletBoundary :: DirichletBoundary ( real value )","title":"function DirichletBoundary [&#8532;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_dirichlet_boundary/#function-dirichletboundary-33","text":"OpenOasis :: CommImp :: Numeric :: DirichletBoundary :: DirichletBoundary ( const DirichletBoundary & other )","title":"function DirichletBoundary [3/3]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_dirichlet_boundary/#function-getboundarycondition","text":"virtual BoundaryCondition OpenOasis :: CommImp :: Numeric :: DirichletBoundary :: GetBoundaryCondition () override Implements OpenOasis::CommImp::Numeric::Boundary::GetBoundaryCondition","title":"function GetBoundaryCondition"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_dirichlet_boundary/#function-gettype","text":"virtual std :: string OpenOasis :: CommImp :: Numeric :: DirichletBoundary :: GetType () override const Implements OpenOasis::CommImp::Numeric::Boundary::GetType","title":"function GetType"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_dirichlet_boundary/#function-setboundaryflux","text":"virtual void OpenOasis :: CommImp :: Numeric :: DirichletBoundary :: SetBoundaryFlux ( real flux ) override Implements OpenOasis::CommImp::Numeric::Boundary::SetBoundaryFlux","title":"function SetBoundaryFlux"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_dirichlet_boundary/#function-setboundaryvalue","text":"virtual void OpenOasis :: CommImp :: Numeric :: DirichletBoundary :: SetBoundaryValue ( real value ) override Implements OpenOasis::CommImp::Numeric::Boundary::SetBoundaryValue The documentation for this class was generated from the following file Models/CommImp/Numeric/DirichletBoundary.h","title":"function SetBoundaryValue"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/","text":"Class OpenOasis::CommImp::Numeric::DoubleSparseMatrix \u00b6 ClassList > OpenOasis > CommImp > Numeric > DoubleSparseMatrix Sparse matrix having double elements. #include <Matrix.h> Classes \u00b6 Type Name struct EqualFunc struct HashFunc class Index Public Attributes \u00b6 Type Name std::unordered_map< Index , Utils::real, HashFunc , EqualFunc > mValues Public Functions \u00b6 Type Name Utils::real At (int row, int column) DoubleSparseMatrix (int rowCount, int columnCount) int GetColumnCount () const int GetRowCount () const bool IsCellEmpty (int row, int column) std::vector< Utils::real > Product (const std::vector< Utils::real > & vector2) void Product (std::vector< Utils::real > & res, const std::vector< Utils::real > & vector2) void SetColumnCount (int value) void SetRowCount (int value) void SetValue (int row, int column, Utils::real value) Utils::real operator() (int row, int column) Public Attributes Documentation \u00b6 variable mValues \u00b6 std :: unordered_map < Index , Utils :: real , HashFunc , EqualFunc > OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: mValues ; Public Functions Documentation \u00b6 function At \u00b6 Utils :: real OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: At ( int row , int column ) function DoubleSparseMatrix \u00b6 OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: DoubleSparseMatrix ( int rowCount , int columnCount ) function GetColumnCount \u00b6 int OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: GetColumnCount () const function GetRowCount \u00b6 int OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: GetRowCount () const function IsCellEmpty \u00b6 bool OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: IsCellEmpty ( int row , int column ) function Product [\u00bd] \u00b6 std :: vector < Utils :: real > OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: Product ( const std :: vector < Utils :: real > & vector2 ) function Product [2/2] \u00b6 void OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: Product ( std :: vector < Utils :: real > & res , const std :: vector < Utils :: real > & vector2 ) function SetColumnCount \u00b6 void OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: SetColumnCount ( int value ) function SetRowCount \u00b6 void OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: SetRowCount ( int value ) function SetValue \u00b6 void OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: SetValue ( int row , int column , Utils :: real value ) function operator() \u00b6 Utils :: real OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: operator () ( int row , int column ) The documentation for this class was generated from the following file Models/CommImp/Numeric/Matrix.h","title":"Class OpenOasis::CommImp::Numeric::DoubleSparseMatrix"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#class-openoasiscommimpnumericdoublesparsematrix","text":"ClassList > OpenOasis > CommImp > Numeric > DoubleSparseMatrix Sparse matrix having double elements. #include <Matrix.h>","title":"Class OpenOasis::CommImp::Numeric::DoubleSparseMatrix"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#classes","text":"Type Name struct EqualFunc struct HashFunc class Index","title":"Classes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#public-attributes","text":"Type Name std::unordered_map< Index , Utils::real, HashFunc , EqualFunc > mValues","title":"Public Attributes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#public-functions","text":"Type Name Utils::real At (int row, int column) DoubleSparseMatrix (int rowCount, int columnCount) int GetColumnCount () const int GetRowCount () const bool IsCellEmpty (int row, int column) std::vector< Utils::real > Product (const std::vector< Utils::real > & vector2) void Product (std::vector< Utils::real > & res, const std::vector< Utils::real > & vector2) void SetColumnCount (int value) void SetRowCount (int value) void SetValue (int row, int column, Utils::real value) Utils::real operator() (int row, int column)","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#variable-mvalues","text":"std :: unordered_map < Index , Utils :: real , HashFunc , EqualFunc > OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: mValues ;","title":"variable mValues"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#function-at","text":"Utils :: real OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: At ( int row , int column )","title":"function At"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#function-doublesparsematrix","text":"OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: DoubleSparseMatrix ( int rowCount , int columnCount )","title":"function DoubleSparseMatrix"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#function-getcolumncount","text":"int OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: GetColumnCount () const","title":"function GetColumnCount"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#function-getrowcount","text":"int OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: GetRowCount () const","title":"function GetRowCount"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#function-iscellempty","text":"bool OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: IsCellEmpty ( int row , int column )","title":"function IsCellEmpty"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#function-product-12","text":"std :: vector < Utils :: real > OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: Product ( const std :: vector < Utils :: real > & vector2 )","title":"function Product [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#function-product-22","text":"void OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: Product ( std :: vector < Utils :: real > & res , const std :: vector < Utils :: real > & vector2 )","title":"function Product [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#function-setcolumncount","text":"void OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: SetColumnCount ( int value )","title":"function SetColumnCount"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#function-setrowcount","text":"void OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: SetRowCount ( int value )","title":"function SetRowCount"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#function-setvalue","text":"void OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: SetValue ( int row , int column , Utils :: real value )","title":"function SetValue"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix/#function-operator","text":"Utils :: real OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: operator () ( int row , int column ) The documentation for this class was generated from the following file Models/CommImp/Numeric/Matrix.h","title":"function operator()"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_equal_func/","text":"Struct OpenOasis::CommImp::Numeric::DoubleSparseMatrix::EqualFunc \u00b6 ClassList > OpenOasis > CommImp > Numeric > DoubleSparseMatrix > EqualFunc Public Functions \u00b6 Type Name bool operator() (const Index & lhs, const Index & rhs) const Public Functions Documentation \u00b6 function operator() \u00b6 bool OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: EqualFunc :: operator () ( const Index & lhs , const Index & rhs ) const The documentation for this class was generated from the following file Models/CommImp/Numeric/Matrix.h","title":"Struct OpenOasis::CommImp::Numeric::DoubleSparseMatrix::EqualFunc"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_equal_func/#struct-openoasiscommimpnumericdoublesparsematrixequalfunc","text":"ClassList > OpenOasis > CommImp > Numeric > DoubleSparseMatrix > EqualFunc","title":"Struct OpenOasis::CommImp::Numeric::DoubleSparseMatrix::EqualFunc"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_equal_func/#public-functions","text":"Type Name bool operator() (const Index & lhs, const Index & rhs) const","title":"Public Functions"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_equal_func/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_equal_func/#function-operator","text":"bool OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: EqualFunc :: operator () ( const Index & lhs , const Index & rhs ) const The documentation for this class was generated from the following file Models/CommImp/Numeric/Matrix.h","title":"function operator()"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_hash_func/","text":"Struct OpenOasis::CommImp::Numeric::DoubleSparseMatrix::HashFunc \u00b6 ClassList > OpenOasis > CommImp > Numeric > DoubleSparseMatrix > HashFunc Public Functions \u00b6 Type Name size_t operator() (const Index & key) const Public Functions Documentation \u00b6 function operator() \u00b6 size_t OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: HashFunc :: operator () ( const Index & key ) const The documentation for this class was generated from the following file Models/CommImp/Numeric/Matrix.h","title":"Struct OpenOasis::CommImp::Numeric::DoubleSparseMatrix::HashFunc"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_hash_func/#struct-openoasiscommimpnumericdoublesparsematrixhashfunc","text":"ClassList > OpenOasis > CommImp > Numeric > DoubleSparseMatrix > HashFunc","title":"Struct OpenOasis::CommImp::Numeric::DoubleSparseMatrix::HashFunc"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_hash_func/#public-functions","text":"Type Name size_t operator() (const Index & key) const","title":"Public Functions"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_hash_func/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_hash_func/#function-operator","text":"size_t OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: HashFunc :: operator () ( const Index & key ) const The documentation for this class was generated from the following file Models/CommImp/Numeric/Matrix.h","title":"function operator()"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_index/","text":"Class OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index \u00b6 ClassList > OpenOasis > CommImp > Numeric > DoubleSparseMatrix > Index Public Attributes \u00b6 Type Name int mCol = = 0 int mRow = = 0 Public Functions \u00b6 Type Name Index (int row, int column) Index () = default Public Attributes Documentation \u00b6 variable mCol \u00b6 int OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: Index :: mCol ; variable mRow \u00b6 int OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: Index :: mRow ; Public Functions Documentation \u00b6 function Index [\u00bd] \u00b6 OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: Index :: Index ( int row , int column ) function Index [2/2] \u00b6 OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: Index :: Index () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/Matrix.h","title":"Class OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_index/#class-openoasiscommimpnumericdoublesparsematrixindex","text":"ClassList > OpenOasis > CommImp > Numeric > DoubleSparseMatrix > Index","title":"Class OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_index/#public-attributes","text":"Type Name int mCol = = 0 int mRow = = 0","title":"Public Attributes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_index/#public-functions","text":"Type Name Index (int row, int column) Index () = default","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_index/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_index/#variable-mcol","text":"int OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: Index :: mCol ;","title":"variable mCol"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_index/#variable-mrow","text":"int OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: Index :: mRow ;","title":"variable mRow"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_index/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_index/#function-index-12","text":"OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: Index :: Index ( int row , int column )","title":"function Index [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_double_sparse_matrix_1_1_index/#function-index-22","text":"OpenOasis :: CommImp :: Numeric :: DoubleSparseMatrix :: Index :: Index () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/Matrix.h","title":"function Index [2/2]"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m/","text":"Namespace OpenOasis::CommImp::Numeric::FVM \u00b6 Namespace List > OpenOasis > CommImp > Numeric > FVM More... Classes \u00b6 Type Name class FvmSolver Detailed Description \u00b6 @File : FvmSolver.cpp @Brief : None Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : FvmSolver.h @License : Apache-2.0 @Desc : Discrete scheme based on finite volume method. The documentation for this class was generated from the following file Models/CommImp/Numeric/FVM/FvmSolver.cpp","title":"Namespace OpenOasis::CommImp::Numeric::FVM"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m/#namespace-openoasiscommimpnumericfvm","text":"Namespace List > OpenOasis > CommImp > Numeric > FVM More...","title":"Namespace OpenOasis::CommImp::Numeric::FVM"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m/#classes","text":"Type Name class FvmSolver","title":"Classes"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m/#detailed-description","text":"@File : FvmSolver.cpp @Brief : None Copyright (C) 2023, The OpenOasis Contributors. Join us in the Oasis! @File : FvmSolver.h @License : Apache-2.0 @Desc : Discrete scheme based on finite volume method. The documentation for this class was generated from the following file Models/CommImp/Numeric/FVM/FvmSolver.cpp","title":"Detailed Description"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m_1_1_fvm_solver/","text":"Class OpenOasis::CommImp::Numeric::FVM::FvmSolver \u00b6 ClassList > OpenOasis > CommImp > Numeric > FVM > FvmSolver Inherits the following classes: OpenOasis::CommImp::Numeric::Solver Public Functions \u00b6 Type Name FvmSolver (const std::shared_ptr< Grid > & grid) virtual std::optional< ScalarFieldFp > GetScalarSolutions (const std::string & var) override const virtual void ParseDiffusionTerm () override virtual void SetBoundary (int faceIndex, const std::shared_ptr< Boundary > & bound) override virtual void SetCoefficient (const std::string & var, const std::variant< real, Vector < real >, Tensor < real > > & coeff) override virtual void SetInitialValue (const std::string & var, const std::variant< real, Vector < real >, Tensor < real > > & value) override virtual void Solve () override ~FvmSolver () = default Public Functions inherited from OpenOasis::CommImp::Numeric::Solver \u00b6 See OpenOasis::CommImp::Numeric::Solver Type Name virtual void AfterScheme () virtual void AfterSolve () virtual void BeforeScheme () virtual void BeforeSolve () std::optional< LinearEqs > GetLinearEqs () const virtual std::optional< ScalarFieldFp > GetScalarSolutions (const std::string & var) const virtual std::optional< TensorFieldFp > GetTensorSolutions (const std::string & var) const virtual std::optional< VectorFieldFp > GetVectorSolutions (const std::string & var) const virtual void ParseConvectionTerm () virtual void ParseDiffusionTerm () virtual void ParseSourceTerm () virtual void ParseTimeDerivativeTerm () virtual void Scheme () virtual void SetBoundary (int faceIndex, const std::shared_ptr< Boundary > & bound) virtual void SetCoefficient (const std::string & var, const std::variant< real, Vector < real >, Tensor < real > > & coeff) virtual void SetCoefficient (const std::string & var, const ScalarFieldFp & coeffs) virtual void SetCoefficient (const std::string & var, const VectorFieldFp & coeffs) virtual void SetCoefficient (const std::string & var, const TensorFieldFp & coeffs) virtual void SetInitialValue (const std::string & var, const std::variant< real, Vector < real >, Tensor < real > > & value) virtual void SetInitialValue (const std::string & var, const ScalarFieldFp & values) virtual void SetInitialValue (const std::string & var, const VectorFieldFp & values) virtual void SetInitialValue (const std::string & var, const TensorFieldFp & values) virtual void Solve () Public Functions Documentation \u00b6 function FvmSolver \u00b6 OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver :: FvmSolver ( const std :: shared_ptr < Grid > & grid ) function GetScalarSolutions \u00b6 virtual std :: optional < ScalarFieldFp > OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver :: GetScalarSolutions ( const std :: string & var ) override const Implements OpenOasis::CommImp::Numeric::Solver::GetScalarSolutions function ParseDiffusionTerm \u00b6 virtual void OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver :: ParseDiffusionTerm () override Implements OpenOasis::CommImp::Numeric::Solver::ParseDiffusionTerm function SetBoundary \u00b6 virtual void OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver :: SetBoundary ( int faceIndex , const std :: shared_ptr < Boundary > & bound ) override Implements OpenOasis::CommImp::Numeric::Solver::SetBoundary function SetCoefficient \u00b6 virtual void OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver :: SetCoefficient ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real > > & coeff ) override Implements OpenOasis::CommImp::Numeric::Solver::SetCoefficient function SetInitialValue \u00b6 virtual void OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver :: SetInitialValue ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real > > & value ) override Implements OpenOasis::CommImp::Numeric::Solver::SetInitialValue function Solve \u00b6 virtual void OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver :: Solve () override Implements OpenOasis::CommImp::Numeric::Solver::Solve function ~FvmSolver \u00b6 OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver ::~ FvmSolver () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/FVM/FvmSolver.h","title":"Class OpenOasis::CommImp::Numeric::FVM::FvmSolver"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m_1_1_fvm_solver/#class-openoasiscommimpnumericfvmfvmsolver","text":"ClassList > OpenOasis > CommImp > Numeric > FVM > FvmSolver Inherits the following classes: OpenOasis::CommImp::Numeric::Solver","title":"Class OpenOasis::CommImp::Numeric::FVM::FvmSolver"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m_1_1_fvm_solver/#public-functions","text":"Type Name FvmSolver (const std::shared_ptr< Grid > & grid) virtual std::optional< ScalarFieldFp > GetScalarSolutions (const std::string & var) override const virtual void ParseDiffusionTerm () override virtual void SetBoundary (int faceIndex, const std::shared_ptr< Boundary > & bound) override virtual void SetCoefficient (const std::string & var, const std::variant< real, Vector < real >, Tensor < real > > & coeff) override virtual void SetInitialValue (const std::string & var, const std::variant< real, Vector < real >, Tensor < real > > & value) override virtual void Solve () override ~FvmSolver () = default","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m_1_1_fvm_solver/#public-functions-inherited-from-openoasiscommimpnumericsolver","text":"See OpenOasis::CommImp::Numeric::Solver Type Name virtual void AfterScheme () virtual void AfterSolve () virtual void BeforeScheme () virtual void BeforeSolve () std::optional< LinearEqs > GetLinearEqs () const virtual std::optional< ScalarFieldFp > GetScalarSolutions (const std::string & var) const virtual std::optional< TensorFieldFp > GetTensorSolutions (const std::string & var) const virtual std::optional< VectorFieldFp > GetVectorSolutions (const std::string & var) const virtual void ParseConvectionTerm () virtual void ParseDiffusionTerm () virtual void ParseSourceTerm () virtual void ParseTimeDerivativeTerm () virtual void Scheme () virtual void SetBoundary (int faceIndex, const std::shared_ptr< Boundary > & bound) virtual void SetCoefficient (const std::string & var, const std::variant< real, Vector < real >, Tensor < real > > & coeff) virtual void SetCoefficient (const std::string & var, const ScalarFieldFp & coeffs) virtual void SetCoefficient (const std::string & var, const VectorFieldFp & coeffs) virtual void SetCoefficient (const std::string & var, const TensorFieldFp & coeffs) virtual void SetInitialValue (const std::string & var, const std::variant< real, Vector < real >, Tensor < real > > & value) virtual void SetInitialValue (const std::string & var, const ScalarFieldFp & values) virtual void SetInitialValue (const std::string & var, const VectorFieldFp & values) virtual void SetInitialValue (const std::string & var, const TensorFieldFp & values) virtual void Solve ()","title":"Public Functions inherited from OpenOasis::CommImp::Numeric::Solver"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m_1_1_fvm_solver/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m_1_1_fvm_solver/#function-fvmsolver","text":"OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver :: FvmSolver ( const std :: shared_ptr < Grid > & grid )","title":"function FvmSolver"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m_1_1_fvm_solver/#function-getscalarsolutions","text":"virtual std :: optional < ScalarFieldFp > OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver :: GetScalarSolutions ( const std :: string & var ) override const Implements OpenOasis::CommImp::Numeric::Solver::GetScalarSolutions","title":"function GetScalarSolutions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m_1_1_fvm_solver/#function-parsediffusionterm","text":"virtual void OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver :: ParseDiffusionTerm () override Implements OpenOasis::CommImp::Numeric::Solver::ParseDiffusionTerm","title":"function ParseDiffusionTerm"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m_1_1_fvm_solver/#function-setboundary","text":"virtual void OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver :: SetBoundary ( int faceIndex , const std :: shared_ptr < Boundary > & bound ) override Implements OpenOasis::CommImp::Numeric::Solver::SetBoundary","title":"function SetBoundary"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m_1_1_fvm_solver/#function-setcoefficient","text":"virtual void OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver :: SetCoefficient ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real > > & coeff ) override Implements OpenOasis::CommImp::Numeric::Solver::SetCoefficient","title":"function SetCoefficient"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m_1_1_fvm_solver/#function-setinitialvalue","text":"virtual void OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver :: SetInitialValue ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real > > & value ) override Implements OpenOasis::CommImp::Numeric::Solver::SetInitialValue","title":"function SetInitialValue"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m_1_1_fvm_solver/#function-solve","text":"virtual void OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver :: Solve () override Implements OpenOasis::CommImp::Numeric::Solver::Solve","title":"function Solve"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_f_v_m_1_1_fvm_solver/#function-fvmsolver_1","text":"OpenOasis :: CommImp :: Numeric :: FVM :: FvmSolver ::~ FvmSolver () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/FVM/FvmSolver.h","title":"function ~FvmSolver"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/","text":"Class OpenOasis::CommImp::Numeric::Field \u00b6 template <typename T> ClassList > OpenOasis > CommImp > Numeric > Field The abstract field class used to represent numeric field, such as scalar, vector or tensor data. #include <Field.h> Inherited by the following classes: OpenOasis::CommImp::Numeric::ScalarField , OpenOasis::CommImp::Numeric::ScalarField , OpenOasis::CommImp::Numeric::VectorField Public Functions \u00b6 Type Name void Clean () Cleans the field data to the default value. void Clear () Clears the field. const std::vector< T > & Data () const Returns constant refrence to the field data. void ForEach (Callback func) Iterates the field and invoke given func for each element. void Initialize (T value) Initializes the vector field with specified value. FieldDomain Range () const void Resize (std::size_t size) Resizes the field. void SetAt (std::size_t i, T value) Sets the field data. void SetAt (std::size_t startIndex, std::size_t endIndex, const Field < T > & other, std::size_t offset=0) Sets the field data from the specified range. std::size_t Size () const Returns the field size. FieldType Type () const const T & operator() (int i) const T & operator() (int i) Field < T > operator* (double k) const void operator*= (double k) Field < T > operator+ (const Field < T > & other) const void operator+= (const Field < T > & other) Field < T > operator- (const Field < T > & other) const void operator-= (const Field < T > & other) void operator= (const Field < T > & other) void operator= (const T & value) Protected Attributes \u00b6 Type Name std::vector< T > mData T mDefault FieldDomain mDomain = = FieldDomain::NONE FieldType mType = = FieldType::NONE Protected Functions \u00b6 Type Name Field () = default Field (std::size_t size, T value) virtual ~Field () = default Public Functions Documentation \u00b6 function Clean \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Field :: Clean () function Clear \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Field :: Clear () function Data \u00b6 inline const std :: vector < T > & OpenOasis :: CommImp :: Numeric :: Field :: Data () const function ForEach \u00b6 Iterates the field and invoke given func for each element. template < typename Callback > inline void OpenOasis :: CommImp :: Numeric :: Field :: ForEach ( Callback func ) This function iterates the field elements and invoke the callback function func . The callback function takes field's element as its input. function Initialize \u00b6 Initializes the vector field with specified value. inline void OpenOasis :: CommImp :: Numeric :: Field :: Initialize ( T value ) Parameters: value The initial value. function Range \u00b6 inline FieldDomain OpenOasis :: CommImp :: Numeric :: Field :: Range () const function Resize \u00b6 Resizes the field. inline void OpenOasis :: CommImp :: Numeric :: Field :: Resize ( std :: size_t size ) Parameters: size New size. function SetAt [\u00bd] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Field :: SetAt ( std :: size_t i , T value ) function SetAt [2/2] \u00b6 Sets the field data from the specified range. inline void OpenOasis :: CommImp :: Numeric :: Field :: SetAt ( std :: size_t startIndex , std :: size_t endIndex , const Field < T > & other , std :: size_t offset = 0 ) Parameters: startIndex Start index of the range. endIndex End index of the range. other Source field. offset Index offset of the source field. function Size \u00b6 inline std :: size_t OpenOasis :: CommImp :: Numeric :: Field :: Size () const function Type \u00b6 inline FieldType OpenOasis :: CommImp :: Numeric :: Field :: Type () const function operator() [\u00bd] \u00b6 inline const T & OpenOasis :: CommImp :: Numeric :: Field :: operator () ( int i ) const function operator() [2/2] \u00b6 inline T & OpenOasis :: CommImp :: Numeric :: Field :: operator () ( int i ) function operator* \u00b6 inline Field < T > OpenOasis :: CommImp :: Numeric :: Field :: operator * ( double k ) const function operator*= \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Field :: operator *= ( double k ) function operator+ \u00b6 inline Field < T > OpenOasis :: CommImp :: Numeric :: Field :: operator + ( const Field < T > & other ) const function operator+= \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Field :: operator += ( const Field < T > & other ) function operator- \u00b6 inline Field < T > OpenOasis :: CommImp :: Numeric :: Field :: operator - ( const Field < T > & other ) const function operator-= \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Field :: operator -= ( const Field < T > & other ) function operator= \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Field :: operator = ( const Field < T > & other ) function operator= \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Field :: operator = ( const T & value ) Protected Attributes Documentation \u00b6 variable mData \u00b6 std :: vector < T > OpenOasis :: CommImp :: Numeric :: Field < T >:: mData ; variable mDefault \u00b6 T OpenOasis :: CommImp :: Numeric :: Field < T >:: mDefault ; variable mDomain \u00b6 FieldDomain OpenOasis :: CommImp :: Numeric :: Field < T >:: mDomain ; variable mType \u00b6 FieldType OpenOasis :: CommImp :: Numeric :: Field < T >:: mType ; Protected Functions Documentation \u00b6 function Field [\u00bd] \u00b6 OpenOasis :: CommImp :: Numeric :: Field :: Field () = default function Field [2/2] \u00b6 inline OpenOasis :: CommImp :: Numeric :: Field :: Field ( std :: size_t size , T value ) function ~Field \u00b6 virtual OpenOasis :: CommImp :: Numeric :: Field ::~ Field () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/Field.h","title":"Class OpenOasis::CommImp::Numeric::Field"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#class-openoasiscommimpnumericfield","text":"template <typename T> ClassList > OpenOasis > CommImp > Numeric > Field The abstract field class used to represent numeric field, such as scalar, vector or tensor data. #include <Field.h> Inherited by the following classes: OpenOasis::CommImp::Numeric::ScalarField , OpenOasis::CommImp::Numeric::ScalarField , OpenOasis::CommImp::Numeric::VectorField","title":"Class OpenOasis::CommImp::Numeric::Field"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#public-functions","text":"Type Name void Clean () Cleans the field data to the default value. void Clear () Clears the field. const std::vector< T > & Data () const Returns constant refrence to the field data. void ForEach (Callback func) Iterates the field and invoke given func for each element. void Initialize (T value) Initializes the vector field with specified value. FieldDomain Range () const void Resize (std::size_t size) Resizes the field. void SetAt (std::size_t i, T value) Sets the field data. void SetAt (std::size_t startIndex, std::size_t endIndex, const Field < T > & other, std::size_t offset=0) Sets the field data from the specified range. std::size_t Size () const Returns the field size. FieldType Type () const const T & operator() (int i) const T & operator() (int i) Field < T > operator* (double k) const void operator*= (double k) Field < T > operator+ (const Field < T > & other) const void operator+= (const Field < T > & other) Field < T > operator- (const Field < T > & other) const void operator-= (const Field < T > & other) void operator= (const Field < T > & other) void operator= (const T & value)","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#protected-attributes","text":"Type Name std::vector< T > mData T mDefault FieldDomain mDomain = = FieldDomain::NONE FieldType mType = = FieldType::NONE","title":"Protected Attributes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#protected-functions","text":"Type Name Field () = default Field (std::size_t size, T value) virtual ~Field () = default","title":"Protected Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-clean","text":"inline void OpenOasis :: CommImp :: Numeric :: Field :: Clean ()","title":"function Clean"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-clear","text":"inline void OpenOasis :: CommImp :: Numeric :: Field :: Clear ()","title":"function Clear"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-data","text":"inline const std :: vector < T > & OpenOasis :: CommImp :: Numeric :: Field :: Data () const","title":"function Data"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-foreach","text":"Iterates the field and invoke given func for each element. template < typename Callback > inline void OpenOasis :: CommImp :: Numeric :: Field :: ForEach ( Callback func ) This function iterates the field elements and invoke the callback function func . The callback function takes field's element as its input.","title":"function ForEach"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-initialize","text":"Initializes the vector field with specified value. inline void OpenOasis :: CommImp :: Numeric :: Field :: Initialize ( T value ) Parameters: value The initial value.","title":"function Initialize"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-range","text":"inline FieldDomain OpenOasis :: CommImp :: Numeric :: Field :: Range () const","title":"function Range"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-resize","text":"Resizes the field. inline void OpenOasis :: CommImp :: Numeric :: Field :: Resize ( std :: size_t size ) Parameters: size New size.","title":"function Resize"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-setat-12","text":"inline void OpenOasis :: CommImp :: Numeric :: Field :: SetAt ( std :: size_t i , T value )","title":"function SetAt [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-setat-22","text":"Sets the field data from the specified range. inline void OpenOasis :: CommImp :: Numeric :: Field :: SetAt ( std :: size_t startIndex , std :: size_t endIndex , const Field < T > & other , std :: size_t offset = 0 ) Parameters: startIndex Start index of the range. endIndex End index of the range. other Source field. offset Index offset of the source field.","title":"function SetAt [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-size","text":"inline std :: size_t OpenOasis :: CommImp :: Numeric :: Field :: Size () const","title":"function Size"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-type","text":"inline FieldType OpenOasis :: CommImp :: Numeric :: Field :: Type () const","title":"function Type"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-operator-12","text":"inline const T & OpenOasis :: CommImp :: Numeric :: Field :: operator () ( int i ) const","title":"function operator() [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-operator-22","text":"inline T & OpenOasis :: CommImp :: Numeric :: Field :: operator () ( int i )","title":"function operator() [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-operator","text":"inline Field < T > OpenOasis :: CommImp :: Numeric :: Field :: operator * ( double k ) const","title":"function operator*"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-operator_1","text":"inline void OpenOasis :: CommImp :: Numeric :: Field :: operator *= ( double k )","title":"function operator*="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-operator_2","text":"inline Field < T > OpenOasis :: CommImp :: Numeric :: Field :: operator + ( const Field < T > & other ) const","title":"function operator+"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-operator_3","text":"inline void OpenOasis :: CommImp :: Numeric :: Field :: operator += ( const Field < T > & other )","title":"function operator+="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-operator-","text":"inline Field < T > OpenOasis :: CommImp :: Numeric :: Field :: operator - ( const Field < T > & other ) const","title":"function operator-"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-operator-_1","text":"inline void OpenOasis :: CommImp :: Numeric :: Field :: operator -= ( const Field < T > & other )","title":"function operator-="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-operator_4","text":"inline void OpenOasis :: CommImp :: Numeric :: Field :: operator = ( const Field < T > & other )","title":"function operator="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-operator_5","text":"inline void OpenOasis :: CommImp :: Numeric :: Field :: operator = ( const T & value )","title":"function operator="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#variable-mdata","text":"std :: vector < T > OpenOasis :: CommImp :: Numeric :: Field < T >:: mData ;","title":"variable mData"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#variable-mdefault","text":"T OpenOasis :: CommImp :: Numeric :: Field < T >:: mDefault ;","title":"variable mDefault"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#variable-mdomain","text":"FieldDomain OpenOasis :: CommImp :: Numeric :: Field < T >:: mDomain ;","title":"variable mDomain"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#variable-mtype","text":"FieldType OpenOasis :: CommImp :: Numeric :: Field < T >:: mType ;","title":"variable mType"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-field-12","text":"OpenOasis :: CommImp :: Numeric :: Field :: Field () = default","title":"function Field [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-field-22","text":"inline OpenOasis :: CommImp :: Numeric :: Field :: Field ( std :: size_t size , T value )","title":"function Field [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_field/#function-field","text":"virtual OpenOasis :: CommImp :: Numeric :: Field ::~ Field () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/Field.h","title":"function ~Field"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_laplacian/","text":"Class OpenOasis::CommImp::Numeric::Laplacian \u00b6 ClassList > OpenOasis > CommImp > Numeric > Laplacian Laplacian operator for the divergence of the gradient of a scalar field. More... #include <LaplacianOperator.h> Inherits the following classes: OpenOasis::CommImp::Numeric::Operator Public Functions \u00b6 Type Name virtual LinearEqs Discretize (const ScalarField < real > & phiCellField, const ScalarField < real > & phiFaceField) override Laplacian (const std::shared_ptr< Grid > & grid) virtual ~Laplacian () = default Public Functions inherited from OpenOasis::CommImp::Numeric::Operator \u00b6 See OpenOasis::CommImp::Numeric::Operator Type Name virtual LinearEqs Discretize (const ScalarField < real > & phiCellField, const ScalarField < real > & phiFaceField) virtual LinearEqs Discretize (const VectorField < real > & phiCellField, const VectorField < real > & phiFaceField) virtual LinearEqs Discretize (const TensorField < real > & phiCellField, const TensorField < real > & phiFaceField) virtual void SetBoundaryCondition (int faceIndex, const BoundaryCondition & boundary) virtual void SetCoefficient (const std::variant< real, Vector < real >, Tensor < real > > & coeff) virtual void SetCoefficient (const ScalarField < real > & coefficients) virtual void SetCoefficient (const VectorField < real > & coefficients) virtual void SetCoefficient (const TensorField < real > & coefficients) virtual ~Operator () = default Protected Attributes inherited from OpenOasis::CommImp::Numeric::Operator \u00b6 See OpenOasis::CommImp::Numeric::Operator Type Name std::optional< std::variant< real, Vector < real >, Tensor < real > > > mCoefficient std::optional< ScalarField < real > > mScalarCoeffs std::optional< TensorField < real > > mTensorCoeffs std::optional< VectorField < real > > mVectorCoeffs std::unordered_map< int, BoundaryCondition > mboundaries Detailed Description \u00b6 First, calculate the gradient of the scalar field. Then, calculate the divergence of the gradient. Public Functions Documentation \u00b6 function Discretize \u00b6 virtual LinearEqs OpenOasis :: CommImp :: Numeric :: Laplacian :: Discretize ( const ScalarField < real > & phiCellField , const ScalarField < real > & phiFaceField ) override Implements OpenOasis::CommImp::Numeric::Operator::Discretize function Laplacian \u00b6 inline OpenOasis :: CommImp :: Numeric :: Laplacian :: Laplacian ( const std :: shared_ptr < Grid > & grid ) function ~Laplacian \u00b6 virtual OpenOasis :: CommImp :: Numeric :: Laplacian ::~ Laplacian () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/LaplacianOperator.h","title":"Class OpenOasis::CommImp::Numeric::Laplacian"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_laplacian/#class-openoasiscommimpnumericlaplacian","text":"ClassList > OpenOasis > CommImp > Numeric > Laplacian Laplacian operator for the divergence of the gradient of a scalar field. More... #include <LaplacianOperator.h> Inherits the following classes: OpenOasis::CommImp::Numeric::Operator","title":"Class OpenOasis::CommImp::Numeric::Laplacian"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_laplacian/#public-functions","text":"Type Name virtual LinearEqs Discretize (const ScalarField < real > & phiCellField, const ScalarField < real > & phiFaceField) override Laplacian (const std::shared_ptr< Grid > & grid) virtual ~Laplacian () = default","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_laplacian/#public-functions-inherited-from-openoasiscommimpnumericoperator","text":"See OpenOasis::CommImp::Numeric::Operator Type Name virtual LinearEqs Discretize (const ScalarField < real > & phiCellField, const ScalarField < real > & phiFaceField) virtual LinearEqs Discretize (const VectorField < real > & phiCellField, const VectorField < real > & phiFaceField) virtual LinearEqs Discretize (const TensorField < real > & phiCellField, const TensorField < real > & phiFaceField) virtual void SetBoundaryCondition (int faceIndex, const BoundaryCondition & boundary) virtual void SetCoefficient (const std::variant< real, Vector < real >, Tensor < real > > & coeff) virtual void SetCoefficient (const ScalarField < real > & coefficients) virtual void SetCoefficient (const VectorField < real > & coefficients) virtual void SetCoefficient (const TensorField < real > & coefficients) virtual ~Operator () = default","title":"Public Functions inherited from OpenOasis::CommImp::Numeric::Operator"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_laplacian/#protected-attributes-inherited-from-openoasiscommimpnumericoperator","text":"See OpenOasis::CommImp::Numeric::Operator Type Name std::optional< std::variant< real, Vector < real >, Tensor < real > > > mCoefficient std::optional< ScalarField < real > > mScalarCoeffs std::optional< TensorField < real > > mTensorCoeffs std::optional< VectorField < real > > mVectorCoeffs std::unordered_map< int, BoundaryCondition > mboundaries","title":"Protected Attributes inherited from OpenOasis::CommImp::Numeric::Operator"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_laplacian/#detailed-description","text":"First, calculate the gradient of the scalar field. Then, calculate the divergence of the gradient.","title":"Detailed Description"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_laplacian/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_laplacian/#function-discretize","text":"virtual LinearEqs OpenOasis :: CommImp :: Numeric :: Laplacian :: Discretize ( const ScalarField < real > & phiCellField , const ScalarField < real > & phiFaceField ) override Implements OpenOasis::CommImp::Numeric::Operator::Discretize","title":"function Discretize"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_laplacian/#function-laplacian","text":"inline OpenOasis :: CommImp :: Numeric :: Laplacian :: Laplacian ( const std :: shared_ptr < Grid > & grid )","title":"function Laplacian"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_laplacian/#function-laplacian_1","text":"virtual OpenOasis :: CommImp :: Numeric :: Laplacian ::~ Laplacian () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/LaplacianOperator.h","title":"function ~Laplacian"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/","text":"Class OpenOasis::CommImp::Numeric::Matrix \u00b6 template <typename T> ClassList > OpenOasis > CommImp > Numeric > Matrix Public Functions \u00b6 Type Name void Add (std::size_t i, std::size_t j, const T & s) Add input scalar s to specified element. void Add (const Matrix & m) Adds input matrix m (element-wise). Matrix Adjoint () const Returns adjoint matrix. size_t Cols () const Eigen::SparseMatrix< T > & Data () const Eigen::SparseMatrix< T > & Data () const T Determinant () const Returns the determinant of this matrix. Vector < T, N > Diagonal () const Returns diagonal vector of this matrix. Matrix Invert () const Returns inverse matrix. Matrix (int rows, int cols) Matrix (int size) Matrix (const Matrix & other) Matrix (const std::initializer_list< std::initializer_list< T > > & lst) Matrix (const Eigen::SparseMatrix< T > & mat) T Max () const T Min () const void Mul (const T & s) Multiplies scalar s to the whole matrix. Matrix Mul (const Matrix & m) const Returns this matrix * input matrix m . size_t Rows () const void Set (const Matrix & other) void Set (const std::initializer_list< std::initializer_list< T > > & lst) void SetAt (size_t i, size_t j, const T & val) void SetCol (size_t j, const Vector < T, N > & vec) void SetDiagonal (const T & s) void SetRow (size_t i, const Vector < T, N > & vec) void SetUnit () void SetZero () void Sub (std::size_t i, std::size_t j, const T & s) Subtracts scalar s to specified element. void Sub (const Matrix & m) Subtracts input matrix m (element-wise). T Sum () const T Trace () const Returns the trace of this matrix. Matrix Transpose () const Returns transpose matrix. T & operator() (size_t i, size_t j) const T & operator() (size_t i, size_t j) const Matrix operator* (const Matrix & m) const Matrix operator* (const T & s) const Matrix & operator*= (const T & s) Matrix & operator*= (const Matrix & m) Matrix operator+ (const Matrix & m) const Matrix & operator+= (const Matrix & m) Matrix operator- (const Matrix & m) const Matrix & operator-= (const Matrix & m) Matrix & operator= (const Matrix & other) Public Static Functions \u00b6 Type Name Matrix Unit (int rows, int cols) Makes a sparse matrix with all diagonal elements to 1, and other elements to 0. Matrix Zero (int rows, int cols) Makes a sparse matrix with zeros. Public Functions Documentation \u00b6 function Add [\u00bd] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Matrix :: Add ( std :: size_t i , std :: size_t j , const T & s ) function Add [2/2] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Matrix :: Add ( const Matrix & m ) function Adjoint \u00b6 inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: Adjoint () const function Cols \u00b6 inline size_t OpenOasis :: CommImp :: Numeric :: Matrix :: Cols () const function Data [\u00bd] \u00b6 inline Eigen :: SparseMatrix < T > & OpenOasis :: CommImp :: Numeric :: Matrix :: Data () function Data [2/2] \u00b6 inline const Eigen :: SparseMatrix < T > & OpenOasis :: CommImp :: Numeric :: Matrix :: Data () const function Determinant \u00b6 Returns the determinant of this matrix. inline T OpenOasis :: CommImp :: Numeric :: Matrix :: Determinant () const Warning: Should be a square matrix. function Diagonal \u00b6 Returns diagonal vector of this matrix. template < std :: size_t N > inline Vector < T , N > OpenOasis :: CommImp :: Numeric :: Matrix :: Diagonal () const Warning: Should be a square matrix. function Invert \u00b6 inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: Invert () const function Matrix [\u2155] \u00b6 inline OpenOasis :: CommImp :: Numeric :: Matrix :: Matrix ( int rows , int cols ) function Matrix [\u2156] \u00b6 inline OpenOasis :: CommImp :: Numeric :: Matrix :: Matrix ( int size ) function Matrix [\u2157] \u00b6 inline OpenOasis :: CommImp :: Numeric :: Matrix :: Matrix ( const Matrix & other ) function Matrix [\u2158] \u00b6 inline OpenOasis :: CommImp :: Numeric :: Matrix :: Matrix ( const std :: initializer_list < std :: initializer_list < T > > & lst ) function Matrix [5/5] \u00b6 inline OpenOasis :: CommImp :: Numeric :: Matrix :: Matrix ( const Eigen :: SparseMatrix < T > & mat ) function Max \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Matrix :: Max () const function Min \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Matrix :: Min () const function Mul [\u00bd] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Matrix :: Mul ( const T & s ) function Mul [2/2] \u00b6 inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: Mul ( const Matrix & m ) const function Rows \u00b6 inline size_t OpenOasis :: CommImp :: Numeric :: Matrix :: Rows () const function Set [\u00bd] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Matrix :: Set ( const Matrix & other ) function Set [2/2] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Matrix :: Set ( const std :: initializer_list < std :: initializer_list < T > > & lst ) function SetAt \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Matrix :: SetAt ( size_t i , size_t j , const T & val ) function SetCol \u00b6 template < size_t N > inline void OpenOasis :: CommImp :: Numeric :: Matrix :: SetCol ( size_t j , const Vector < T , N > & vec ) function SetDiagonal \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Matrix :: SetDiagonal ( const T & s ) function SetRow \u00b6 template < size_t N > inline void OpenOasis :: CommImp :: Numeric :: Matrix :: SetRow ( size_t i , const Vector < T , N > & vec ) function SetUnit \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Matrix :: SetUnit () function SetZero \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Matrix :: SetZero () function Sub [\u00bd] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Matrix :: Sub ( std :: size_t i , std :: size_t j , const T & s ) function Sub [2/2] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Matrix :: Sub ( const Matrix & m ) function Sum \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Matrix :: Sum () const function Trace \u00b6 Returns the trace of this matrix. inline T OpenOasis :: CommImp :: Numeric :: Matrix :: Trace () const Warning: Should be a square matrix. function Transpose \u00b6 inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: Transpose () const function operator() [\u00bd] \u00b6 inline T & OpenOasis :: CommImp :: Numeric :: Matrix :: operator () ( size_t i , size_t j ) function operator() [2/2] \u00b6 inline const T & OpenOasis :: CommImp :: Numeric :: Matrix :: operator () ( size_t i , size_t j ) const function operator* \u00b6 inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: operator * ( const Matrix & m ) const function operator* \u00b6 inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: operator * ( const T & s ) const function operator*= \u00b6 inline Matrix & OpenOasis :: CommImp :: Numeric :: Matrix :: operator *= ( const T & s ) function operator*= \u00b6 inline Matrix & OpenOasis :: CommImp :: Numeric :: Matrix :: operator *= ( const Matrix & m ) function operator+ \u00b6 inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: operator + ( const Matrix & m ) const function operator+= \u00b6 inline Matrix & OpenOasis :: CommImp :: Numeric :: Matrix :: operator += ( const Matrix & m ) function operator- \u00b6 inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: operator - ( const Matrix & m ) const function operator-= \u00b6 inline Matrix & OpenOasis :: CommImp :: Numeric :: Matrix :: operator -= ( const Matrix & m ) function operator= \u00b6 inline Matrix & OpenOasis :: CommImp :: Numeric :: Matrix :: operator = ( const Matrix & other ) Public Static Functions Documentation \u00b6 function Unit \u00b6 static inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: Unit ( int rows , int cols ) function Zero \u00b6 static inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: Zero ( int rows , int cols ) The documentation for this class was generated from the following file Models/CommImp/Numeric/Matrix.h","title":"Class OpenOasis::CommImp::Numeric::Matrix"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#class-openoasiscommimpnumericmatrix","text":"template <typename T> ClassList > OpenOasis > CommImp > Numeric > Matrix","title":"Class OpenOasis::CommImp::Numeric::Matrix"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#public-functions","text":"Type Name void Add (std::size_t i, std::size_t j, const T & s) Add input scalar s to specified element. void Add (const Matrix & m) Adds input matrix m (element-wise). Matrix Adjoint () const Returns adjoint matrix. size_t Cols () const Eigen::SparseMatrix< T > & Data () const Eigen::SparseMatrix< T > & Data () const T Determinant () const Returns the determinant of this matrix. Vector < T, N > Diagonal () const Returns diagonal vector of this matrix. Matrix Invert () const Returns inverse matrix. Matrix (int rows, int cols) Matrix (int size) Matrix (const Matrix & other) Matrix (const std::initializer_list< std::initializer_list< T > > & lst) Matrix (const Eigen::SparseMatrix< T > & mat) T Max () const T Min () const void Mul (const T & s) Multiplies scalar s to the whole matrix. Matrix Mul (const Matrix & m) const Returns this matrix * input matrix m . size_t Rows () const void Set (const Matrix & other) void Set (const std::initializer_list< std::initializer_list< T > > & lst) void SetAt (size_t i, size_t j, const T & val) void SetCol (size_t j, const Vector < T, N > & vec) void SetDiagonal (const T & s) void SetRow (size_t i, const Vector < T, N > & vec) void SetUnit () void SetZero () void Sub (std::size_t i, std::size_t j, const T & s) Subtracts scalar s to specified element. void Sub (const Matrix & m) Subtracts input matrix m (element-wise). T Sum () const T Trace () const Returns the trace of this matrix. Matrix Transpose () const Returns transpose matrix. T & operator() (size_t i, size_t j) const T & operator() (size_t i, size_t j) const Matrix operator* (const Matrix & m) const Matrix operator* (const T & s) const Matrix & operator*= (const T & s) Matrix & operator*= (const Matrix & m) Matrix operator+ (const Matrix & m) const Matrix & operator+= (const Matrix & m) Matrix operator- (const Matrix & m) const Matrix & operator-= (const Matrix & m) Matrix & operator= (const Matrix & other)","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#public-static-functions","text":"Type Name Matrix Unit (int rows, int cols) Makes a sparse matrix with all diagonal elements to 1, and other elements to 0. Matrix Zero (int rows, int cols) Makes a sparse matrix with zeros.","title":"Public Static Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-add-12","text":"inline void OpenOasis :: CommImp :: Numeric :: Matrix :: Add ( std :: size_t i , std :: size_t j , const T & s )","title":"function Add [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-add-22","text":"inline void OpenOasis :: CommImp :: Numeric :: Matrix :: Add ( const Matrix & m )","title":"function Add [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-adjoint","text":"inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: Adjoint () const","title":"function Adjoint"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-cols","text":"inline size_t OpenOasis :: CommImp :: Numeric :: Matrix :: Cols () const","title":"function Cols"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-data-12","text":"inline Eigen :: SparseMatrix < T > & OpenOasis :: CommImp :: Numeric :: Matrix :: Data ()","title":"function Data [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-data-22","text":"inline const Eigen :: SparseMatrix < T > & OpenOasis :: CommImp :: Numeric :: Matrix :: Data () const","title":"function Data [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-determinant","text":"Returns the determinant of this matrix. inline T OpenOasis :: CommImp :: Numeric :: Matrix :: Determinant () const Warning: Should be a square matrix.","title":"function Determinant"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-diagonal","text":"Returns diagonal vector of this matrix. template < std :: size_t N > inline Vector < T , N > OpenOasis :: CommImp :: Numeric :: Matrix :: Diagonal () const Warning: Should be a square matrix.","title":"function Diagonal"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-invert","text":"inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: Invert () const","title":"function Invert"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-matrix-15","text":"inline OpenOasis :: CommImp :: Numeric :: Matrix :: Matrix ( int rows , int cols )","title":"function Matrix [&#8533;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-matrix-25","text":"inline OpenOasis :: CommImp :: Numeric :: Matrix :: Matrix ( int size )","title":"function Matrix [&#8534;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-matrix-35","text":"inline OpenOasis :: CommImp :: Numeric :: Matrix :: Matrix ( const Matrix & other )","title":"function Matrix [&#8535;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-matrix-45","text":"inline OpenOasis :: CommImp :: Numeric :: Matrix :: Matrix ( const std :: initializer_list < std :: initializer_list < T > > & lst )","title":"function Matrix [&#8536;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-matrix-55","text":"inline OpenOasis :: CommImp :: Numeric :: Matrix :: Matrix ( const Eigen :: SparseMatrix < T > & mat )","title":"function Matrix [5/5]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-max","text":"inline T OpenOasis :: CommImp :: Numeric :: Matrix :: Max () const","title":"function Max"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-min","text":"inline T OpenOasis :: CommImp :: Numeric :: Matrix :: Min () const","title":"function Min"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-mul-12","text":"inline void OpenOasis :: CommImp :: Numeric :: Matrix :: Mul ( const T & s )","title":"function Mul [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-mul-22","text":"inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: Mul ( const Matrix & m ) const","title":"function Mul [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-rows","text":"inline size_t OpenOasis :: CommImp :: Numeric :: Matrix :: Rows () const","title":"function Rows"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-set-12","text":"inline void OpenOasis :: CommImp :: Numeric :: Matrix :: Set ( const Matrix & other )","title":"function Set [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-set-22","text":"inline void OpenOasis :: CommImp :: Numeric :: Matrix :: Set ( const std :: initializer_list < std :: initializer_list < T > > & lst )","title":"function Set [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-setat","text":"inline void OpenOasis :: CommImp :: Numeric :: Matrix :: SetAt ( size_t i , size_t j , const T & val )","title":"function SetAt"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-setcol","text":"template < size_t N > inline void OpenOasis :: CommImp :: Numeric :: Matrix :: SetCol ( size_t j , const Vector < T , N > & vec )","title":"function SetCol"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-setdiagonal","text":"inline void OpenOasis :: CommImp :: Numeric :: Matrix :: SetDiagonal ( const T & s )","title":"function SetDiagonal"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-setrow","text":"template < size_t N > inline void OpenOasis :: CommImp :: Numeric :: Matrix :: SetRow ( size_t i , const Vector < T , N > & vec )","title":"function SetRow"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-setunit","text":"inline void OpenOasis :: CommImp :: Numeric :: Matrix :: SetUnit ()","title":"function SetUnit"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-setzero","text":"inline void OpenOasis :: CommImp :: Numeric :: Matrix :: SetZero ()","title":"function SetZero"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-sub-12","text":"inline void OpenOasis :: CommImp :: Numeric :: Matrix :: Sub ( std :: size_t i , std :: size_t j , const T & s )","title":"function Sub [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-sub-22","text":"inline void OpenOasis :: CommImp :: Numeric :: Matrix :: Sub ( const Matrix & m )","title":"function Sub [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-sum","text":"inline T OpenOasis :: CommImp :: Numeric :: Matrix :: Sum () const","title":"function Sum"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-trace","text":"Returns the trace of this matrix. inline T OpenOasis :: CommImp :: Numeric :: Matrix :: Trace () const Warning: Should be a square matrix.","title":"function Trace"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-transpose","text":"inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: Transpose () const","title":"function Transpose"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-operator-12","text":"inline T & OpenOasis :: CommImp :: Numeric :: Matrix :: operator () ( size_t i , size_t j )","title":"function operator() [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-operator-22","text":"inline const T & OpenOasis :: CommImp :: Numeric :: Matrix :: operator () ( size_t i , size_t j ) const","title":"function operator() [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-operator","text":"inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: operator * ( const Matrix & m ) const","title":"function operator*"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-operator_1","text":"inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: operator * ( const T & s ) const","title":"function operator*"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-operator_2","text":"inline Matrix & OpenOasis :: CommImp :: Numeric :: Matrix :: operator *= ( const T & s )","title":"function operator*="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-operator_3","text":"inline Matrix & OpenOasis :: CommImp :: Numeric :: Matrix :: operator *= ( const Matrix & m )","title":"function operator*="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-operator_4","text":"inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: operator + ( const Matrix & m ) const","title":"function operator+"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-operator_5","text":"inline Matrix & OpenOasis :: CommImp :: Numeric :: Matrix :: operator += ( const Matrix & m )","title":"function operator+="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-operator-","text":"inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: operator - ( const Matrix & m ) const","title":"function operator-"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-operator-_1","text":"inline Matrix & OpenOasis :: CommImp :: Numeric :: Matrix :: operator -= ( const Matrix & m )","title":"function operator-="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-operator_6","text":"inline Matrix & OpenOasis :: CommImp :: Numeric :: Matrix :: operator = ( const Matrix & other )","title":"function operator="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-unit","text":"static inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: Unit ( int rows , int cols )","title":"function Unit"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_matrix/#function-zero","text":"static inline Matrix OpenOasis :: CommImp :: Numeric :: Matrix :: Zero ( int rows , int cols ) The documentation for this class was generated from the following file Models/CommImp/Numeric/Matrix.h","title":"function Zero"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/","text":"Class OpenOasis::CommImp::Numeric::Operator \u00b6 ClassList > OpenOasis > CommImp > Numeric > Operator Abstract operator class. More... #include <Operator.h> Inherited by the following classes: OpenOasis::CommImp::Numeric::Laplacian Public Functions \u00b6 Type Name virtual LinearEqs Discretize (const ScalarField < real > & phiCellField, const ScalarField < real > & phiFaceField) virtual LinearEqs Discretize (const VectorField < real > & phiCellField, const VectorField < real > & phiFaceField) virtual LinearEqs Discretize (const TensorField < real > & phiCellField, const TensorField < real > & phiFaceField) virtual void SetBoundaryCondition (int faceIndex, const BoundaryCondition & boundary) virtual void SetCoefficient (const std::variant< real, Vector < real >, Tensor < real > > & coeff) virtual void SetCoefficient (const ScalarField < real > & coefficients) virtual void SetCoefficient (const VectorField < real > & coefficients) virtual void SetCoefficient (const TensorField < real > & coefficients) virtual ~Operator () = default Protected Attributes \u00b6 Type Name std::optional< std::variant< real, Vector < real >, Tensor < real > > > mCoefficient std::optional< ScalarField < real > > mScalarCoeffs std::optional< TensorField < real > > mTensorCoeffs std::optional< VectorField < real > > mVectorCoeffs std::unordered_map< int, BoundaryCondition > mboundaries Detailed Description \u00b6 Each numerical operator can discretize specific equation terms, or say carry out specific operations on field quantities, and return corresponding coefficient matrix and source term vector. Public Functions Documentation \u00b6 function Discretize [\u2153] \u00b6 inline virtual LinearEqs OpenOasis :: CommImp :: Numeric :: Operator :: Discretize ( const ScalarField < real > & phiCellField , const ScalarField < real > & phiFaceField ) function Discretize [\u2154] \u00b6 inline virtual LinearEqs OpenOasis :: CommImp :: Numeric :: Operator :: Discretize ( const VectorField < real > & phiCellField , const VectorField < real > & phiFaceField ) function Discretize [3/3] \u00b6 inline virtual LinearEqs OpenOasis :: CommImp :: Numeric :: Operator :: Discretize ( const TensorField < real > & phiCellField , const TensorField < real > & phiFaceField ) function SetBoundaryCondition \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Operator :: SetBoundaryCondition ( int faceIndex , const BoundaryCondition & boundary ) function SetCoefficient [\u00bc] \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Operator :: SetCoefficient ( const std :: variant < real , Vector < real > , Tensor < real > > & coeff ) function SetCoefficient [2/4] \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Operator :: SetCoefficient ( const ScalarField < real > & coefficients ) function SetCoefficient [\u00be] \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Operator :: SetCoefficient ( const VectorField < real > & coefficients ) function SetCoefficient [4/4] \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Operator :: SetCoefficient ( const TensorField < real > & coefficients ) function ~Operator \u00b6 virtual OpenOasis :: CommImp :: Numeric :: Operator ::~ Operator () = default Protected Attributes Documentation \u00b6 variable mCoefficient \u00b6 std :: optional < std :: variant < real , Vector < real > , Tensor < real > > > OpenOasis :: CommImp :: Numeric :: Operator :: mCoefficient ; variable mScalarCoeffs \u00b6 std :: optional < ScalarField < real > > OpenOasis :: CommImp :: Numeric :: Operator :: mScalarCoeffs ; variable mTensorCoeffs \u00b6 std :: optional < TensorField < real > > OpenOasis :: CommImp :: Numeric :: Operator :: mTensorCoeffs ; variable mVectorCoeffs \u00b6 std :: optional < VectorField < real > > OpenOasis :: CommImp :: Numeric :: Operator :: mVectorCoeffs ; variable mboundaries \u00b6 std :: unordered_map < int , BoundaryCondition > OpenOasis :: CommImp :: Numeric :: Operator :: mboundaries ; The documentation for this class was generated from the following file Models/CommImp/Numeric/Operator.h","title":"Class OpenOasis::CommImp::Numeric::Operator"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#class-openoasiscommimpnumericoperator","text":"ClassList > OpenOasis > CommImp > Numeric > Operator Abstract operator class. More... #include <Operator.h> Inherited by the following classes: OpenOasis::CommImp::Numeric::Laplacian","title":"Class OpenOasis::CommImp::Numeric::Operator"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#public-functions","text":"Type Name virtual LinearEqs Discretize (const ScalarField < real > & phiCellField, const ScalarField < real > & phiFaceField) virtual LinearEqs Discretize (const VectorField < real > & phiCellField, const VectorField < real > & phiFaceField) virtual LinearEqs Discretize (const TensorField < real > & phiCellField, const TensorField < real > & phiFaceField) virtual void SetBoundaryCondition (int faceIndex, const BoundaryCondition & boundary) virtual void SetCoefficient (const std::variant< real, Vector < real >, Tensor < real > > & coeff) virtual void SetCoefficient (const ScalarField < real > & coefficients) virtual void SetCoefficient (const VectorField < real > & coefficients) virtual void SetCoefficient (const TensorField < real > & coefficients) virtual ~Operator () = default","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#protected-attributes","text":"Type Name std::optional< std::variant< real, Vector < real >, Tensor < real > > > mCoefficient std::optional< ScalarField < real > > mScalarCoeffs std::optional< TensorField < real > > mTensorCoeffs std::optional< VectorField < real > > mVectorCoeffs std::unordered_map< int, BoundaryCondition > mboundaries","title":"Protected Attributes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#detailed-description","text":"Each numerical operator can discretize specific equation terms, or say carry out specific operations on field quantities, and return corresponding coefficient matrix and source term vector.","title":"Detailed Description"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#function-discretize-13","text":"inline virtual LinearEqs OpenOasis :: CommImp :: Numeric :: Operator :: Discretize ( const ScalarField < real > & phiCellField , const ScalarField < real > & phiFaceField )","title":"function Discretize [&#8531;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#function-discretize-23","text":"inline virtual LinearEqs OpenOasis :: CommImp :: Numeric :: Operator :: Discretize ( const VectorField < real > & phiCellField , const VectorField < real > & phiFaceField )","title":"function Discretize [&#8532;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#function-discretize-33","text":"inline virtual LinearEqs OpenOasis :: CommImp :: Numeric :: Operator :: Discretize ( const TensorField < real > & phiCellField , const TensorField < real > & phiFaceField )","title":"function Discretize [3/3]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#function-setboundarycondition","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Operator :: SetBoundaryCondition ( int faceIndex , const BoundaryCondition & boundary )","title":"function SetBoundaryCondition"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#function-setcoefficient-14","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Operator :: SetCoefficient ( const std :: variant < real , Vector < real > , Tensor < real > > & coeff )","title":"function SetCoefficient [&frac14;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#function-setcoefficient-24","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Operator :: SetCoefficient ( const ScalarField < real > & coefficients )","title":"function SetCoefficient [2/4]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#function-setcoefficient-34","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Operator :: SetCoefficient ( const VectorField < real > & coefficients )","title":"function SetCoefficient [&frac34;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#function-setcoefficient-44","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Operator :: SetCoefficient ( const TensorField < real > & coefficients )","title":"function SetCoefficient [4/4]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#function-operator","text":"virtual OpenOasis :: CommImp :: Numeric :: Operator ::~ Operator () = default","title":"function ~Operator"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#variable-mcoefficient","text":"std :: optional < std :: variant < real , Vector < real > , Tensor < real > > > OpenOasis :: CommImp :: Numeric :: Operator :: mCoefficient ;","title":"variable mCoefficient"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#variable-mscalarcoeffs","text":"std :: optional < ScalarField < real > > OpenOasis :: CommImp :: Numeric :: Operator :: mScalarCoeffs ;","title":"variable mScalarCoeffs"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#variable-mtensorcoeffs","text":"std :: optional < TensorField < real > > OpenOasis :: CommImp :: Numeric :: Operator :: mTensorCoeffs ;","title":"variable mTensorCoeffs"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#variable-mvectorcoeffs","text":"std :: optional < VectorField < real > > OpenOasis :: CommImp :: Numeric :: Operator :: mVectorCoeffs ;","title":"variable mVectorCoeffs"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_operator/#variable-mboundaries","text":"std :: unordered_map < int , BoundaryCondition > OpenOasis :: CommImp :: Numeric :: Operator :: mboundaries ; The documentation for this class was generated from the following file Models/CommImp/Numeric/Operator.h","title":"variable mboundaries"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_scalar_field/","text":"Class OpenOasis::CommImp::Numeric::ScalarField \u00b6 template <typename T> ClassList > OpenOasis > CommImp > Numeric > ScalarField Scaler field. #include <ScalarField.h> Inherits the following classes: OpenOasis::CommImp::Numeric::Field Public Functions \u00b6 Type Name ScalarField (std::size_t size, T val=0, FieldDomain domain=FieldDomain::CELL) ScalarField (FieldDomain domain=FieldDomain::CELL) virtual ~ScalarField () = default Public Functions inherited from OpenOasis::CommImp::Numeric::Field \u00b6 See OpenOasis::CommImp::Numeric::Field Type Name void Clean () Cleans the field data to the default value. void Clear () Clears the field. const std::vector< T > & Data () const Returns constant refrence to the field data. void ForEach (Callback func) Iterates the field and invoke given func for each element. void Initialize (T value) Initializes the vector field with specified value. FieldDomain Range () const void Resize (std::size_t size) Resizes the field. void SetAt (std::size_t i, T value) Sets the field data. void SetAt (std::size_t startIndex, std::size_t endIndex, const Field < T > & other, std::size_t offset=0) Sets the field data from the specified range. std::size_t Size () const Returns the field size. FieldType Type () const const T & operator() (int i) const T & operator() (int i) Field < T > operator* (double k) const void operator*= (double k) Field < T > operator+ (const Field < T > & other) const void operator+= (const Field < T > & other) Field < T > operator- (const Field < T > & other) const void operator-= (const Field < T > & other) void operator= (const Field < T > & other) void operator= (const T & value) Protected Attributes inherited from OpenOasis::CommImp::Numeric::Field \u00b6 See OpenOasis::CommImp::Numeric::Field Type Name std::vector< T > mData T mDefault FieldDomain mDomain = = FieldDomain::NONE FieldType mType = = FieldType::NONE Protected Functions inherited from OpenOasis::CommImp::Numeric::Field \u00b6 See OpenOasis::CommImp::Numeric::Field Type Name Field () = default Field (std::size_t size, T value) virtual ~Field () = default Public Functions Documentation \u00b6 function ScalarField [\u00bd] \u00b6 inline OpenOasis :: CommImp :: Numeric :: ScalarField :: ScalarField ( std :: size_t size , T val = 0 , FieldDomain domain = FieldDomain :: CELL ) function ScalarField [2/2] \u00b6 inline OpenOasis :: CommImp :: Numeric :: ScalarField :: ScalarField ( FieldDomain domain = FieldDomain :: CELL ) function ~ScalarField \u00b6 virtual OpenOasis :: CommImp :: Numeric :: ScalarField ::~ ScalarField () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/ScalarField.h","title":"Class OpenOasis::CommImp::Numeric::ScalarField"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_scalar_field/#class-openoasiscommimpnumericscalarfield","text":"template <typename T> ClassList > OpenOasis > CommImp > Numeric > ScalarField Scaler field. #include <ScalarField.h> Inherits the following classes: OpenOasis::CommImp::Numeric::Field","title":"Class OpenOasis::CommImp::Numeric::ScalarField"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_scalar_field/#public-functions","text":"Type Name ScalarField (std::size_t size, T val=0, FieldDomain domain=FieldDomain::CELL) ScalarField (FieldDomain domain=FieldDomain::CELL) virtual ~ScalarField () = default","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_scalar_field/#public-functions-inherited-from-openoasiscommimpnumericfield","text":"See OpenOasis::CommImp::Numeric::Field Type Name void Clean () Cleans the field data to the default value. void Clear () Clears the field. const std::vector< T > & Data () const Returns constant refrence to the field data. void ForEach (Callback func) Iterates the field and invoke given func for each element. void Initialize (T value) Initializes the vector field with specified value. FieldDomain Range () const void Resize (std::size_t size) Resizes the field. void SetAt (std::size_t i, T value) Sets the field data. void SetAt (std::size_t startIndex, std::size_t endIndex, const Field < T > & other, std::size_t offset=0) Sets the field data from the specified range. std::size_t Size () const Returns the field size. FieldType Type () const const T & operator() (int i) const T & operator() (int i) Field < T > operator* (double k) const void operator*= (double k) Field < T > operator+ (const Field < T > & other) const void operator+= (const Field < T > & other) Field < T > operator- (const Field < T > & other) const void operator-= (const Field < T > & other) void operator= (const Field < T > & other) void operator= (const T & value)","title":"Public Functions inherited from OpenOasis::CommImp::Numeric::Field"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_scalar_field/#protected-attributes-inherited-from-openoasiscommimpnumericfield","text":"See OpenOasis::CommImp::Numeric::Field Type Name std::vector< T > mData T mDefault FieldDomain mDomain = = FieldDomain::NONE FieldType mType = = FieldType::NONE","title":"Protected Attributes inherited from OpenOasis::CommImp::Numeric::Field"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_scalar_field/#protected-functions-inherited-from-openoasiscommimpnumericfield","text":"See OpenOasis::CommImp::Numeric::Field Type Name Field () = default Field (std::size_t size, T value) virtual ~Field () = default","title":"Protected Functions inherited from OpenOasis::CommImp::Numeric::Field"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_scalar_field/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_scalar_field/#function-scalarfield-12","text":"inline OpenOasis :: CommImp :: Numeric :: ScalarField :: ScalarField ( std :: size_t size , T val = 0 , FieldDomain domain = FieldDomain :: CELL )","title":"function ScalarField [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_scalar_field/#function-scalarfield-22","text":"inline OpenOasis :: CommImp :: Numeric :: ScalarField :: ScalarField ( FieldDomain domain = FieldDomain :: CELL )","title":"function ScalarField [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_scalar_field/#function-scalarfield","text":"virtual OpenOasis :: CommImp :: Numeric :: ScalarField ::~ ScalarField () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/ScalarField.h","title":"function ~ScalarField"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/","text":"Class OpenOasis::CommImp::Numeric::Solver \u00b6 ClassList > OpenOasis > CommImp > Numeric > Solver Abstract solver class. #include <Solver.h> Inherited by the following classes: OpenOasis::CommImp::Numeric::FVM::FvmSolver Public Functions \u00b6 Type Name virtual void AfterScheme () virtual void AfterSolve () virtual void BeforeScheme () virtual void BeforeSolve () std::optional< LinearEqs > GetLinearEqs () const virtual std::optional< ScalarFieldFp > GetScalarSolutions (const std::string & var) const virtual std::optional< TensorFieldFp > GetTensorSolutions (const std::string & var) const virtual std::optional< VectorFieldFp > GetVectorSolutions (const std::string & var) const virtual void ParseConvectionTerm () virtual void ParseDiffusionTerm () virtual void ParseSourceTerm () virtual void ParseTimeDerivativeTerm () virtual void Scheme () virtual void SetBoundary (int faceIndex, const std::shared_ptr< Boundary > & bound) virtual void SetCoefficient (const std::string & var, const std::variant< real, Vector < real >, Tensor < real > > & coeff) virtual void SetCoefficient (const std::string & var, const ScalarFieldFp & coeffs) virtual void SetCoefficient (const std::string & var, const VectorFieldFp & coeffs) virtual void SetCoefficient (const std::string & var, const TensorFieldFp & coeffs) virtual void SetInitialValue (const std::string & var, const std::variant< real, Vector < real >, Tensor < real > > & value) virtual void SetInitialValue (const std::string & var, const ScalarFieldFp & values) virtual void SetInitialValue (const std::string & var, const VectorFieldFp & values) virtual void SetInitialValue (const std::string & var, const TensorFieldFp & values) virtual void Solve () Public Functions Documentation \u00b6 function AfterScheme \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: AfterScheme () function AfterSolve \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: AfterSolve () function BeforeScheme \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: BeforeScheme () function BeforeSolve \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: BeforeSolve () function GetLinearEqs \u00b6 inline std :: optional < LinearEqs > OpenOasis :: CommImp :: Numeric :: Solver :: GetLinearEqs () const function GetScalarSolutions \u00b6 inline virtual std :: optional < ScalarFieldFp > OpenOasis :: CommImp :: Numeric :: Solver :: GetScalarSolutions ( const std :: string & var ) const function GetTensorSolutions \u00b6 inline virtual std :: optional < TensorFieldFp > OpenOasis :: CommImp :: Numeric :: Solver :: GetTensorSolutions ( const std :: string & var ) const function GetVectorSolutions \u00b6 inline virtual std :: optional < VectorFieldFp > OpenOasis :: CommImp :: Numeric :: Solver :: GetVectorSolutions ( const std :: string & var ) const function ParseConvectionTerm \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: ParseConvectionTerm () function ParseDiffusionTerm \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: ParseDiffusionTerm () function ParseSourceTerm \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: ParseSourceTerm () function ParseTimeDerivativeTerm \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: ParseTimeDerivativeTerm () function Scheme \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: Scheme () function SetBoundary \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetBoundary ( int faceIndex , const std :: shared_ptr < Boundary > & bound ) function SetCoefficient [\u00bc] \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetCoefficient ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real > > & coeff ) function SetCoefficient [2/4] \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetCoefficient ( const std :: string & var , const ScalarFieldFp & coeffs ) function SetCoefficient [\u00be] \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetCoefficient ( const std :: string & var , const VectorFieldFp & coeffs ) function SetCoefficient [4/4] \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetCoefficient ( const std :: string & var , const TensorFieldFp & coeffs ) function SetInitialValue [\u00bc] \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetInitialValue ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real > > & value ) function SetInitialValue [2/4] \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetInitialValue ( const std :: string & var , const ScalarFieldFp & values ) function SetInitialValue [\u00be] \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetInitialValue ( const std :: string & var , const VectorFieldFp & values ) function SetInitialValue [4/4] \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetInitialValue ( const std :: string & var , const TensorFieldFp & values ) function Solve \u00b6 inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: Solve () The documentation for this class was generated from the following file Models/CommImp/Numeric/Solver.h","title":"Class OpenOasis::CommImp::Numeric::Solver"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#class-openoasiscommimpnumericsolver","text":"ClassList > OpenOasis > CommImp > Numeric > Solver Abstract solver class. #include <Solver.h> Inherited by the following classes: OpenOasis::CommImp::Numeric::FVM::FvmSolver","title":"Class OpenOasis::CommImp::Numeric::Solver"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#public-functions","text":"Type Name virtual void AfterScheme () virtual void AfterSolve () virtual void BeforeScheme () virtual void BeforeSolve () std::optional< LinearEqs > GetLinearEqs () const virtual std::optional< ScalarFieldFp > GetScalarSolutions (const std::string & var) const virtual std::optional< TensorFieldFp > GetTensorSolutions (const std::string & var) const virtual std::optional< VectorFieldFp > GetVectorSolutions (const std::string & var) const virtual void ParseConvectionTerm () virtual void ParseDiffusionTerm () virtual void ParseSourceTerm () virtual void ParseTimeDerivativeTerm () virtual void Scheme () virtual void SetBoundary (int faceIndex, const std::shared_ptr< Boundary > & bound) virtual void SetCoefficient (const std::string & var, const std::variant< real, Vector < real >, Tensor < real > > & coeff) virtual void SetCoefficient (const std::string & var, const ScalarFieldFp & coeffs) virtual void SetCoefficient (const std::string & var, const VectorFieldFp & coeffs) virtual void SetCoefficient (const std::string & var, const TensorFieldFp & coeffs) virtual void SetInitialValue (const std::string & var, const std::variant< real, Vector < real >, Tensor < real > > & value) virtual void SetInitialValue (const std::string & var, const ScalarFieldFp & values) virtual void SetInitialValue (const std::string & var, const VectorFieldFp & values) virtual void SetInitialValue (const std::string & var, const TensorFieldFp & values) virtual void Solve ()","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-afterscheme","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: AfterScheme ()","title":"function AfterScheme"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-aftersolve","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: AfterSolve ()","title":"function AfterSolve"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-beforescheme","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: BeforeScheme ()","title":"function BeforeScheme"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-beforesolve","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: BeforeSolve ()","title":"function BeforeSolve"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-getlineareqs","text":"inline std :: optional < LinearEqs > OpenOasis :: CommImp :: Numeric :: Solver :: GetLinearEqs () const","title":"function GetLinearEqs"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-getscalarsolutions","text":"inline virtual std :: optional < ScalarFieldFp > OpenOasis :: CommImp :: Numeric :: Solver :: GetScalarSolutions ( const std :: string & var ) const","title":"function GetScalarSolutions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-gettensorsolutions","text":"inline virtual std :: optional < TensorFieldFp > OpenOasis :: CommImp :: Numeric :: Solver :: GetTensorSolutions ( const std :: string & var ) const","title":"function GetTensorSolutions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-getvectorsolutions","text":"inline virtual std :: optional < VectorFieldFp > OpenOasis :: CommImp :: Numeric :: Solver :: GetVectorSolutions ( const std :: string & var ) const","title":"function GetVectorSolutions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-parseconvectionterm","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: ParseConvectionTerm ()","title":"function ParseConvectionTerm"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-parsediffusionterm","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: ParseDiffusionTerm ()","title":"function ParseDiffusionTerm"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-parsesourceterm","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: ParseSourceTerm ()","title":"function ParseSourceTerm"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-parsetimederivativeterm","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: ParseTimeDerivativeTerm ()","title":"function ParseTimeDerivativeTerm"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-scheme","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: Scheme ()","title":"function Scheme"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-setboundary","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetBoundary ( int faceIndex , const std :: shared_ptr < Boundary > & bound )","title":"function SetBoundary"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-setcoefficient-14","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetCoefficient ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real > > & coeff )","title":"function SetCoefficient [&frac14;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-setcoefficient-24","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetCoefficient ( const std :: string & var , const ScalarFieldFp & coeffs )","title":"function SetCoefficient [2/4]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-setcoefficient-34","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetCoefficient ( const std :: string & var , const VectorFieldFp & coeffs )","title":"function SetCoefficient [&frac34;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-setcoefficient-44","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetCoefficient ( const std :: string & var , const TensorFieldFp & coeffs )","title":"function SetCoefficient [4/4]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-setinitialvalue-14","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetInitialValue ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real > > & value )","title":"function SetInitialValue [&frac14;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-setinitialvalue-24","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetInitialValue ( const std :: string & var , const ScalarFieldFp & values )","title":"function SetInitialValue [2/4]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-setinitialvalue-34","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetInitialValue ( const std :: string & var , const VectorFieldFp & values )","title":"function SetInitialValue [&frac34;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-setinitialvalue-44","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: SetInitialValue ( const std :: string & var , const TensorFieldFp & values )","title":"function SetInitialValue [4/4]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_solver/#function-solve","text":"inline virtual void OpenOasis :: CommImp :: Numeric :: Solver :: Solve () The documentation for this class was generated from the following file Models/CommImp/Numeric/Solver.h","title":"function Solve"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_source/","text":"Class OpenOasis::CommImp::Numeric::Source \u00b6 ClassList > OpenOasis > CommImp > Numeric > Source Public Functions \u00b6 Type Name virtual std::vector< double > GetSource () = 0 Public Functions Documentation \u00b6 function GetSource \u00b6 virtual std :: vector < double > OpenOasis :: CommImp :: Numeric :: Source :: GetSource () = 0 The documentation for this class was generated from the following file Models/CommImp/Numeric/Source.h","title":"Class OpenOasis::CommImp::Numeric::Source"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_source/#class-openoasiscommimpnumericsource","text":"ClassList > OpenOasis > CommImp > Numeric > Source","title":"Class OpenOasis::CommImp::Numeric::Source"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_source/#public-functions","text":"Type Name virtual std::vector< double > GetSource () = 0","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_source/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_source/#function-getsource","text":"virtual std :: vector < double > OpenOasis :: CommImp :: Numeric :: Source :: GetSource () = 0 The documentation for this class was generated from the following file Models/CommImp/Numeric/Source.h","title":"function GetSource"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/","text":"Class OpenOasis::CommImp::Numeric::Tensor \u00b6 template <typename T> ClassList > OpenOasis > CommImp > Numeric > Tensor Public Functions \u00b6 Type Name T AbsMax () const Return the component of the tensor hasing the maximum absolute value. T AbsMin () const Return the component of the tensor hasing the minimum absolute value. void Add (T v) void Add (const Tensor & other) T Avg () const T DDot (const Tensor & other) const void Div (T v) Vector < T, 3 > Dot (const Vector < T, 3 > & other) const bool IsEqual (const Tensor & other) const T Length () const Return the tensor's length(magnitude). T Max () const T Min () const void Mul (T v) void Normalize () void Set (const Tensor & other) void Set (const std::initializer_list< U > & lst) void SetAt (std::size_t i, T v, Args... args) void SetAt (std::size_t i, T v) void SetAt (std::size_t i, std::size_t j, T v) void SetAt (std::size_t i, const Vector < T, 3 > & vec) constexpr std::size_t Size () const void Sub (T v) void Sub (const Tensor & other) T Sum () const Tensor () Tensor (const Tensor & other) Tensor (Args... args) Tensor (const std::initializer_list< U > & lst) T & operator() (std::size_t i, std::size_t j) const T & operator() (std::size_t i, std::size_t j) const Vector < T, 3 > operator* (const Vector < T, 3 > & other) const T operator* (const Tensor & other) const Tensor operator+ (const Tensor & other) const Tensor operator+ (T v) const Tensor & operator+= (const Tensor & other) Tensor & operator+= (T v) Tensor operator- (const Tensor & other) const Tensor operator- (T v) const Tensor & operator-= (const Tensor & other) Tensor & operator-= (T v) void operator= (const Tensor & other) Public Functions Documentation \u00b6 function AbsMax \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Tensor :: AbsMax () const function AbsMin \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Tensor :: AbsMin () const function Add [\u00bd] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Add ( T v ) function Add [2/2] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Add ( const Tensor & other ) function Avg \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Tensor :: Avg () const function DDot \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Tensor :: DDot ( const Tensor & other ) const function Div \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Div ( T v ) function Dot \u00b6 inline Vector < T , 3 > OpenOasis :: CommImp :: Numeric :: Tensor :: Dot ( const Vector < T , 3 > & other ) const function IsEqual \u00b6 inline bool OpenOasis :: CommImp :: Numeric :: Tensor :: IsEqual ( const Tensor & other ) const function Length \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Tensor :: Length () const function Max \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Tensor :: Max () const function Min \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Tensor :: Min () const function Mul \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Mul ( T v ) function Normalize \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Normalize () function Set [\u00bd] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Set ( const Tensor & other ) function Set [2/2] \u00b6 template < typename U > inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Set ( const std :: initializer_list < U > & lst ) function SetAt [\u00bc] \u00b6 template < typename ... Args > inline void OpenOasis :: CommImp :: Numeric :: Tensor :: SetAt ( std :: size_t i , T v , Args ... args ) function SetAt [2/4] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Tensor :: SetAt ( std :: size_t i , T v ) function SetAt [\u00be] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Tensor :: SetAt ( std :: size_t i , std :: size_t j , T v ) function SetAt [4/4] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Tensor :: SetAt ( std :: size_t i , const Vector < T , 3 > & vec ) function Size \u00b6 inline constexpr std :: size_t OpenOasis :: CommImp :: Numeric :: Tensor :: Size () const function Sub [\u00bd] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Sub ( T v ) function Sub [2/2] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Sub ( const Tensor & other ) function Sum \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Tensor :: Sum () const function Tensor [\u00bc] \u00b6 inline OpenOasis :: CommImp :: Numeric :: Tensor :: Tensor () function Tensor [2/4] \u00b6 inline OpenOasis :: CommImp :: Numeric :: Tensor :: Tensor ( const Tensor & other ) function Tensor [\u00be] \u00b6 template < typename ... Args > inline OpenOasis :: CommImp :: Numeric :: Tensor :: Tensor ( Args ... args ) function Tensor [4/4] \u00b6 template < typename U > inline OpenOasis :: CommImp :: Numeric :: Tensor :: Tensor ( const std :: initializer_list < U > & lst ) function operator() [\u00bd] \u00b6 inline T & OpenOasis :: CommImp :: Numeric :: Tensor :: operator () ( std :: size_t i , std :: size_t j ) function operator() [2/2] \u00b6 inline const T & OpenOasis :: CommImp :: Numeric :: Tensor :: operator () ( std :: size_t i , std :: size_t j ) const function operator* \u00b6 inline Vector < T , 3 > OpenOasis :: CommImp :: Numeric :: Tensor :: operator * ( const Vector < T , 3 > & other ) const function operator* \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Tensor :: operator * ( const Tensor & other ) const function operator+ \u00b6 inline Tensor OpenOasis :: CommImp :: Numeric :: Tensor :: operator + ( const Tensor & other ) const function operator+ \u00b6 inline Tensor OpenOasis :: CommImp :: Numeric :: Tensor :: operator + ( T v ) const function operator+= \u00b6 inline Tensor & OpenOasis :: CommImp :: Numeric :: Tensor :: operator += ( const Tensor & other ) function operator+= \u00b6 inline Tensor & OpenOasis :: CommImp :: Numeric :: Tensor :: operator += ( T v ) function operator- \u00b6 inline Tensor OpenOasis :: CommImp :: Numeric :: Tensor :: operator - ( const Tensor & other ) const function operator- \u00b6 inline Tensor OpenOasis :: CommImp :: Numeric :: Tensor :: operator - ( T v ) const function operator-= \u00b6 inline Tensor & OpenOasis :: CommImp :: Numeric :: Tensor :: operator -= ( const Tensor & other ) function operator-= \u00b6 inline Tensor & OpenOasis :: CommImp :: Numeric :: Tensor :: operator -= ( T v ) function operator= \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Tensor :: operator = ( const Tensor & other ) The documentation for this class was generated from the following file Models/CommImp/Numeric/Tensor.h","title":"Class OpenOasis::CommImp::Numeric::Tensor"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#class-openoasiscommimpnumerictensor","text":"template <typename T> ClassList > OpenOasis > CommImp > Numeric > Tensor","title":"Class OpenOasis::CommImp::Numeric::Tensor"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#public-functions","text":"Type Name T AbsMax () const Return the component of the tensor hasing the maximum absolute value. T AbsMin () const Return the component of the tensor hasing the minimum absolute value. void Add (T v) void Add (const Tensor & other) T Avg () const T DDot (const Tensor & other) const void Div (T v) Vector < T, 3 > Dot (const Vector < T, 3 > & other) const bool IsEqual (const Tensor & other) const T Length () const Return the tensor's length(magnitude). T Max () const T Min () const void Mul (T v) void Normalize () void Set (const Tensor & other) void Set (const std::initializer_list< U > & lst) void SetAt (std::size_t i, T v, Args... args) void SetAt (std::size_t i, T v) void SetAt (std::size_t i, std::size_t j, T v) void SetAt (std::size_t i, const Vector < T, 3 > & vec) constexpr std::size_t Size () const void Sub (T v) void Sub (const Tensor & other) T Sum () const Tensor () Tensor (const Tensor & other) Tensor (Args... args) Tensor (const std::initializer_list< U > & lst) T & operator() (std::size_t i, std::size_t j) const T & operator() (std::size_t i, std::size_t j) const Vector < T, 3 > operator* (const Vector < T, 3 > & other) const T operator* (const Tensor & other) const Tensor operator+ (const Tensor & other) const Tensor operator+ (T v) const Tensor & operator+= (const Tensor & other) Tensor & operator+= (T v) Tensor operator- (const Tensor & other) const Tensor operator- (T v) const Tensor & operator-= (const Tensor & other) Tensor & operator-= (T v) void operator= (const Tensor & other)","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-absmax","text":"inline T OpenOasis :: CommImp :: Numeric :: Tensor :: AbsMax () const","title":"function AbsMax"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-absmin","text":"inline T OpenOasis :: CommImp :: Numeric :: Tensor :: AbsMin () const","title":"function AbsMin"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-add-12","text":"inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Add ( T v )","title":"function Add [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-add-22","text":"inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Add ( const Tensor & other )","title":"function Add [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-avg","text":"inline T OpenOasis :: CommImp :: Numeric :: Tensor :: Avg () const","title":"function Avg"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-ddot","text":"inline T OpenOasis :: CommImp :: Numeric :: Tensor :: DDot ( const Tensor & other ) const","title":"function DDot"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-div","text":"inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Div ( T v )","title":"function Div"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-dot","text":"inline Vector < T , 3 > OpenOasis :: CommImp :: Numeric :: Tensor :: Dot ( const Vector < T , 3 > & other ) const","title":"function Dot"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-isequal","text":"inline bool OpenOasis :: CommImp :: Numeric :: Tensor :: IsEqual ( const Tensor & other ) const","title":"function IsEqual"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-length","text":"inline T OpenOasis :: CommImp :: Numeric :: Tensor :: Length () const","title":"function Length"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-max","text":"inline T OpenOasis :: CommImp :: Numeric :: Tensor :: Max () const","title":"function Max"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-min","text":"inline T OpenOasis :: CommImp :: Numeric :: Tensor :: Min () const","title":"function Min"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-mul","text":"inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Mul ( T v )","title":"function Mul"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-normalize","text":"inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Normalize ()","title":"function Normalize"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-set-12","text":"inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Set ( const Tensor & other )","title":"function Set [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-set-22","text":"template < typename U > inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Set ( const std :: initializer_list < U > & lst )","title":"function Set [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-setat-14","text":"template < typename ... Args > inline void OpenOasis :: CommImp :: Numeric :: Tensor :: SetAt ( std :: size_t i , T v , Args ... args )","title":"function SetAt [&frac14;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-setat-24","text":"inline void OpenOasis :: CommImp :: Numeric :: Tensor :: SetAt ( std :: size_t i , T v )","title":"function SetAt [2/4]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-setat-34","text":"inline void OpenOasis :: CommImp :: Numeric :: Tensor :: SetAt ( std :: size_t i , std :: size_t j , T v )","title":"function SetAt [&frac34;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-setat-44","text":"inline void OpenOasis :: CommImp :: Numeric :: Tensor :: SetAt ( std :: size_t i , const Vector < T , 3 > & vec )","title":"function SetAt [4/4]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-size","text":"inline constexpr std :: size_t OpenOasis :: CommImp :: Numeric :: Tensor :: Size () const","title":"function Size"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-sub-12","text":"inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Sub ( T v )","title":"function Sub [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-sub-22","text":"inline void OpenOasis :: CommImp :: Numeric :: Tensor :: Sub ( const Tensor & other )","title":"function Sub [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-sum","text":"inline T OpenOasis :: CommImp :: Numeric :: Tensor :: Sum () const","title":"function Sum"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-tensor-14","text":"inline OpenOasis :: CommImp :: Numeric :: Tensor :: Tensor ()","title":"function Tensor [&frac14;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-tensor-24","text":"inline OpenOasis :: CommImp :: Numeric :: Tensor :: Tensor ( const Tensor & other )","title":"function Tensor [2/4]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-tensor-34","text":"template < typename ... Args > inline OpenOasis :: CommImp :: Numeric :: Tensor :: Tensor ( Args ... args )","title":"function Tensor [&frac34;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-tensor-44","text":"template < typename U > inline OpenOasis :: CommImp :: Numeric :: Tensor :: Tensor ( const std :: initializer_list < U > & lst )","title":"function Tensor [4/4]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-operator-12","text":"inline T & OpenOasis :: CommImp :: Numeric :: Tensor :: operator () ( std :: size_t i , std :: size_t j )","title":"function operator() [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-operator-22","text":"inline const T & OpenOasis :: CommImp :: Numeric :: Tensor :: operator () ( std :: size_t i , std :: size_t j ) const","title":"function operator() [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-operator","text":"inline Vector < T , 3 > OpenOasis :: CommImp :: Numeric :: Tensor :: operator * ( const Vector < T , 3 > & other ) const","title":"function operator*"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-operator_1","text":"inline T OpenOasis :: CommImp :: Numeric :: Tensor :: operator * ( const Tensor & other ) const","title":"function operator*"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-operator_2","text":"inline Tensor OpenOasis :: CommImp :: Numeric :: Tensor :: operator + ( const Tensor & other ) const","title":"function operator+"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-operator_3","text":"inline Tensor OpenOasis :: CommImp :: Numeric :: Tensor :: operator + ( T v ) const","title":"function operator+"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-operator_4","text":"inline Tensor & OpenOasis :: CommImp :: Numeric :: Tensor :: operator += ( const Tensor & other )","title":"function operator+="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-operator_5","text":"inline Tensor & OpenOasis :: CommImp :: Numeric :: Tensor :: operator += ( T v )","title":"function operator+="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-operator-","text":"inline Tensor OpenOasis :: CommImp :: Numeric :: Tensor :: operator - ( const Tensor & other ) const","title":"function operator-"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-operator-_1","text":"inline Tensor OpenOasis :: CommImp :: Numeric :: Tensor :: operator - ( T v ) const","title":"function operator-"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-operator-_2","text":"inline Tensor & OpenOasis :: CommImp :: Numeric :: Tensor :: operator -= ( const Tensor & other )","title":"function operator-="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-operator-_3","text":"inline Tensor & OpenOasis :: CommImp :: Numeric :: Tensor :: operator -= ( T v )","title":"function operator-="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor/#function-operator_6","text":"inline void OpenOasis :: CommImp :: Numeric :: Tensor :: operator = ( const Tensor & other ) The documentation for this class was generated from the following file Models/CommImp/Numeric/Tensor.h","title":"function operator="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor_field/","text":"Class OpenOasis::CommImp::Numeric::TensorField \u00b6 template <typename T> ClassList > OpenOasis > CommImp > Numeric > TensorField Tensor field. #include <TensorField.h> Inherits the following classes: OpenOasis::CommImp::Numeric::Field Public Functions \u00b6 Type Name TensorField (FieldDomain domain=FieldDomain::CELL) TensorField (std::size_t size, const Tensor < T > & val={}, FieldDomain domain=FieldDomain::CELL) virtual ~TensorField () = default Public Functions inherited from OpenOasis::CommImp::Numeric::Field \u00b6 See OpenOasis::CommImp::Numeric::Field Type Name void Clean () Cleans the field data to the default value. void Clear () Clears the field. const std::vector< T > & Data () const Returns constant refrence to the field data. void ForEach (Callback func) Iterates the field and invoke given func for each element. void Initialize (T value) Initializes the vector field with specified value. FieldDomain Range () const void Resize (std::size_t size) Resizes the field. void SetAt (std::size_t i, T value) Sets the field data. void SetAt (std::size_t startIndex, std::size_t endIndex, const Field < T > & other, std::size_t offset=0) Sets the field data from the specified range. std::size_t Size () const Returns the field size. FieldType Type () const const T & operator() (int i) const T & operator() (int i) Field < T > operator* (double k) const void operator*= (double k) Field < T > operator+ (const Field < T > & other) const void operator+= (const Field < T > & other) Field < T > operator- (const Field < T > & other) const void operator-= (const Field < T > & other) void operator= (const Field < T > & other) void operator= (const T & value) Protected Attributes inherited from OpenOasis::CommImp::Numeric::Field \u00b6 See OpenOasis::CommImp::Numeric::Field Type Name std::vector< T > mData T mDefault FieldDomain mDomain = = FieldDomain::NONE FieldType mType = = FieldType::NONE Protected Functions inherited from OpenOasis::CommImp::Numeric::Field \u00b6 See OpenOasis::CommImp::Numeric::Field Type Name Field () = default Field (std::size_t size, T value) virtual ~Field () = default Public Functions Documentation \u00b6 function TensorField [\u00bd] \u00b6 inline OpenOasis :: CommImp :: Numeric :: TensorField :: TensorField ( FieldDomain domain = FieldDomain :: CELL ) function TensorField [2/2] \u00b6 inline OpenOasis :: CommImp :: Numeric :: TensorField :: TensorField ( std :: size_t size , const Tensor < T > & val = {}, FieldDomain domain = FieldDomain :: CELL ) function ~TensorField \u00b6 virtual OpenOasis :: CommImp :: Numeric :: TensorField ::~ TensorField () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/TensorField.h","title":"Class OpenOasis::CommImp::Numeric::TensorField"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor_field/#class-openoasiscommimpnumerictensorfield","text":"template <typename T> ClassList > OpenOasis > CommImp > Numeric > TensorField Tensor field. #include <TensorField.h> Inherits the following classes: OpenOasis::CommImp::Numeric::Field","title":"Class OpenOasis::CommImp::Numeric::TensorField"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor_field/#public-functions","text":"Type Name TensorField (FieldDomain domain=FieldDomain::CELL) TensorField (std::size_t size, const Tensor < T > & val={}, FieldDomain domain=FieldDomain::CELL) virtual ~TensorField () = default","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor_field/#public-functions-inherited-from-openoasiscommimpnumericfield","text":"See OpenOasis::CommImp::Numeric::Field Type Name void Clean () Cleans the field data to the default value. void Clear () Clears the field. const std::vector< T > & Data () const Returns constant refrence to the field data. void ForEach (Callback func) Iterates the field and invoke given func for each element. void Initialize (T value) Initializes the vector field with specified value. FieldDomain Range () const void Resize (std::size_t size) Resizes the field. void SetAt (std::size_t i, T value) Sets the field data. void SetAt (std::size_t startIndex, std::size_t endIndex, const Field < T > & other, std::size_t offset=0) Sets the field data from the specified range. std::size_t Size () const Returns the field size. FieldType Type () const const T & operator() (int i) const T & operator() (int i) Field < T > operator* (double k) const void operator*= (double k) Field < T > operator+ (const Field < T > & other) const void operator+= (const Field < T > & other) Field < T > operator- (const Field < T > & other) const void operator-= (const Field < T > & other) void operator= (const Field < T > & other) void operator= (const T & value)","title":"Public Functions inherited from OpenOasis::CommImp::Numeric::Field"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor_field/#protected-attributes-inherited-from-openoasiscommimpnumericfield","text":"See OpenOasis::CommImp::Numeric::Field Type Name std::vector< T > mData T mDefault FieldDomain mDomain = = FieldDomain::NONE FieldType mType = = FieldType::NONE","title":"Protected Attributes inherited from OpenOasis::CommImp::Numeric::Field"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor_field/#protected-functions-inherited-from-openoasiscommimpnumericfield","text":"See OpenOasis::CommImp::Numeric::Field Type Name Field () = default Field (std::size_t size, T value) virtual ~Field () = default","title":"Protected Functions inherited from OpenOasis::CommImp::Numeric::Field"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor_field/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor_field/#function-tensorfield-12","text":"inline OpenOasis :: CommImp :: Numeric :: TensorField :: TensorField ( FieldDomain domain = FieldDomain :: CELL )","title":"function TensorField [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor_field/#function-tensorfield-22","text":"inline OpenOasis :: CommImp :: Numeric :: TensorField :: TensorField ( std :: size_t size , const Tensor < T > & val = {}, FieldDomain domain = FieldDomain :: CELL )","title":"function TensorField [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_tensor_field/#function-tensorfield","text":"virtual OpenOasis :: CommImp :: Numeric :: TensorField ::~ TensorField () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/TensorField.h","title":"function ~TensorField"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/","text":"Class OpenOasis::CommImp::Numeric::Vector \u00b6 template <typename T, size_t N> ClassList > OpenOasis > CommImp > Numeric > Vector Public Functions \u00b6 Type Name T AbsMax () const Return the component of the vector hasing the maximum absolute value. T AbsMin () const Return the component of the vector hasing the minimum absolute value. void Add (T v) void Add (const Vector & other) T Avg () const Vector Cross (const Vector & other) const void Div (T v) T Dot (const Vector & other) const Tensor < T > Dyadic (const Vector & other) const bool IsEqual (const Vector & other) const T Length () const Return the vector's length(magnitude). T Max () const T Min () const void Mul (T v) void Normalize () void Set (const std::initializer_list< U > & lst) void Set (const Vector & other) void SetAt (size_t i, T v, Args... args) void SetAt (size_t i, T v) constexpr size_t Size () const void Sub (T v) void Sub (const Vector & other) T Sum () const Vector () Vector (const Vector & other) Vector (const std::array< T, N > & other) Vector (Args... args) Vector (const std::initializer_list< U > & lst) bool operator!= (const Vector & other) const Vector operator& (const Vector & other) const Override & operator for cross product. Vector & operator&= (const Vector & other) T & operator() (size_t i) const T & operator() (size_t i) const Vector operator* (T v) const Override * operator for vector multiplication. T operator* (const Vector & other) const Override * operator for dot product. Vector & operator*= (T v) Vector operator+ (const Vector & other) const Vector operator+ (T v) const Vector & operator+= (const Vector & other) Vector & operator+= (T v) Vector operator- (const Vector & other) const Vector operator- (T v) const Vector & operator-= (const Vector & other) Vector & operator-= (T v) void operator= (const Vector & other) bool operator== (const Vector & other) const Tensor < T > operator^ (const Vector & other) const Override ^ operator for dyadic product. virtual ~Vector () = default Public Functions Documentation \u00b6 function AbsMax \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Vector :: AbsMax () const function AbsMin \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Vector :: AbsMin () const function Add [\u00bd] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Vector :: Add ( T v ) function Add [2/2] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Vector :: Add ( const Vector & other ) function Avg \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Vector :: Avg () const function Cross \u00b6 inline Vector OpenOasis :: CommImp :: Numeric :: Vector :: Cross ( const Vector & other ) const function Div \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Vector :: Div ( T v ) function Dot \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Vector :: Dot ( const Vector & other ) const function Dyadic \u00b6 inline Tensor < T > OpenOasis :: CommImp :: Numeric :: Vector :: Dyadic ( const Vector & other ) const function IsEqual \u00b6 inline bool OpenOasis :: CommImp :: Numeric :: Vector :: IsEqual ( const Vector & other ) const function Length \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Vector :: Length () const function Max \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Vector :: Max () const function Min \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Vector :: Min () const function Mul \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Vector :: Mul ( T v ) function Normalize \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Vector :: Normalize () function Set [\u00bd] \u00b6 template < typename U > inline void OpenOasis :: CommImp :: Numeric :: Vector :: Set ( const std :: initializer_list < U > & lst ) function Set [2/2] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Vector :: Set ( const Vector & other ) function SetAt [\u00bd] \u00b6 template < typename ... Args > inline void OpenOasis :: CommImp :: Numeric :: Vector :: SetAt ( size_t i , T v , Args ... args ) function SetAt [2/2] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Vector :: SetAt ( size_t i , T v ) function Size \u00b6 inline constexpr size_t OpenOasis :: CommImp :: Numeric :: Vector :: Size () const function Sub [\u00bd] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Vector :: Sub ( T v ) function Sub [2/2] \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Vector :: Sub ( const Vector & other ) function Sum \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Vector :: Sum () const function Vector [\u2155] \u00b6 inline OpenOasis :: CommImp :: Numeric :: Vector :: Vector () function Vector [\u2156] \u00b6 inline OpenOasis :: CommImp :: Numeric :: Vector :: Vector ( const Vector & other ) function Vector [\u2157] \u00b6 inline OpenOasis :: CommImp :: Numeric :: Vector :: Vector ( const std :: array < T , N > & other ) function Vector [\u2158] \u00b6 template < typename ... Args > inline OpenOasis :: CommImp :: Numeric :: Vector :: Vector ( Args ... args ) function Vector [5/5] \u00b6 template < typename U > inline OpenOasis :: CommImp :: Numeric :: Vector :: Vector ( const std :: initializer_list < U > & lst ) function operator!= \u00b6 inline bool OpenOasis :: CommImp :: Numeric :: Vector :: operator != ( const Vector & other ) const function operator& \u00b6 inline Vector OpenOasis :: CommImp :: Numeric :: Vector :: operator & ( const Vector & other ) const function operator&= \u00b6 inline Vector & OpenOasis :: CommImp :: Numeric :: Vector :: operator &= ( const Vector & other ) function operator() [\u00bd] \u00b6 inline T & OpenOasis :: CommImp :: Numeric :: Vector :: operator () ( size_t i ) function operator() [2/2] \u00b6 inline const T & OpenOasis :: CommImp :: Numeric :: Vector :: operator () ( size_t i ) const function operator* \u00b6 inline Vector OpenOasis :: CommImp :: Numeric :: Vector :: operator * ( T v ) const function operator* \u00b6 inline T OpenOasis :: CommImp :: Numeric :: Vector :: operator * ( const Vector & other ) const function operator*= \u00b6 inline Vector & OpenOasis :: CommImp :: Numeric :: Vector :: operator *= ( T v ) function operator+ \u00b6 inline Vector OpenOasis :: CommImp :: Numeric :: Vector :: operator + ( const Vector & other ) const function operator+ \u00b6 inline Vector OpenOasis :: CommImp :: Numeric :: Vector :: operator + ( T v ) const function operator+= \u00b6 inline Vector & OpenOasis :: CommImp :: Numeric :: Vector :: operator += ( const Vector & other ) function operator+= \u00b6 inline Vector & OpenOasis :: CommImp :: Numeric :: Vector :: operator += ( T v ) function operator- \u00b6 inline Vector OpenOasis :: CommImp :: Numeric :: Vector :: operator - ( const Vector & other ) const function operator- \u00b6 inline Vector OpenOasis :: CommImp :: Numeric :: Vector :: operator - ( T v ) const function operator-= \u00b6 inline Vector & OpenOasis :: CommImp :: Numeric :: Vector :: operator -= ( const Vector & other ) function operator-= \u00b6 inline Vector & OpenOasis :: CommImp :: Numeric :: Vector :: operator -= ( T v ) function operator= \u00b6 inline void OpenOasis :: CommImp :: Numeric :: Vector :: operator = ( const Vector & other ) function operator== \u00b6 inline bool OpenOasis :: CommImp :: Numeric :: Vector :: operator == ( const Vector & other ) const function operator^ \u00b6 inline Tensor < T > OpenOasis :: CommImp :: Numeric :: Vector :: operator ^ ( const Vector & other ) const function ~Vector \u00b6 virtual OpenOasis :: CommImp :: Numeric :: Vector ::~ Vector () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/Vector.h","title":"Class OpenOasis::CommImp::Numeric::Vector"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#class-openoasiscommimpnumericvector","text":"template <typename T, size_t N> ClassList > OpenOasis > CommImp > Numeric > Vector","title":"Class OpenOasis::CommImp::Numeric::Vector"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#public-functions","text":"Type Name T AbsMax () const Return the component of the vector hasing the maximum absolute value. T AbsMin () const Return the component of the vector hasing the minimum absolute value. void Add (T v) void Add (const Vector & other) T Avg () const Vector Cross (const Vector & other) const void Div (T v) T Dot (const Vector & other) const Tensor < T > Dyadic (const Vector & other) const bool IsEqual (const Vector & other) const T Length () const Return the vector's length(magnitude). T Max () const T Min () const void Mul (T v) void Normalize () void Set (const std::initializer_list< U > & lst) void Set (const Vector & other) void SetAt (size_t i, T v, Args... args) void SetAt (size_t i, T v) constexpr size_t Size () const void Sub (T v) void Sub (const Vector & other) T Sum () const Vector () Vector (const Vector & other) Vector (const std::array< T, N > & other) Vector (Args... args) Vector (const std::initializer_list< U > & lst) bool operator!= (const Vector & other) const Vector operator& (const Vector & other) const Override & operator for cross product. Vector & operator&= (const Vector & other) T & operator() (size_t i) const T & operator() (size_t i) const Vector operator* (T v) const Override * operator for vector multiplication. T operator* (const Vector & other) const Override * operator for dot product. Vector & operator*= (T v) Vector operator+ (const Vector & other) const Vector operator+ (T v) const Vector & operator+= (const Vector & other) Vector & operator+= (T v) Vector operator- (const Vector & other) const Vector operator- (T v) const Vector & operator-= (const Vector & other) Vector & operator-= (T v) void operator= (const Vector & other) bool operator== (const Vector & other) const Tensor < T > operator^ (const Vector & other) const Override ^ operator for dyadic product. virtual ~Vector () = default","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-absmax","text":"inline T OpenOasis :: CommImp :: Numeric :: Vector :: AbsMax () const","title":"function AbsMax"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-absmin","text":"inline T OpenOasis :: CommImp :: Numeric :: Vector :: AbsMin () const","title":"function AbsMin"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-add-12","text":"inline void OpenOasis :: CommImp :: Numeric :: Vector :: Add ( T v )","title":"function Add [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-add-22","text":"inline void OpenOasis :: CommImp :: Numeric :: Vector :: Add ( const Vector & other )","title":"function Add [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-avg","text":"inline T OpenOasis :: CommImp :: Numeric :: Vector :: Avg () const","title":"function Avg"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-cross","text":"inline Vector OpenOasis :: CommImp :: Numeric :: Vector :: Cross ( const Vector & other ) const","title":"function Cross"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-div","text":"inline void OpenOasis :: CommImp :: Numeric :: Vector :: Div ( T v )","title":"function Div"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-dot","text":"inline T OpenOasis :: CommImp :: Numeric :: Vector :: Dot ( const Vector & other ) const","title":"function Dot"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-dyadic","text":"inline Tensor < T > OpenOasis :: CommImp :: Numeric :: Vector :: Dyadic ( const Vector & other ) const","title":"function Dyadic"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-isequal","text":"inline bool OpenOasis :: CommImp :: Numeric :: Vector :: IsEqual ( const Vector & other ) const","title":"function IsEqual"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-length","text":"inline T OpenOasis :: CommImp :: Numeric :: Vector :: Length () const","title":"function Length"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-max","text":"inline T OpenOasis :: CommImp :: Numeric :: Vector :: Max () const","title":"function Max"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-min","text":"inline T OpenOasis :: CommImp :: Numeric :: Vector :: Min () const","title":"function Min"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-mul","text":"inline void OpenOasis :: CommImp :: Numeric :: Vector :: Mul ( T v )","title":"function Mul"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-normalize","text":"inline void OpenOasis :: CommImp :: Numeric :: Vector :: Normalize ()","title":"function Normalize"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-set-12","text":"template < typename U > inline void OpenOasis :: CommImp :: Numeric :: Vector :: Set ( const std :: initializer_list < U > & lst )","title":"function Set [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-set-22","text":"inline void OpenOasis :: CommImp :: Numeric :: Vector :: Set ( const Vector & other )","title":"function Set [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-setat-12","text":"template < typename ... Args > inline void OpenOasis :: CommImp :: Numeric :: Vector :: SetAt ( size_t i , T v , Args ... args )","title":"function SetAt [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-setat-22","text":"inline void OpenOasis :: CommImp :: Numeric :: Vector :: SetAt ( size_t i , T v )","title":"function SetAt [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-size","text":"inline constexpr size_t OpenOasis :: CommImp :: Numeric :: Vector :: Size () const","title":"function Size"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-sub-12","text":"inline void OpenOasis :: CommImp :: Numeric :: Vector :: Sub ( T v )","title":"function Sub [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-sub-22","text":"inline void OpenOasis :: CommImp :: Numeric :: Vector :: Sub ( const Vector & other )","title":"function Sub [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-sum","text":"inline T OpenOasis :: CommImp :: Numeric :: Vector :: Sum () const","title":"function Sum"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-vector-15","text":"inline OpenOasis :: CommImp :: Numeric :: Vector :: Vector ()","title":"function Vector [&#8533;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-vector-25","text":"inline OpenOasis :: CommImp :: Numeric :: Vector :: Vector ( const Vector & other )","title":"function Vector [&#8534;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-vector-35","text":"inline OpenOasis :: CommImp :: Numeric :: Vector :: Vector ( const std :: array < T , N > & other )","title":"function Vector [&#8535;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-vector-45","text":"template < typename ... Args > inline OpenOasis :: CommImp :: Numeric :: Vector :: Vector ( Args ... args )","title":"function Vector [&#8536;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-vector-55","text":"template < typename U > inline OpenOasis :: CommImp :: Numeric :: Vector :: Vector ( const std :: initializer_list < U > & lst )","title":"function Vector [5/5]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator","text":"inline bool OpenOasis :: CommImp :: Numeric :: Vector :: operator != ( const Vector & other ) const","title":"function operator!="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator_1","text":"inline Vector OpenOasis :: CommImp :: Numeric :: Vector :: operator & ( const Vector & other ) const","title":"function operator&amp;"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator_2","text":"inline Vector & OpenOasis :: CommImp :: Numeric :: Vector :: operator &= ( const Vector & other )","title":"function operator&amp;="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator-12","text":"inline T & OpenOasis :: CommImp :: Numeric :: Vector :: operator () ( size_t i )","title":"function operator() [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator-22","text":"inline const T & OpenOasis :: CommImp :: Numeric :: Vector :: operator () ( size_t i ) const","title":"function operator() [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator_3","text":"inline Vector OpenOasis :: CommImp :: Numeric :: Vector :: operator * ( T v ) const","title":"function operator*"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator_4","text":"inline T OpenOasis :: CommImp :: Numeric :: Vector :: operator * ( const Vector & other ) const","title":"function operator*"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator_5","text":"inline Vector & OpenOasis :: CommImp :: Numeric :: Vector :: operator *= ( T v )","title":"function operator*="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator_6","text":"inline Vector OpenOasis :: CommImp :: Numeric :: Vector :: operator + ( const Vector & other ) const","title":"function operator+"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator_7","text":"inline Vector OpenOasis :: CommImp :: Numeric :: Vector :: operator + ( T v ) const","title":"function operator+"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator_8","text":"inline Vector & OpenOasis :: CommImp :: Numeric :: Vector :: operator += ( const Vector & other )","title":"function operator+="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator_9","text":"inline Vector & OpenOasis :: CommImp :: Numeric :: Vector :: operator += ( T v )","title":"function operator+="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator-","text":"inline Vector OpenOasis :: CommImp :: Numeric :: Vector :: operator - ( const Vector & other ) const","title":"function operator-"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator-_1","text":"inline Vector OpenOasis :: CommImp :: Numeric :: Vector :: operator - ( T v ) const","title":"function operator-"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator-_2","text":"inline Vector & OpenOasis :: CommImp :: Numeric :: Vector :: operator -= ( const Vector & other )","title":"function operator-="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator-_3","text":"inline Vector & OpenOasis :: CommImp :: Numeric :: Vector :: operator -= ( T v )","title":"function operator-="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator_10","text":"inline void OpenOasis :: CommImp :: Numeric :: Vector :: operator = ( const Vector & other )","title":"function operator="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator_11","text":"inline bool OpenOasis :: CommImp :: Numeric :: Vector :: operator == ( const Vector & other ) const","title":"function operator=="},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-operator_12","text":"inline Tensor < T > OpenOasis :: CommImp :: Numeric :: Vector :: operator ^ ( const Vector & other ) const","title":"function operator^"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector/#function-vector","text":"virtual OpenOasis :: CommImp :: Numeric :: Vector ::~ Vector () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/Vector.h","title":"function ~Vector"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector_field/","text":"Class OpenOasis::CommImp::Numeric::VectorField \u00b6 template <typename T, std::size_t N> ClassList > OpenOasis > CommImp > Numeric > VectorField Vector field with default zero vector in 2D or 3D space. #include <VectorField.h> Inherits the following classes: OpenOasis::CommImp::Numeric::Field Public Functions \u00b6 Type Name VectorField (FieldDomain domain=FieldDomain::CELL) VectorField (std::size_t size, const Vector < T, N > & val={}, FieldDomain domain=FieldDomain::CELL) virtual ~VectorField () = default Public Functions inherited from OpenOasis::CommImp::Numeric::Field \u00b6 See OpenOasis::CommImp::Numeric::Field Type Name void Clean () Cleans the field data to the default value. void Clear () Clears the field. const std::vector< T > & Data () const Returns constant refrence to the field data. void ForEach (Callback func) Iterates the field and invoke given func for each element. void Initialize (T value) Initializes the vector field with specified value. FieldDomain Range () const void Resize (std::size_t size) Resizes the field. void SetAt (std::size_t i, T value) Sets the field data. void SetAt (std::size_t startIndex, std::size_t endIndex, const Field < T > & other, std::size_t offset=0) Sets the field data from the specified range. std::size_t Size () const Returns the field size. FieldType Type () const const T & operator() (int i) const T & operator() (int i) Field < T > operator* (double k) const void operator*= (double k) Field < T > operator+ (const Field < T > & other) const void operator+= (const Field < T > & other) Field < T > operator- (const Field < T > & other) const void operator-= (const Field < T > & other) void operator= (const Field < T > & other) void operator= (const T & value) Protected Attributes inherited from OpenOasis::CommImp::Numeric::Field \u00b6 See OpenOasis::CommImp::Numeric::Field Type Name std::vector< T > mData T mDefault FieldDomain mDomain = = FieldDomain::NONE FieldType mType = = FieldType::NONE Protected Functions inherited from OpenOasis::CommImp::Numeric::Field \u00b6 See OpenOasis::CommImp::Numeric::Field Type Name Field () = default Field (std::size_t size, T value) virtual ~Field () = default Public Functions Documentation \u00b6 function VectorField [\u00bd] \u00b6 inline OpenOasis :: CommImp :: Numeric :: VectorField :: VectorField ( FieldDomain domain = FieldDomain :: CELL ) function VectorField [2/2] \u00b6 inline OpenOasis :: CommImp :: Numeric :: VectorField :: VectorField ( std :: size_t size , const Vector < T , N > & val = {}, FieldDomain domain = FieldDomain :: CELL ) function ~VectorField \u00b6 virtual OpenOasis :: CommImp :: Numeric :: VectorField ::~ VectorField () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/VectorField.h","title":"Class OpenOasis::CommImp::Numeric::VectorField"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector_field/#class-openoasiscommimpnumericvectorfield","text":"template <typename T, std::size_t N> ClassList > OpenOasis > CommImp > Numeric > VectorField Vector field with default zero vector in 2D or 3D space. #include <VectorField.h> Inherits the following classes: OpenOasis::CommImp::Numeric::Field","title":"Class OpenOasis::CommImp::Numeric::VectorField"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector_field/#public-functions","text":"Type Name VectorField (FieldDomain domain=FieldDomain::CELL) VectorField (std::size_t size, const Vector < T, N > & val={}, FieldDomain domain=FieldDomain::CELL) virtual ~VectorField () = default","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector_field/#public-functions-inherited-from-openoasiscommimpnumericfield","text":"See OpenOasis::CommImp::Numeric::Field Type Name void Clean () Cleans the field data to the default value. void Clear () Clears the field. const std::vector< T > & Data () const Returns constant refrence to the field data. void ForEach (Callback func) Iterates the field and invoke given func for each element. void Initialize (T value) Initializes the vector field with specified value. FieldDomain Range () const void Resize (std::size_t size) Resizes the field. void SetAt (std::size_t i, T value) Sets the field data. void SetAt (std::size_t startIndex, std::size_t endIndex, const Field < T > & other, std::size_t offset=0) Sets the field data from the specified range. std::size_t Size () const Returns the field size. FieldType Type () const const T & operator() (int i) const T & operator() (int i) Field < T > operator* (double k) const void operator*= (double k) Field < T > operator+ (const Field < T > & other) const void operator+= (const Field < T > & other) Field < T > operator- (const Field < T > & other) const void operator-= (const Field < T > & other) void operator= (const Field < T > & other) void operator= (const T & value)","title":"Public Functions inherited from OpenOasis::CommImp::Numeric::Field"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector_field/#protected-attributes-inherited-from-openoasiscommimpnumericfield","text":"See OpenOasis::CommImp::Numeric::Field Type Name std::vector< T > mData T mDefault FieldDomain mDomain = = FieldDomain::NONE FieldType mType = = FieldType::NONE","title":"Protected Attributes inherited from OpenOasis::CommImp::Numeric::Field"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector_field/#protected-functions-inherited-from-openoasiscommimpnumericfield","text":"See OpenOasis::CommImp::Numeric::Field Type Name Field () = default Field (std::size_t size, T value) virtual ~Field () = default","title":"Protected Functions inherited from OpenOasis::CommImp::Numeric::Field"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector_field/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector_field/#function-vectorfield-12","text":"inline OpenOasis :: CommImp :: Numeric :: VectorField :: VectorField ( FieldDomain domain = FieldDomain :: CELL )","title":"function VectorField [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector_field/#function-vectorfield-22","text":"inline OpenOasis :: CommImp :: Numeric :: VectorField :: VectorField ( std :: size_t size , const Vector < T , N > & val = {}, FieldDomain domain = FieldDomain :: CELL )","title":"function VectorField [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_numeric_1_1_vector_field/#function-vectorfield","text":"virtual OpenOasis :: CommImp :: Numeric :: VectorField ::~ VectorField () = default The documentation for this class was generated from the following file Models/CommImp/Numeric/VectorField.h","title":"function ~VectorField"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_spatial/","text":"Namespace OpenOasis::CommImp::Spatial \u00b6 Namespace List > OpenOasis > CommImp > Spatial More... Classes \u00b6 Type Name struct Cell Mesh cell data structure. Polygon type for 1D and 2D mesh, Polyhedron type for 3D mesh. struct Coordinate The Coordinate struct contains a (x, y, z) coordinate. struct Face Mesh face data structure. Polyline type for 1D or 2D mesh, Polygon type for 3D mesh. class GeoCalculator The GeoCalculator is a collection of general geometry functions. class Grid Grid encapsulate the mesh data for numerical calculation. class Grid1D class Grid2D Grid formed by flat cells in 2d. class Grid3D struct Mesh Mesh structure. struct Node Mesh node data structure. (Point type). struct XYExtent Extent is a rectangle in xy-space. class XYGeoTools The XYGeoTools class is a collection of general geometry functions. struct XYLine The XYline struct is used for representing a line segment. struct XYPoint XYPoint is simply a x and y coordinate point (has no z coordinate). struct XYPolygon The XYPolygon struct defines a polygon in the XY plane (no z coordinate). struct XYPolyline XYPolyline is a collection of points (at least 2) connected with straigth lines. XYPolylines are typically used for presentation of 1D data, river network. Detailed Description \u00b6 @File : Coordinate.cpp @Brief : None. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : Coordinate.h @License : Apache-2.0 @Desc : The Coordinate struct contains a (x, y, z) coordinate. @File : GeoCalculator.cpp @Brief : A collection of general geometry functions. @File : Grid.cpp @Brief : Grid used for numerical calculation. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : Grid.h @License : Apache-2.0 @Desc : Grid used for numerical calculation. @File : Grid1D.cpp @Brief : Grid in river net used for numerical calculation. @File : Grid2D.cpp @Brief : Grid in 2d used for numerical calculation. @File : Grid3D.cpp @Brief : Grid in 3d used for numerical calculation. @File : XYGeoStructs.cpp @Brief : To provide basic plane geometry data structures (no z coordinate). @File : XYGeoTools.cpp @Brief : The XYGeoTools class is a collection of general geometry functions. The documentation for this class was generated from the following file Models/CommImp/Spatial/Coordinate.cpp","title":"Namespace OpenOasis::CommImp::Spatial"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_spatial/#namespace-openoasiscommimpspatial","text":"Namespace List > OpenOasis > CommImp > Spatial More...","title":"Namespace OpenOasis::CommImp::Spatial"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_spatial/#classes","text":"Type Name struct Cell Mesh cell data structure. Polygon type for 1D and 2D mesh, Polyhedron type for 3D mesh. struct Coordinate The Coordinate struct contains a (x, y, z) coordinate. struct Face Mesh face data structure. Polyline type for 1D or 2D mesh, Polygon type for 3D mesh. class GeoCalculator The GeoCalculator is a collection of general geometry functions. class Grid Grid encapsulate the mesh data for numerical calculation. class Grid1D class Grid2D Grid formed by flat cells in 2d. class Grid3D struct Mesh Mesh structure. struct Node Mesh node data structure. (Point type). struct XYExtent Extent is a rectangle in xy-space. class XYGeoTools The XYGeoTools class is a collection of general geometry functions. struct XYLine The XYline struct is used for representing a line segment. struct XYPoint XYPoint is simply a x and y coordinate point (has no z coordinate). struct XYPolygon The XYPolygon struct defines a polygon in the XY plane (no z coordinate). struct XYPolyline XYPolyline is a collection of points (at least 2) connected with straigth lines. XYPolylines are typically used for presentation of 1D data, river network.","title":"Classes"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_spatial/#detailed-description","text":"@File : Coordinate.cpp @Brief : None. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : Coordinate.h @License : Apache-2.0 @Desc : The Coordinate struct contains a (x, y, z) coordinate. @File : GeoCalculator.cpp @Brief : A collection of general geometry functions. @File : Grid.cpp @Brief : Grid used for numerical calculation. Copyright (C) 2022, The OpenOasis Contributors. Join us in the Oasis! @File : Grid.h @License : Apache-2.0 @Desc : Grid used for numerical calculation. @File : Grid1D.cpp @Brief : Grid in river net used for numerical calculation. @File : Grid2D.cpp @Brief : Grid in 2d used for numerical calculation. @File : Grid3D.cpp @Brief : Grid in 3d used for numerical calculation. @File : XYGeoStructs.cpp @Brief : To provide basic plane geometry data structures (no z coordinate). @File : XYGeoTools.cpp @Brief : The XYGeoTools class is a collection of general geometry functions. The documentation for this class was generated from the following file Models/CommImp/Spatial/Coordinate.cpp","title":"Detailed Description"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_cell/","text":"Struct OpenOasis::CommImp::Spatial::Cell \u00b6 ClassList > OpenOasis > CommImp > Spatial > Cell Mesh cell data structure. Polygon type for 1D and 2D mesh, Polyhedron type for 3D mesh. #include <MeshStructs.h> Public Attributes \u00b6 Type Name Coordinate centroid std::vector< int > faceIndexes std::vector< int > neighbors std::vector< int > subCells real surface = = NAN real volume = = NAN Public Attributes Documentation \u00b6 variable centroid \u00b6 Coordinate OpenOasis :: CommImp :: Spatial :: Cell :: centroid ; variable faceIndexes \u00b6 std :: vector < int > OpenOasis :: CommImp :: Spatial :: Cell :: faceIndexes ; variable neighbors \u00b6 std :: vector < int > OpenOasis :: CommImp :: Spatial :: Cell :: neighbors ; variable subCells \u00b6 std :: vector < int > OpenOasis :: CommImp :: Spatial :: Cell :: subCells ; variable surface \u00b6 real OpenOasis :: CommImp :: Spatial :: Cell :: surface ; variable volume \u00b6 real OpenOasis :: CommImp :: Spatial :: Cell :: volume ; The documentation for this class was generated from the following file Models/CommImp/Spatial/MeshStructs.h","title":"Struct OpenOasis::CommImp::Spatial::Cell"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_cell/#struct-openoasiscommimpspatialcell","text":"ClassList > OpenOasis > CommImp > Spatial > Cell Mesh cell data structure. Polygon type for 1D and 2D mesh, Polyhedron type for 3D mesh. #include <MeshStructs.h>","title":"Struct OpenOasis::CommImp::Spatial::Cell"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_cell/#public-attributes","text":"Type Name Coordinate centroid std::vector< int > faceIndexes std::vector< int > neighbors std::vector< int > subCells real surface = = NAN real volume = = NAN","title":"Public Attributes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_cell/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_cell/#variable-centroid","text":"Coordinate OpenOasis :: CommImp :: Spatial :: Cell :: centroid ;","title":"variable centroid"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_cell/#variable-faceindexes","text":"std :: vector < int > OpenOasis :: CommImp :: Spatial :: Cell :: faceIndexes ;","title":"variable faceIndexes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_cell/#variable-neighbors","text":"std :: vector < int > OpenOasis :: CommImp :: Spatial :: Cell :: neighbors ;","title":"variable neighbors"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_cell/#variable-subcells","text":"std :: vector < int > OpenOasis :: CommImp :: Spatial :: Cell :: subCells ;","title":"variable subCells"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_cell/#variable-surface","text":"real OpenOasis :: CommImp :: Spatial :: Cell :: surface ;","title":"variable surface"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_cell/#variable-volume","text":"real OpenOasis :: CommImp :: Spatial :: Cell :: volume ; The documentation for this class was generated from the following file Models/CommImp/Spatial/MeshStructs.h","title":"variable volume"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_coordinate/","text":"Struct OpenOasis::CommImp::Spatial::Coordinate \u00b6 ClassList > OpenOasis > CommImp > Spatial > Coordinate The Coordinate struct contains a (x, y, z) coordinate. #include <Coordinate.h> Public Attributes \u00b6 Type Name real x = = 0. real y = = 0. real z = = 0. Public Functions \u00b6 Type Name bool Equals (real coorX, real coorY, real coorZ) const bool Equals (const Coordinate & coor) const Public Attributes Documentation \u00b6 variable x \u00b6 real OpenOasis :: CommImp :: Spatial :: Coordinate :: x ; variable y \u00b6 real OpenOasis :: CommImp :: Spatial :: Coordinate :: y ; variable z \u00b6 real OpenOasis :: CommImp :: Spatial :: Coordinate :: z ; Public Functions Documentation \u00b6 function Equals [\u00bd] \u00b6 bool OpenOasis :: CommImp :: Spatial :: Coordinate :: Equals ( real coorX , real coorY , real coorZ ) const function Equals [2/2] \u00b6 bool OpenOasis :: CommImp :: Spatial :: Coordinate :: Equals ( const Coordinate & coor ) const The documentation for this class was generated from the following file Models/CommImp/Spatial/Coordinate.h","title":"Struct OpenOasis::CommImp::Spatial::Coordinate"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_coordinate/#struct-openoasiscommimpspatialcoordinate","text":"ClassList > OpenOasis > CommImp > Spatial > Coordinate The Coordinate struct contains a (x, y, z) coordinate. #include <Coordinate.h>","title":"Struct OpenOasis::CommImp::Spatial::Coordinate"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_coordinate/#public-attributes","text":"Type Name real x = = 0. real y = = 0. real z = = 0.","title":"Public Attributes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_coordinate/#public-functions","text":"Type Name bool Equals (real coorX, real coorY, real coorZ) const bool Equals (const Coordinate & coor) const","title":"Public Functions"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_coordinate/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_coordinate/#variable-x","text":"real OpenOasis :: CommImp :: Spatial :: Coordinate :: x ;","title":"variable x"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_coordinate/#variable-y","text":"real OpenOasis :: CommImp :: Spatial :: Coordinate :: y ;","title":"variable y"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_coordinate/#variable-z","text":"real OpenOasis :: CommImp :: Spatial :: Coordinate :: z ;","title":"variable z"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_coordinate/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_coordinate/#function-equals-12","text":"bool OpenOasis :: CommImp :: Spatial :: Coordinate :: Equals ( real coorX , real coorY , real coorZ ) const","title":"function Equals [&frac12;]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_coordinate/#function-equals-22","text":"bool OpenOasis :: CommImp :: Spatial :: Coordinate :: Equals ( const Coordinate & coor ) const The documentation for this class was generated from the following file Models/CommImp/Spatial/Coordinate.h","title":"function Equals [2/2]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_face/","text":"Struct OpenOasis::CommImp::Spatial::Face \u00b6 ClassList > OpenOasis > CommImp > Spatial > Face Mesh face data structure. Polyline type for 1D or 2D mesh, Polygon type for 3D mesh. #include <MeshStructs.h> Public Attributes \u00b6 Type Name real area = = NAN std::vector< int > cellIndexes std::vector< int > cellSides Coordinate centroid std::vector< int > nodeIndexes std::array< real, 3 > normal real perimeter = = NAN Public Attributes Documentation \u00b6 variable area \u00b6 real OpenOasis :: CommImp :: Spatial :: Face :: area ; variable cellIndexes \u00b6 std :: vector < int > OpenOasis :: CommImp :: Spatial :: Face :: cellIndexes ; variable cellSides \u00b6 std :: vector < int > OpenOasis :: CommImp :: Spatial :: Face :: cellSides ; variable centroid \u00b6 Coordinate OpenOasis :: CommImp :: Spatial :: Face :: centroid ; variable nodeIndexes \u00b6 std :: vector < int > OpenOasis :: CommImp :: Spatial :: Face :: nodeIndexes ; variable normal \u00b6 std :: array < real , 3 > OpenOasis :: CommImp :: Spatial :: Face :: normal ; variable perimeter \u00b6 real OpenOasis :: CommImp :: Spatial :: Face :: perimeter ; The documentation for this class was generated from the following file Models/CommImp/Spatial/MeshStructs.h","title":"Struct OpenOasis::CommImp::Spatial::Face"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_face/#struct-openoasiscommimpspatialface","text":"ClassList > OpenOasis > CommImp > Spatial > Face Mesh face data structure. Polyline type for 1D or 2D mesh, Polygon type for 3D mesh. #include <MeshStructs.h>","title":"Struct OpenOasis::CommImp::Spatial::Face"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_face/#public-attributes","text":"Type Name real area = = NAN std::vector< int > cellIndexes std::vector< int > cellSides Coordinate centroid std::vector< int > nodeIndexes std::array< real, 3 > normal real perimeter = = NAN","title":"Public Attributes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_face/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_face/#variable-area","text":"real OpenOasis :: CommImp :: Spatial :: Face :: area ;","title":"variable area"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_face/#variable-cellindexes","text":"std :: vector < int > OpenOasis :: CommImp :: Spatial :: Face :: cellIndexes ;","title":"variable cellIndexes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_face/#variable-cellsides","text":"std :: vector < int > OpenOasis :: CommImp :: Spatial :: Face :: cellSides ;","title":"variable cellSides"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_face/#variable-centroid","text":"Coordinate OpenOasis :: CommImp :: Spatial :: Face :: centroid ;","title":"variable centroid"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_face/#variable-nodeindexes","text":"std :: vector < int > OpenOasis :: CommImp :: Spatial :: Face :: nodeIndexes ;","title":"variable nodeIndexes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_face/#variable-normal","text":"std :: array < real , 3 > OpenOasis :: CommImp :: Spatial :: Face :: normal ;","title":"variable normal"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_face/#variable-perimeter","text":"real OpenOasis :: CommImp :: Spatial :: Face :: perimeter ; The documentation for this class was generated from the following file Models/CommImp/Spatial/MeshStructs.h","title":"variable perimeter"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/","text":"Class OpenOasis::CommImp::Spatial::GeoCalculator \u00b6 ClassList > OpenOasis > CommImp > Spatial > GeoCalculator The GeoCalculator is a collection of general geometry functions. #include <GeoCalculator.h> Public Static Attributes \u00b6 Type Name constexpr real EPSILON = = 1.0e-5 Public Static Functions \u00b6 Type Name real CalculateArea (const Vector < real, 3 > & normal, const std::vector< int > & nodeIdxs, const std::unordered_map< int, Node > & nodes) Calculates the plane(2d or 3d) area. Coordinate CalculateCellCentroid (int cellIdx, const Mesh & mesh) real CalculateCellVolume (int cellIdx, const Mesh & mesh) Coordinate CalculateCentroid (const std::vector< int > & nodeIdxs, const std::unordered_map< int, Node > & nodes) Calculates the centroid. real CalculateFaceArea (int faceIdx, const Mesh & mesh) Coordinate CalculateFaceCentroid (int faceIdx, const Mesh & mesh) std::array< real, 3 > CalculateFaceNormal (int faceIdx, const Mesh & mesh) real CalculateFacePerimeter (int faceIdx, const Mesh & mesh) real CalculateLength (const Node & node0, const Node & node1) Calculates the distance between two Nodes. std::array< real, 3 > CalculateNormal (const std::vector< int > & nodeIdxs, const std::unordered_map< int, Node > & nodes) Calculates the plane(2d or 3d) unit normal vector. real CalculateVolume (const std::vector< int > & nodeIdxs, const std::unordered_map< int, Node > & nodes) Calculates the volume of a polygon pyramid. std::vector< int > GetCellNodeIndexes (int cellIdx, const Mesh & mesh) std::vector< int > SortFaceNodes (int faceIndex, const Mesh & mesh) std::vector< int > SortNodes (const std::vector< int > & nodeIdxs, const std::unordered_map< int, Node > & nodes) Sortes the specified Nodes counterclockwise. Public Static Attributes Documentation \u00b6 variable EPSILON \u00b6 constexpr real OpenOasis :: CommImp :: Spatial :: GeoCalculator :: EPSILON ; Public Static Functions Documentation \u00b6 function CalculateArea \u00b6 Calculates the plane(2d or 3d) area. static real OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateArea ( const Vector < real , 3 > & normal , const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ) Parameters: normal The unit normal vector of the plane. nodeIdxs The clock- or counter- clockwise ordered Node indexes. nodes The Node map. Returns: Area of the plane. function CalculateCellCentroid \u00b6 static Coordinate OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateCellCentroid ( int cellIdx , const Mesh & mesh ) function CalculateCellVolume \u00b6 static real OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateCellVolume ( int cellIdx , const Mesh & mesh ) function CalculateCentroid \u00b6 Calculates the centroid. static Coordinate OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateCentroid ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ) Parameters: nodeIdxs Node indexes. nodes The Nodes map. Returns: Centroid. function CalculateFaceArea \u00b6 static real OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateFaceArea ( int faceIdx , const Mesh & mesh ) function CalculateFaceCentroid \u00b6 static Coordinate OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateFaceCentroid ( int faceIdx , const Mesh & mesh ) function CalculateFaceNormal \u00b6 static std :: array < real , 3 > OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateFaceNormal ( int faceIdx , const Mesh & mesh ) function CalculateFacePerimeter \u00b6 static real OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateFacePerimeter ( int faceIdx , const Mesh & mesh ) function CalculateLength \u00b6 Calculates the distance between two Nodes. static real OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateLength ( const Node & node0 , const Node & node1 ) Parameters: node0 The endpoint. node1 The endpoint. Returns: The length. function CalculateNormal \u00b6 Calculates the plane(2d or 3d) unit normal vector. static std :: array < real , 3 > OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateNormal ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ) Parameters: nodeIdxs The clock- or counter- clockwise ordered Node indexes. nodes The Nodes map. Returns: Unit normal vector. function CalculateVolume \u00b6 Calculates the volume of a polygon pyramid. static real OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateVolume ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ) Parameters: nodeIdxs The Node indexes. nodes The Node map. Returns: Volume. function GetCellNodeIndexes \u00b6 static std :: vector < int > OpenOasis :: CommImp :: Spatial :: GeoCalculator :: GetCellNodeIndexes ( int cellIdx , const Mesh & mesh ) function SortFaceNodes \u00b6 static std :: vector < int > OpenOasis :: CommImp :: Spatial :: GeoCalculator :: SortFaceNodes ( int faceIndex , const Mesh & mesh ) function SortNodes \u00b6 Sortes the specified Nodes counterclockwise. static std :: vector < int > OpenOasis :: CommImp :: Spatial :: GeoCalculator :: SortNodes ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ) Parameters: nodeIdxs The Node indexes. nodes The Nodes map. Returns: The sorted Node indexes. The documentation for this class was generated from the following file Models/CommImp/Spatial/GeoCalculator.h","title":"Class OpenOasis::CommImp::Spatial::GeoCalculator"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#class-openoasiscommimpspatialgeocalculator","text":"ClassList > OpenOasis > CommImp > Spatial > GeoCalculator The GeoCalculator is a collection of general geometry functions. #include <GeoCalculator.h>","title":"Class OpenOasis::CommImp::Spatial::GeoCalculator"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#public-static-attributes","text":"Type Name constexpr real EPSILON = = 1.0e-5","title":"Public Static Attributes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#public-static-functions","text":"Type Name real CalculateArea (const Vector < real, 3 > & normal, const std::vector< int > & nodeIdxs, const std::unordered_map< int, Node > & nodes) Calculates the plane(2d or 3d) area. Coordinate CalculateCellCentroid (int cellIdx, const Mesh & mesh) real CalculateCellVolume (int cellIdx, const Mesh & mesh) Coordinate CalculateCentroid (const std::vector< int > & nodeIdxs, const std::unordered_map< int, Node > & nodes) Calculates the centroid. real CalculateFaceArea (int faceIdx, const Mesh & mesh) Coordinate CalculateFaceCentroid (int faceIdx, const Mesh & mesh) std::array< real, 3 > CalculateFaceNormal (int faceIdx, const Mesh & mesh) real CalculateFacePerimeter (int faceIdx, const Mesh & mesh) real CalculateLength (const Node & node0, const Node & node1) Calculates the distance between two Nodes. std::array< real, 3 > CalculateNormal (const std::vector< int > & nodeIdxs, const std::unordered_map< int, Node > & nodes) Calculates the plane(2d or 3d) unit normal vector. real CalculateVolume (const std::vector< int > & nodeIdxs, const std::unordered_map< int, Node > & nodes) Calculates the volume of a polygon pyramid. std::vector< int > GetCellNodeIndexes (int cellIdx, const Mesh & mesh) std::vector< int > SortFaceNodes (int faceIndex, const Mesh & mesh) std::vector< int > SortNodes (const std::vector< int > & nodeIdxs, const std::unordered_map< int, Node > & nodes) Sortes the specified Nodes counterclockwise.","title":"Public Static Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#variable-epsilon","text":"constexpr real OpenOasis :: CommImp :: Spatial :: GeoCalculator :: EPSILON ;","title":"variable EPSILON"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#function-calculatearea","text":"Calculates the plane(2d or 3d) area. static real OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateArea ( const Vector < real , 3 > & normal , const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ) Parameters: normal The unit normal vector of the plane. nodeIdxs The clock- or counter- clockwise ordered Node indexes. nodes The Node map. Returns: Area of the plane.","title":"function CalculateArea"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#function-calculatecellcentroid","text":"static Coordinate OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateCellCentroid ( int cellIdx , const Mesh & mesh )","title":"function CalculateCellCentroid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#function-calculatecellvolume","text":"static real OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateCellVolume ( int cellIdx , const Mesh & mesh )","title":"function CalculateCellVolume"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#function-calculatecentroid","text":"Calculates the centroid. static Coordinate OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateCentroid ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ) Parameters: nodeIdxs Node indexes. nodes The Nodes map. Returns: Centroid.","title":"function CalculateCentroid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#function-calculatefacearea","text":"static real OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateFaceArea ( int faceIdx , const Mesh & mesh )","title":"function CalculateFaceArea"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#function-calculatefacecentroid","text":"static Coordinate OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateFaceCentroid ( int faceIdx , const Mesh & mesh )","title":"function CalculateFaceCentroid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#function-calculatefacenormal","text":"static std :: array < real , 3 > OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateFaceNormal ( int faceIdx , const Mesh & mesh )","title":"function CalculateFaceNormal"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#function-calculatefaceperimeter","text":"static real OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateFacePerimeter ( int faceIdx , const Mesh & mesh )","title":"function CalculateFacePerimeter"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#function-calculatelength","text":"Calculates the distance between two Nodes. static real OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateLength ( const Node & node0 , const Node & node1 ) Parameters: node0 The endpoint. node1 The endpoint. Returns: The length.","title":"function CalculateLength"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#function-calculatenormal","text":"Calculates the plane(2d or 3d) unit normal vector. static std :: array < real , 3 > OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateNormal ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ) Parameters: nodeIdxs The clock- or counter- clockwise ordered Node indexes. nodes The Nodes map. Returns: Unit normal vector.","title":"function CalculateNormal"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#function-calculatevolume","text":"Calculates the volume of a polygon pyramid. static real OpenOasis :: CommImp :: Spatial :: GeoCalculator :: CalculateVolume ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ) Parameters: nodeIdxs The Node indexes. nodes The Node map. Returns: Volume.","title":"function CalculateVolume"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#function-getcellnodeindexes","text":"static std :: vector < int > OpenOasis :: CommImp :: Spatial :: GeoCalculator :: GetCellNodeIndexes ( int cellIdx , const Mesh & mesh )","title":"function GetCellNodeIndexes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#function-sortfacenodes","text":"static std :: vector < int > OpenOasis :: CommImp :: Spatial :: GeoCalculator :: SortFaceNodes ( int faceIndex , const Mesh & mesh )","title":"function SortFaceNodes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_geo_calculator/#function-sortnodes","text":"Sortes the specified Nodes counterclockwise. static std :: vector < int > OpenOasis :: CommImp :: Spatial :: GeoCalculator :: SortNodes ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ) Parameters: nodeIdxs The Node indexes. nodes The Nodes map. Returns: The sorted Node indexes. The documentation for this class was generated from the following file Models/CommImp/Spatial/GeoCalculator.h","title":"function SortNodes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/","text":"Class OpenOasis::CommImp::Spatial::Grid \u00b6 ClassList > OpenOasis > CommImp > Spatial > Grid Grid encapsulate the mesh data for numerical calculation. #include <Grid.h> Inherited by the following classes: OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D Public Functions \u00b6 Type Name virtual void Activate () Activate the mesh to extract topological information needed for various numerical calculations. const std::vector< int > & GetBoundaryCellIndexes () const double GetBoundaryCenterDistance (int cellIdx, int boundaryFaceIdx) const const MultiIndexMap< double > & GetBoundaryCenterDistances () const const std::vector< int > & GetBoundaryFaceIndexes () const const Cell & GetCell (int cellIndex) const double GetCellCenterDistance (int cellIdx, int neighborCellIdx) const const MultiIndexMap< double > & GetCellCenterDistances () const const MultiIndexMap< double > & GetCellWeightAtFace () const double GetCellWeightAtFace (int cellIdx, int faceIdx) const const Face & GetFace (int faceIndex) const const std::unordered_map< int, Vector < double > > & GetFaceCorrectionVector () const const Vector < double > & GetFaceCorrectionVector (int faceIdx) const const Node & GetNode (int nodeIndex) const int GetNumCells () const int GetNumFaces () const int GetNumNodes () const std::vector< int > GetPatchFaceIndexes (const std::string & patchId) const std::vector< std::string > GetPatchIds () const int GetRawNumCells () const int GetRawNumFaces () const int GetRawNumNodes () const std::vector< int > GetZoneCellIndexes (const std::string & zoneId) const std::vector< std::string > GetZoneIds () const Grid (const std::shared_ptr< Grid > & grid) Grid (std::unordered_map< int, Coordinate > & nodeCoords, std::unordered_map< int, Coordinate > & faceCoords, std::unordered_map< int, Coordinate > & cellCoords, std::unordered_map< int, std::vector< int > > & faceNodes, std::unordered_map< int, std::vector< int > > & cellFaces, std::unordered_map< std::string, std::vector< int > > & patches, std::unordered_map< std::string, std::vector< int > > & zones) virtual void RefineCell (int cellIndex) = 0 Refine the cell at the given index for adaptive grid. virtual void RelaxCell (int cellIndex) = 0 Relax the cell at the given index for adaptive grid. virtual int Type () const = 0 Get the grid type. virtual ~Grid () = default Protected Attributes \u00b6 Type Name std::vector< int > mBoundaryCells MultiIndexMap< double > mBoundaryCenterDists std::vector< int > mBoundaryFaces MultiIndexMap< double > mCellFaceWeight MultiIndexMap< double > mCenterDists std::unordered_map< int, Vector < double > > mFaceCorrVecs std::unordered_map< int, Coordinate > mFaceIntersection Mesh mMesh std::unordered_map< std::string, std::vector< int > > mPatches int mRawCellsNum int mRawFacesNum int mRawNodesNum std::unordered_map< std::string, std::vector< int > > mZoneCells std::unordered_map< std::string, std::vector< int > > mZones Protected Functions \u00b6 Type Name virtual void CalculateBoundaryCenterDistances () virtual void CalculateCellDistances () virtual void CalculateCellSurface () virtual void CalculateCellVolume () double CalculateDistance (const Coordinate & n1, const Coordinate & n2) const virtual void CalculateFaceArea () virtual void CalculateFaceCorrectionVector () virtual void CalculateFaceDirector () virtual void CalculateFaceIntersections () virtual void CalculateFaceNormal () virtual void CalculateFacePerimeter () virtual void CalculateFaceWeights () virtual void CheckMesh () const virtual void CollectBoundaryFacesAndCells () virtual void CollectCellNeighbors () virtual void CollectCellsInZone () virtual void CollectCellsSharedFace () virtual void CollectCellsSharedNode () virtual void CollectFacesSharedNode () virtual void SortNodes () Public Functions Documentation \u00b6 function Activate \u00b6 virtual void OpenOasis :: CommImp :: Spatial :: Grid :: Activate () function GetBoundaryCellIndexes \u00b6 const std :: vector < int > & OpenOasis :: CommImp :: Spatial :: Grid :: GetBoundaryCellIndexes () const function GetBoundaryCenterDistance \u00b6 double OpenOasis :: CommImp :: Spatial :: Grid :: GetBoundaryCenterDistance ( int cellIdx , int boundaryFaceIdx ) const function GetBoundaryCenterDistances \u00b6 const MultiIndexMap < double > & OpenOasis :: CommImp :: Spatial :: Grid :: GetBoundaryCenterDistances () const function GetBoundaryFaceIndexes \u00b6 const std :: vector < int > & OpenOasis :: CommImp :: Spatial :: Grid :: GetBoundaryFaceIndexes () const function GetCell \u00b6 const Cell & OpenOasis :: CommImp :: Spatial :: Grid :: GetCell ( int cellIndex ) const function GetCellCenterDistance \u00b6 double OpenOasis :: CommImp :: Spatial :: Grid :: GetCellCenterDistance ( int cellIdx , int neighborCellIdx ) const function GetCellCenterDistances \u00b6 const MultiIndexMap < double > & OpenOasis :: CommImp :: Spatial :: Grid :: GetCellCenterDistances () const function GetCellWeightAtFace [\u00bd] \u00b6 const MultiIndexMap < double > & OpenOasis :: CommImp :: Spatial :: Grid :: GetCellWeightAtFace () const function GetCellWeightAtFace [2/2] \u00b6 double OpenOasis :: CommImp :: Spatial :: Grid :: GetCellWeightAtFace ( int cellIdx , int faceIdx ) const function GetFace \u00b6 const Face & OpenOasis :: CommImp :: Spatial :: Grid :: GetFace ( int faceIndex ) const function GetFaceCorrectionVector [\u00bd] \u00b6 const std :: unordered_map < int , Vector < double > > & OpenOasis :: CommImp :: Spatial :: Grid :: GetFaceCorrectionVector () const function GetFaceCorrectionVector [2/2] \u00b6 const Vector < double > & OpenOasis :: CommImp :: Spatial :: Grid :: GetFaceCorrectionVector ( int faceIdx ) const function GetNode \u00b6 const Node & OpenOasis :: CommImp :: Spatial :: Grid :: GetNode ( int nodeIndex ) const function GetNumCells \u00b6 int OpenOasis :: CommImp :: Spatial :: Grid :: GetNumCells () const function GetNumFaces \u00b6 int OpenOasis :: CommImp :: Spatial :: Grid :: GetNumFaces () const function GetNumNodes \u00b6 int OpenOasis :: CommImp :: Spatial :: Grid :: GetNumNodes () const function GetPatchFaceIndexes \u00b6 std :: vector < int > OpenOasis :: CommImp :: Spatial :: Grid :: GetPatchFaceIndexes ( const std :: string & patchId ) const function GetPatchIds \u00b6 std :: vector < std :: string > OpenOasis :: CommImp :: Spatial :: Grid :: GetPatchIds () const function GetRawNumCells \u00b6 int OpenOasis :: CommImp :: Spatial :: Grid :: GetRawNumCells () const function GetRawNumFaces \u00b6 int OpenOasis :: CommImp :: Spatial :: Grid :: GetRawNumFaces () const function GetRawNumNodes \u00b6 int OpenOasis :: CommImp :: Spatial :: Grid :: GetRawNumNodes () const function GetZoneCellIndexes \u00b6 std :: vector < int > OpenOasis :: CommImp :: Spatial :: Grid :: GetZoneCellIndexes ( const std :: string & zoneId ) const function GetZoneIds \u00b6 std :: vector < std :: string > OpenOasis :: CommImp :: Spatial :: Grid :: GetZoneIds () const function Grid [\u00bd] \u00b6 OpenOasis :: CommImp :: Spatial :: Grid :: Grid ( const std :: shared_ptr < Grid > & grid ) function Grid [2/2] \u00b6 OpenOasis :: CommImp :: Spatial :: Grid :: Grid ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int > > & faceNodes , std :: unordered_map < int , std :: vector < int > > & cellFaces , std :: unordered_map < std :: string , std :: vector < int > > & patches , std :: unordered_map < std :: string , std :: vector < int > > & zones ) function RefineCell \u00b6 Refine the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid :: RefineCell ( int cellIndex ) = 0 Note: The refining wouldn't change the origin nodes. function RelaxCell \u00b6 Relax the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid :: RelaxCell ( int cellIndex ) = 0 Note: The coarsening wouldn't change the origin nodes. function Type \u00b6 Get the grid type. virtual int OpenOasis :: CommImp :: Spatial :: Grid :: Type () const = 0 Returns: Return 1, for 1d grid; 2, for 2d; 3, for 3d; others, for invalid type. function ~Grid \u00b6 virtual OpenOasis :: CommImp :: Spatial :: Grid ::~ Grid () = default Protected Attributes Documentation \u00b6 variable mBoundaryCells \u00b6 std :: vector < int > OpenOasis :: CommImp :: Spatial :: Grid :: mBoundaryCells ; variable mBoundaryCenterDists \u00b6 MultiIndexMap < double > OpenOasis :: CommImp :: Spatial :: Grid :: mBoundaryCenterDists ; variable mBoundaryFaces \u00b6 std :: vector < int > OpenOasis :: CommImp :: Spatial :: Grid :: mBoundaryFaces ; variable mCellFaceWeight \u00b6 MultiIndexMap < double > OpenOasis :: CommImp :: Spatial :: Grid :: mCellFaceWeight ; variable mCenterDists \u00b6 MultiIndexMap < double > OpenOasis :: CommImp :: Spatial :: Grid :: mCenterDists ; variable mFaceCorrVecs \u00b6 std :: unordered_map < int , Vector < double > > OpenOasis :: CommImp :: Spatial :: Grid :: mFaceCorrVecs ; variable mFaceIntersection \u00b6 std :: unordered_map < int , Coordinate > OpenOasis :: CommImp :: Spatial :: Grid :: mFaceIntersection ; variable mMesh \u00b6 Mesh OpenOasis :: CommImp :: Spatial :: Grid :: mMesh ; variable mPatches \u00b6 std :: unordered_map < std :: string , std :: vector < int > > OpenOasis :: CommImp :: Spatial :: Grid :: mPatches ; variable mRawCellsNum \u00b6 int OpenOasis :: CommImp :: Spatial :: Grid :: mRawCellsNum ; variable mRawFacesNum \u00b6 int OpenOasis :: CommImp :: Spatial :: Grid :: mRawFacesNum ; variable mRawNodesNum \u00b6 int OpenOasis :: CommImp :: Spatial :: Grid :: mRawNodesNum ; variable mZoneCells \u00b6 std :: unordered_map < std :: string , std :: vector < int > > OpenOasis :: CommImp :: Spatial :: Grid :: mZoneCells ; variable mZones \u00b6 std :: unordered_map < std :: string , std :: vector < int > > OpenOasis :: CommImp :: Spatial :: Grid :: mZones ; Protected Functions Documentation \u00b6 function CalculateBoundaryCenterDistances \u00b6 virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateBoundaryCenterDistances () function CalculateCellDistances \u00b6 virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateCellDistances () function CalculateCellSurface \u00b6 inline virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateCellSurface () function CalculateCellVolume \u00b6 inline virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateCellVolume () function CalculateDistance \u00b6 inline double OpenOasis :: CommImp :: Spatial :: Grid :: CalculateDistance ( const Coordinate & n1 , const Coordinate & n2 ) const function CalculateFaceArea \u00b6 inline virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateFaceArea () function CalculateFaceCorrectionVector \u00b6 virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateFaceCorrectionVector () function CalculateFaceDirector \u00b6 virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateFaceDirector () function CalculateFaceIntersections \u00b6 virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateFaceIntersections () function CalculateFaceNormal \u00b6 inline virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateFaceNormal () function CalculateFacePerimeter \u00b6 inline virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateFacePerimeter () function CalculateFaceWeights \u00b6 virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateFaceWeights () function CheckMesh \u00b6 virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CheckMesh () const function CollectBoundaryFacesAndCells \u00b6 virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CollectBoundaryFacesAndCells () function CollectCellNeighbors \u00b6 virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CollectCellNeighbors () function CollectCellsInZone \u00b6 inline virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CollectCellsInZone () function CollectCellsSharedFace \u00b6 virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CollectCellsSharedFace () function CollectCellsSharedNode \u00b6 virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CollectCellsSharedNode () function CollectFacesSharedNode \u00b6 virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CollectFacesSharedNode () function SortNodes \u00b6 virtual void OpenOasis :: CommImp :: Spatial :: Grid :: SortNodes () The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid.h","title":"Class OpenOasis::CommImp::Spatial::Grid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#class-openoasiscommimpspatialgrid","text":"ClassList > OpenOasis > CommImp > Spatial > Grid Grid encapsulate the mesh data for numerical calculation. #include <Grid.h> Inherited by the following classes: OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D","title":"Class OpenOasis::CommImp::Spatial::Grid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#public-functions","text":"Type Name virtual void Activate () Activate the mesh to extract topological information needed for various numerical calculations. const std::vector< int > & GetBoundaryCellIndexes () const double GetBoundaryCenterDistance (int cellIdx, int boundaryFaceIdx) const const MultiIndexMap< double > & GetBoundaryCenterDistances () const const std::vector< int > & GetBoundaryFaceIndexes () const const Cell & GetCell (int cellIndex) const double GetCellCenterDistance (int cellIdx, int neighborCellIdx) const const MultiIndexMap< double > & GetCellCenterDistances () const const MultiIndexMap< double > & GetCellWeightAtFace () const double GetCellWeightAtFace (int cellIdx, int faceIdx) const const Face & GetFace (int faceIndex) const const std::unordered_map< int, Vector < double > > & GetFaceCorrectionVector () const const Vector < double > & GetFaceCorrectionVector (int faceIdx) const const Node & GetNode (int nodeIndex) const int GetNumCells () const int GetNumFaces () const int GetNumNodes () const std::vector< int > GetPatchFaceIndexes (const std::string & patchId) const std::vector< std::string > GetPatchIds () const int GetRawNumCells () const int GetRawNumFaces () const int GetRawNumNodes () const std::vector< int > GetZoneCellIndexes (const std::string & zoneId) const std::vector< std::string > GetZoneIds () const Grid (const std::shared_ptr< Grid > & grid) Grid (std::unordered_map< int, Coordinate > & nodeCoords, std::unordered_map< int, Coordinate > & faceCoords, std::unordered_map< int, Coordinate > & cellCoords, std::unordered_map< int, std::vector< int > > & faceNodes, std::unordered_map< int, std::vector< int > > & cellFaces, std::unordered_map< std::string, std::vector< int > > & patches, std::unordered_map< std::string, std::vector< int > > & zones) virtual void RefineCell (int cellIndex) = 0 Refine the cell at the given index for adaptive grid. virtual void RelaxCell (int cellIndex) = 0 Relax the cell at the given index for adaptive grid. virtual int Type () const = 0 Get the grid type. virtual ~Grid () = default","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#protected-attributes","text":"Type Name std::vector< int > mBoundaryCells MultiIndexMap< double > mBoundaryCenterDists std::vector< int > mBoundaryFaces MultiIndexMap< double > mCellFaceWeight MultiIndexMap< double > mCenterDists std::unordered_map< int, Vector < double > > mFaceCorrVecs std::unordered_map< int, Coordinate > mFaceIntersection Mesh mMesh std::unordered_map< std::string, std::vector< int > > mPatches int mRawCellsNum int mRawFacesNum int mRawNodesNum std::unordered_map< std::string, std::vector< int > > mZoneCells std::unordered_map< std::string, std::vector< int > > mZones","title":"Protected Attributes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#protected-functions","text":"Type Name virtual void CalculateBoundaryCenterDistances () virtual void CalculateCellDistances () virtual void CalculateCellSurface () virtual void CalculateCellVolume () double CalculateDistance (const Coordinate & n1, const Coordinate & n2) const virtual void CalculateFaceArea () virtual void CalculateFaceCorrectionVector () virtual void CalculateFaceDirector () virtual void CalculateFaceIntersections () virtual void CalculateFaceNormal () virtual void CalculateFacePerimeter () virtual void CalculateFaceWeights () virtual void CheckMesh () const virtual void CollectBoundaryFacesAndCells () virtual void CollectCellNeighbors () virtual void CollectCellsInZone () virtual void CollectCellsSharedFace () virtual void CollectCellsSharedNode () virtual void CollectFacesSharedNode () virtual void SortNodes ()","title":"Protected Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-activate","text":"virtual void OpenOasis :: CommImp :: Spatial :: Grid :: Activate ()","title":"function Activate"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getboundarycellindexes","text":"const std :: vector < int > & OpenOasis :: CommImp :: Spatial :: Grid :: GetBoundaryCellIndexes () const","title":"function GetBoundaryCellIndexes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getboundarycenterdistance","text":"double OpenOasis :: CommImp :: Spatial :: Grid :: GetBoundaryCenterDistance ( int cellIdx , int boundaryFaceIdx ) const","title":"function GetBoundaryCenterDistance"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getboundarycenterdistances","text":"const MultiIndexMap < double > & OpenOasis :: CommImp :: Spatial :: Grid :: GetBoundaryCenterDistances () const","title":"function GetBoundaryCenterDistances"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getboundaryfaceindexes","text":"const std :: vector < int > & OpenOasis :: CommImp :: Spatial :: Grid :: GetBoundaryFaceIndexes () const","title":"function GetBoundaryFaceIndexes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getcell","text":"const Cell & OpenOasis :: CommImp :: Spatial :: Grid :: GetCell ( int cellIndex ) const","title":"function GetCell"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getcellcenterdistance","text":"double OpenOasis :: CommImp :: Spatial :: Grid :: GetCellCenterDistance ( int cellIdx , int neighborCellIdx ) const","title":"function GetCellCenterDistance"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getcellcenterdistances","text":"const MultiIndexMap < double > & OpenOasis :: CommImp :: Spatial :: Grid :: GetCellCenterDistances () const","title":"function GetCellCenterDistances"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getcellweightatface-12","text":"const MultiIndexMap < double > & OpenOasis :: CommImp :: Spatial :: Grid :: GetCellWeightAtFace () const","title":"function GetCellWeightAtFace [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getcellweightatface-22","text":"double OpenOasis :: CommImp :: Spatial :: Grid :: GetCellWeightAtFace ( int cellIdx , int faceIdx ) const","title":"function GetCellWeightAtFace [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getface","text":"const Face & OpenOasis :: CommImp :: Spatial :: Grid :: GetFace ( int faceIndex ) const","title":"function GetFace"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getfacecorrectionvector-12","text":"const std :: unordered_map < int , Vector < double > > & OpenOasis :: CommImp :: Spatial :: Grid :: GetFaceCorrectionVector () const","title":"function GetFaceCorrectionVector [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getfacecorrectionvector-22","text":"const Vector < double > & OpenOasis :: CommImp :: Spatial :: Grid :: GetFaceCorrectionVector ( int faceIdx ) const","title":"function GetFaceCorrectionVector [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getnode","text":"const Node & OpenOasis :: CommImp :: Spatial :: Grid :: GetNode ( int nodeIndex ) const","title":"function GetNode"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getnumcells","text":"int OpenOasis :: CommImp :: Spatial :: Grid :: GetNumCells () const","title":"function GetNumCells"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getnumfaces","text":"int OpenOasis :: CommImp :: Spatial :: Grid :: GetNumFaces () const","title":"function GetNumFaces"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getnumnodes","text":"int OpenOasis :: CommImp :: Spatial :: Grid :: GetNumNodes () const","title":"function GetNumNodes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getpatchfaceindexes","text":"std :: vector < int > OpenOasis :: CommImp :: Spatial :: Grid :: GetPatchFaceIndexes ( const std :: string & patchId ) const","title":"function GetPatchFaceIndexes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getpatchids","text":"std :: vector < std :: string > OpenOasis :: CommImp :: Spatial :: Grid :: GetPatchIds () const","title":"function GetPatchIds"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getrawnumcells","text":"int OpenOasis :: CommImp :: Spatial :: Grid :: GetRawNumCells () const","title":"function GetRawNumCells"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getrawnumfaces","text":"int OpenOasis :: CommImp :: Spatial :: Grid :: GetRawNumFaces () const","title":"function GetRawNumFaces"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getrawnumnodes","text":"int OpenOasis :: CommImp :: Spatial :: Grid :: GetRawNumNodes () const","title":"function GetRawNumNodes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getzonecellindexes","text":"std :: vector < int > OpenOasis :: CommImp :: Spatial :: Grid :: GetZoneCellIndexes ( const std :: string & zoneId ) const","title":"function GetZoneCellIndexes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-getzoneids","text":"std :: vector < std :: string > OpenOasis :: CommImp :: Spatial :: Grid :: GetZoneIds () const","title":"function GetZoneIds"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-grid-12","text":"OpenOasis :: CommImp :: Spatial :: Grid :: Grid ( const std :: shared_ptr < Grid > & grid )","title":"function Grid [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-grid-22","text":"OpenOasis :: CommImp :: Spatial :: Grid :: Grid ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int > > & faceNodes , std :: unordered_map < int , std :: vector < int > > & cellFaces , std :: unordered_map < std :: string , std :: vector < int > > & patches , std :: unordered_map < std :: string , std :: vector < int > > & zones )","title":"function Grid [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-refinecell","text":"Refine the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid :: RefineCell ( int cellIndex ) = 0 Note: The refining wouldn't change the origin nodes.","title":"function RefineCell"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-relaxcell","text":"Relax the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid :: RelaxCell ( int cellIndex ) = 0 Note: The coarsening wouldn't change the origin nodes.","title":"function RelaxCell"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-type","text":"Get the grid type. virtual int OpenOasis :: CommImp :: Spatial :: Grid :: Type () const = 0 Returns: Return 1, for 1d grid; 2, for 2d; 3, for 3d; others, for invalid type.","title":"function Type"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-grid","text":"virtual OpenOasis :: CommImp :: Spatial :: Grid ::~ Grid () = default","title":"function ~Grid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#variable-mboundarycells","text":"std :: vector < int > OpenOasis :: CommImp :: Spatial :: Grid :: mBoundaryCells ;","title":"variable mBoundaryCells"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#variable-mboundarycenterdists","text":"MultiIndexMap < double > OpenOasis :: CommImp :: Spatial :: Grid :: mBoundaryCenterDists ;","title":"variable mBoundaryCenterDists"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#variable-mboundaryfaces","text":"std :: vector < int > OpenOasis :: CommImp :: Spatial :: Grid :: mBoundaryFaces ;","title":"variable mBoundaryFaces"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#variable-mcellfaceweight","text":"MultiIndexMap < double > OpenOasis :: CommImp :: Spatial :: Grid :: mCellFaceWeight ;","title":"variable mCellFaceWeight"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#variable-mcenterdists","text":"MultiIndexMap < double > OpenOasis :: CommImp :: Spatial :: Grid :: mCenterDists ;","title":"variable mCenterDists"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#variable-mfacecorrvecs","text":"std :: unordered_map < int , Vector < double > > OpenOasis :: CommImp :: Spatial :: Grid :: mFaceCorrVecs ;","title":"variable mFaceCorrVecs"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#variable-mfaceintersection","text":"std :: unordered_map < int , Coordinate > OpenOasis :: CommImp :: Spatial :: Grid :: mFaceIntersection ;","title":"variable mFaceIntersection"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#variable-mmesh","text":"Mesh OpenOasis :: CommImp :: Spatial :: Grid :: mMesh ;","title":"variable mMesh"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#variable-mpatches","text":"std :: unordered_map < std :: string , std :: vector < int > > OpenOasis :: CommImp :: Spatial :: Grid :: mPatches ;","title":"variable mPatches"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#variable-mrawcellsnum","text":"int OpenOasis :: CommImp :: Spatial :: Grid :: mRawCellsNum ;","title":"variable mRawCellsNum"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#variable-mrawfacesnum","text":"int OpenOasis :: CommImp :: Spatial :: Grid :: mRawFacesNum ;","title":"variable mRawFacesNum"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#variable-mrawnodesnum","text":"int OpenOasis :: CommImp :: Spatial :: Grid :: mRawNodesNum ;","title":"variable mRawNodesNum"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#variable-mzonecells","text":"std :: unordered_map < std :: string , std :: vector < int > > OpenOasis :: CommImp :: Spatial :: Grid :: mZoneCells ;","title":"variable mZoneCells"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#variable-mzones","text":"std :: unordered_map < std :: string , std :: vector < int > > OpenOasis :: CommImp :: Spatial :: Grid :: mZones ;","title":"variable mZones"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-calculateboundarycenterdistances","text":"virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateBoundaryCenterDistances ()","title":"function CalculateBoundaryCenterDistances"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-calculatecelldistances","text":"virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateCellDistances ()","title":"function CalculateCellDistances"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-calculatecellsurface","text":"inline virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateCellSurface ()","title":"function CalculateCellSurface"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-calculatecellvolume","text":"inline virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateCellVolume ()","title":"function CalculateCellVolume"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-calculatedistance","text":"inline double OpenOasis :: CommImp :: Spatial :: Grid :: CalculateDistance ( const Coordinate & n1 , const Coordinate & n2 ) const","title":"function CalculateDistance"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-calculatefacearea","text":"inline virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateFaceArea ()","title":"function CalculateFaceArea"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-calculatefacecorrectionvector","text":"virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateFaceCorrectionVector ()","title":"function CalculateFaceCorrectionVector"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-calculatefacedirector","text":"virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateFaceDirector ()","title":"function CalculateFaceDirector"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-calculatefaceintersections","text":"virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateFaceIntersections ()","title":"function CalculateFaceIntersections"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-calculatefacenormal","text":"inline virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateFaceNormal ()","title":"function CalculateFaceNormal"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-calculatefaceperimeter","text":"inline virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateFacePerimeter ()","title":"function CalculateFacePerimeter"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-calculatefaceweights","text":"virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CalculateFaceWeights ()","title":"function CalculateFaceWeights"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-checkmesh","text":"virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CheckMesh () const","title":"function CheckMesh"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-collectboundaryfacesandcells","text":"virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CollectBoundaryFacesAndCells ()","title":"function CollectBoundaryFacesAndCells"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-collectcellneighbors","text":"virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CollectCellNeighbors ()","title":"function CollectCellNeighbors"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-collectcellsinzone","text":"inline virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CollectCellsInZone ()","title":"function CollectCellsInZone"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-collectcellssharedface","text":"virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CollectCellsSharedFace ()","title":"function CollectCellsSharedFace"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-collectcellssharednode","text":"virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CollectCellsSharedNode ()","title":"function CollectCellsSharedNode"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-collectfacessharednode","text":"virtual void OpenOasis :: CommImp :: Spatial :: Grid :: CollectFacesSharedNode ()","title":"function CollectFacesSharedNode"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid/#function-sortnodes","text":"virtual void OpenOasis :: CommImp :: Spatial :: Grid :: SortNodes () The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid.h","title":"function SortNodes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid1_d/","text":"Class OpenOasis::CommImp::Spatial::Grid1D \u00b6 ClassList > OpenOasis > CommImp > Spatial > Grid1D Inherits the following classes: OpenOasis::CommImp::Spatial::Grid Public Functions \u00b6 Type Name Grid1D (const std::shared_ptr< Grid > & grid) Grid1D (std::unordered_map< int, Coordinate > & nodeCoords, std::unordered_map< int, Coordinate > & faceCoords, std::unordered_map< int, Coordinate > & cellCoords, std::unordered_map< int, std::vector< int > > & faceNodes, std::unordered_map< int, std::vector< int > > & cellFaces, std::unordered_map< std::string, std::vector< int > > & patches, std::unordered_map< std::string, std::vector< int > > & zones) virtual void RefineCell (int cellIndex) override Refine the cell at the given index for adaptive grid. virtual void RelaxCell (int cellIndex) override Relax the cell at the given index for adaptive grid. virtual int Type () override const Get the grid type. virtual ~Grid1D () = default Public Functions inherited from OpenOasis::CommImp::Spatial::Grid \u00b6 See OpenOasis::CommImp::Spatial::Grid Type Name virtual void Activate () Activate the mesh to extract topological information needed for various numerical calculations. const std::vector< int > & GetBoundaryCellIndexes () const double GetBoundaryCenterDistance (int cellIdx, int boundaryFaceIdx) const const MultiIndexMap< double > & GetBoundaryCenterDistances () const const std::vector< int > & GetBoundaryFaceIndexes () const const Cell & GetCell (int cellIndex) const double GetCellCenterDistance (int cellIdx, int neighborCellIdx) const const MultiIndexMap< double > & GetCellCenterDistances () const const MultiIndexMap< double > & GetCellWeightAtFace () const double GetCellWeightAtFace (int cellIdx, int faceIdx) const const Face & GetFace (int faceIndex) const const std::unordered_map< int, Vector < double > > & GetFaceCorrectionVector () const const Vector < double > & GetFaceCorrectionVector (int faceIdx) const const Node & GetNode (int nodeIndex) const int GetNumCells () const int GetNumFaces () const int GetNumNodes () const std::vector< int > GetPatchFaceIndexes (const std::string & patchId) const std::vector< std::string > GetPatchIds () const int GetRawNumCells () const int GetRawNumFaces () const int GetRawNumNodes () const std::vector< int > GetZoneCellIndexes (const std::string & zoneId) const std::vector< std::string > GetZoneIds () const Grid (const std::shared_ptr< Grid > & grid) Grid (std::unordered_map< int, Coordinate > & nodeCoords, std::unordered_map< int, Coordinate > & faceCoords, std::unordered_map< int, Coordinate > & cellCoords, std::unordered_map< int, std::vector< int > > & faceNodes, std::unordered_map< int, std::vector< int > > & cellFaces, std::unordered_map< std::string, std::vector< int > > & patches, std::unordered_map< std::string, std::vector< int > > & zones) virtual void RefineCell (int cellIndex) = 0 Refine the cell at the given index for adaptive grid. virtual void RelaxCell (int cellIndex) = 0 Relax the cell at the given index for adaptive grid. virtual int Type () const = 0 Get the grid type. virtual ~Grid () = default Protected Attributes inherited from OpenOasis::CommImp::Spatial::Grid \u00b6 See OpenOasis::CommImp::Spatial::Grid Type Name std::vector< int > mBoundaryCells MultiIndexMap< double > mBoundaryCenterDists std::vector< int > mBoundaryFaces MultiIndexMap< double > mCellFaceWeight MultiIndexMap< double > mCenterDists std::unordered_map< int, Vector < double > > mFaceCorrVecs std::unordered_map< int, Coordinate > mFaceIntersection Mesh mMesh std::unordered_map< std::string, std::vector< int > > mPatches int mRawCellsNum int mRawFacesNum int mRawNodesNum std::unordered_map< std::string, std::vector< int > > mZoneCells std::unordered_map< std::string, std::vector< int > > mZones Protected Functions inherited from OpenOasis::CommImp::Spatial::Grid \u00b6 See OpenOasis::CommImp::Spatial::Grid Type Name virtual void CalculateBoundaryCenterDistances () virtual void CalculateCellDistances () virtual void CalculateCellSurface () virtual void CalculateCellVolume () double CalculateDistance (const Coordinate & n1, const Coordinate & n2) const virtual void CalculateFaceArea () virtual void CalculateFaceCorrectionVector () virtual void CalculateFaceDirector () virtual void CalculateFaceIntersections () virtual void CalculateFaceNormal () virtual void CalculateFacePerimeter () virtual void CalculateFaceWeights () virtual void CheckMesh () const virtual void CollectBoundaryFacesAndCells () virtual void CollectCellNeighbors () virtual void CollectCellsInZone () virtual void CollectCellsSharedFace () virtual void CollectCellsSharedNode () virtual void CollectFacesSharedNode () virtual void SortNodes () Public Functions Documentation \u00b6 function Grid1D [\u00bd] \u00b6 OpenOasis :: CommImp :: Spatial :: Grid1D :: Grid1D ( const std :: shared_ptr < Grid > & grid ) function Grid1D [2/2] \u00b6 OpenOasis :: CommImp :: Spatial :: Grid1D :: Grid1D ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int > > & faceNodes , std :: unordered_map < int , std :: vector < int > > & cellFaces , std :: unordered_map < std :: string , std :: vector < int > > & patches , std :: unordered_map < std :: string , std :: vector < int > > & zones ) function RefineCell \u00b6 Refine the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid1D :: RefineCell ( int cellIndex ) override Note: The refining wouldn't change the origin nodes. Implements OpenOasis::CommImp::Spatial::Grid::RefineCell function RelaxCell \u00b6 Relax the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid1D :: RelaxCell ( int cellIndex ) override Note: The coarsening wouldn't change the origin nodes. Implements OpenOasis::CommImp::Spatial::Grid::RelaxCell function Type \u00b6 Get the grid type. virtual int OpenOasis :: CommImp :: Spatial :: Grid1D :: Type () override const Returns: Return 1, for 1d grid; 2, for 2d; 3, for 3d; others, for invalid type. Implements OpenOasis::CommImp::Spatial::Grid::Type function ~Grid1D \u00b6 virtual OpenOasis :: CommImp :: Spatial :: Grid1D ::~ Grid1D () = default The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid1D.h","title":"Class OpenOasis::CommImp::Spatial::Grid1D"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid1_d/#class-openoasiscommimpspatialgrid1d","text":"ClassList > OpenOasis > CommImp > Spatial > Grid1D Inherits the following classes: OpenOasis::CommImp::Spatial::Grid","title":"Class OpenOasis::CommImp::Spatial::Grid1D"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid1_d/#public-functions","text":"Type Name Grid1D (const std::shared_ptr< Grid > & grid) Grid1D (std::unordered_map< int, Coordinate > & nodeCoords, std::unordered_map< int, Coordinate > & faceCoords, std::unordered_map< int, Coordinate > & cellCoords, std::unordered_map< int, std::vector< int > > & faceNodes, std::unordered_map< int, std::vector< int > > & cellFaces, std::unordered_map< std::string, std::vector< int > > & patches, std::unordered_map< std::string, std::vector< int > > & zones) virtual void RefineCell (int cellIndex) override Refine the cell at the given index for adaptive grid. virtual void RelaxCell (int cellIndex) override Relax the cell at the given index for adaptive grid. virtual int Type () override const Get the grid type. virtual ~Grid1D () = default","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid1_d/#public-functions-inherited-from-openoasiscommimpspatialgrid","text":"See OpenOasis::CommImp::Spatial::Grid Type Name virtual void Activate () Activate the mesh to extract topological information needed for various numerical calculations. const std::vector< int > & GetBoundaryCellIndexes () const double GetBoundaryCenterDistance (int cellIdx, int boundaryFaceIdx) const const MultiIndexMap< double > & GetBoundaryCenterDistances () const const std::vector< int > & GetBoundaryFaceIndexes () const const Cell & GetCell (int cellIndex) const double GetCellCenterDistance (int cellIdx, int neighborCellIdx) const const MultiIndexMap< double > & GetCellCenterDistances () const const MultiIndexMap< double > & GetCellWeightAtFace () const double GetCellWeightAtFace (int cellIdx, int faceIdx) const const Face & GetFace (int faceIndex) const const std::unordered_map< int, Vector < double > > & GetFaceCorrectionVector () const const Vector < double > & GetFaceCorrectionVector (int faceIdx) const const Node & GetNode (int nodeIndex) const int GetNumCells () const int GetNumFaces () const int GetNumNodes () const std::vector< int > GetPatchFaceIndexes (const std::string & patchId) const std::vector< std::string > GetPatchIds () const int GetRawNumCells () const int GetRawNumFaces () const int GetRawNumNodes () const std::vector< int > GetZoneCellIndexes (const std::string & zoneId) const std::vector< std::string > GetZoneIds () const Grid (const std::shared_ptr< Grid > & grid) Grid (std::unordered_map< int, Coordinate > & nodeCoords, std::unordered_map< int, Coordinate > & faceCoords, std::unordered_map< int, Coordinate > & cellCoords, std::unordered_map< int, std::vector< int > > & faceNodes, std::unordered_map< int, std::vector< int > > & cellFaces, std::unordered_map< std::string, std::vector< int > > & patches, std::unordered_map< std::string, std::vector< int > > & zones) virtual void RefineCell (int cellIndex) = 0 Refine the cell at the given index for adaptive grid. virtual void RelaxCell (int cellIndex) = 0 Relax the cell at the given index for adaptive grid. virtual int Type () const = 0 Get the grid type. virtual ~Grid () = default","title":"Public Functions inherited from OpenOasis::CommImp::Spatial::Grid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid1_d/#protected-attributes-inherited-from-openoasiscommimpspatialgrid","text":"See OpenOasis::CommImp::Spatial::Grid Type Name std::vector< int > mBoundaryCells MultiIndexMap< double > mBoundaryCenterDists std::vector< int > mBoundaryFaces MultiIndexMap< double > mCellFaceWeight MultiIndexMap< double > mCenterDists std::unordered_map< int, Vector < double > > mFaceCorrVecs std::unordered_map< int, Coordinate > mFaceIntersection Mesh mMesh std::unordered_map< std::string, std::vector< int > > mPatches int mRawCellsNum int mRawFacesNum int mRawNodesNum std::unordered_map< std::string, std::vector< int > > mZoneCells std::unordered_map< std::string, std::vector< int > > mZones","title":"Protected Attributes inherited from OpenOasis::CommImp::Spatial::Grid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid1_d/#protected-functions-inherited-from-openoasiscommimpspatialgrid","text":"See OpenOasis::CommImp::Spatial::Grid Type Name virtual void CalculateBoundaryCenterDistances () virtual void CalculateCellDistances () virtual void CalculateCellSurface () virtual void CalculateCellVolume () double CalculateDistance (const Coordinate & n1, const Coordinate & n2) const virtual void CalculateFaceArea () virtual void CalculateFaceCorrectionVector () virtual void CalculateFaceDirector () virtual void CalculateFaceIntersections () virtual void CalculateFaceNormal () virtual void CalculateFacePerimeter () virtual void CalculateFaceWeights () virtual void CheckMesh () const virtual void CollectBoundaryFacesAndCells () virtual void CollectCellNeighbors () virtual void CollectCellsInZone () virtual void CollectCellsSharedFace () virtual void CollectCellsSharedNode () virtual void CollectFacesSharedNode () virtual void SortNodes ()","title":"Protected Functions inherited from OpenOasis::CommImp::Spatial::Grid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid1_d/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid1_d/#function-grid1d-12","text":"OpenOasis :: CommImp :: Spatial :: Grid1D :: Grid1D ( const std :: shared_ptr < Grid > & grid )","title":"function Grid1D [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid1_d/#function-grid1d-22","text":"OpenOasis :: CommImp :: Spatial :: Grid1D :: Grid1D ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int > > & faceNodes , std :: unordered_map < int , std :: vector < int > > & cellFaces , std :: unordered_map < std :: string , std :: vector < int > > & patches , std :: unordered_map < std :: string , std :: vector < int > > & zones )","title":"function Grid1D [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid1_d/#function-refinecell","text":"Refine the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid1D :: RefineCell ( int cellIndex ) override Note: The refining wouldn't change the origin nodes. Implements OpenOasis::CommImp::Spatial::Grid::RefineCell","title":"function RefineCell"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid1_d/#function-relaxcell","text":"Relax the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid1D :: RelaxCell ( int cellIndex ) override Note: The coarsening wouldn't change the origin nodes. Implements OpenOasis::CommImp::Spatial::Grid::RelaxCell","title":"function RelaxCell"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid1_d/#function-type","text":"Get the grid type. virtual int OpenOasis :: CommImp :: Spatial :: Grid1D :: Type () override const Returns: Return 1, for 1d grid; 2, for 2d; 3, for 3d; others, for invalid type. Implements OpenOasis::CommImp::Spatial::Grid::Type","title":"function Type"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid1_d/#function-grid1d","text":"virtual OpenOasis :: CommImp :: Spatial :: Grid1D ::~ Grid1D () = default The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid1D.h","title":"function ~Grid1D"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid2_d/","text":"Class OpenOasis::CommImp::Spatial::Grid2D \u00b6 ClassList > OpenOasis > CommImp > Spatial > Grid2D Grid formed by flat cells in 2d. #include <Grid2D.h> Inherits the following classes: OpenOasis::CommImp::Spatial::Grid Public Functions \u00b6 Type Name Grid2D (const std::shared_ptr< Grid > & grid) Grid2D (std::unordered_map< int, Coordinate > & nodeCoords, std::unordered_map< int, Coordinate > & faceCoords, std::unordered_map< int, Coordinate > & cellCoords, std::unordered_map< int, std::vector< int > > & faceNodes, std::unordered_map< int, std::vector< int > > & cellFaces, std::unordered_map< std::string, std::vector< int > > & patches, std::unordered_map< std::string, std::vector< int > > & zones) virtual void RefineCell (int cellIndex) override Refine the cell at the given index for adaptive grid. virtual void RelaxCell (int cellIndex) override Relax the cell at the given index for adaptive grid. virtual int Type () override const Get the grid type. virtual ~Grid2D () = default Public Functions inherited from OpenOasis::CommImp::Spatial::Grid \u00b6 See OpenOasis::CommImp::Spatial::Grid Type Name virtual void Activate () Activate the mesh to extract topological information needed for various numerical calculations. const std::vector< int > & GetBoundaryCellIndexes () const double GetBoundaryCenterDistance (int cellIdx, int boundaryFaceIdx) const const MultiIndexMap< double > & GetBoundaryCenterDistances () const const std::vector< int > & GetBoundaryFaceIndexes () const const Cell & GetCell (int cellIndex) const double GetCellCenterDistance (int cellIdx, int neighborCellIdx) const const MultiIndexMap< double > & GetCellCenterDistances () const const MultiIndexMap< double > & GetCellWeightAtFace () const double GetCellWeightAtFace (int cellIdx, int faceIdx) const const Face & GetFace (int faceIndex) const const std::unordered_map< int, Vector < double > > & GetFaceCorrectionVector () const const Vector < double > & GetFaceCorrectionVector (int faceIdx) const const Node & GetNode (int nodeIndex) const int GetNumCells () const int GetNumFaces () const int GetNumNodes () const std::vector< int > GetPatchFaceIndexes (const std::string & patchId) const std::vector< std::string > GetPatchIds () const int GetRawNumCells () const int GetRawNumFaces () const int GetRawNumNodes () const std::vector< int > GetZoneCellIndexes (const std::string & zoneId) const std::vector< std::string > GetZoneIds () const Grid (const std::shared_ptr< Grid > & grid) Grid (std::unordered_map< int, Coordinate > & nodeCoords, std::unordered_map< int, Coordinate > & faceCoords, std::unordered_map< int, Coordinate > & cellCoords, std::unordered_map< int, std::vector< int > > & faceNodes, std::unordered_map< int, std::vector< int > > & cellFaces, std::unordered_map< std::string, std::vector< int > > & patches, std::unordered_map< std::string, std::vector< int > > & zones) virtual void RefineCell (int cellIndex) = 0 Refine the cell at the given index for adaptive grid. virtual void RelaxCell (int cellIndex) = 0 Relax the cell at the given index for adaptive grid. virtual int Type () const = 0 Get the grid type. virtual ~Grid () = default Protected Attributes inherited from OpenOasis::CommImp::Spatial::Grid \u00b6 See OpenOasis::CommImp::Spatial::Grid Type Name std::vector< int > mBoundaryCells MultiIndexMap< double > mBoundaryCenterDists std::vector< int > mBoundaryFaces MultiIndexMap< double > mCellFaceWeight MultiIndexMap< double > mCenterDists std::unordered_map< int, Vector < double > > mFaceCorrVecs std::unordered_map< int, Coordinate > mFaceIntersection Mesh mMesh std::unordered_map< std::string, std::vector< int > > mPatches int mRawCellsNum int mRawFacesNum int mRawNodesNum std::unordered_map< std::string, std::vector< int > > mZoneCells std::unordered_map< std::string, std::vector< int > > mZones Protected Functions inherited from OpenOasis::CommImp::Spatial::Grid \u00b6 See OpenOasis::CommImp::Spatial::Grid Type Name virtual void CalculateBoundaryCenterDistances () virtual void CalculateCellDistances () virtual void CalculateCellSurface () virtual void CalculateCellVolume () double CalculateDistance (const Coordinate & n1, const Coordinate & n2) const virtual void CalculateFaceArea () virtual void CalculateFaceCorrectionVector () virtual void CalculateFaceDirector () virtual void CalculateFaceIntersections () virtual void CalculateFaceNormal () virtual void CalculateFacePerimeter () virtual void CalculateFaceWeights () virtual void CheckMesh () const virtual void CollectBoundaryFacesAndCells () virtual void CollectCellNeighbors () virtual void CollectCellsInZone () virtual void CollectCellsSharedFace () virtual void CollectCellsSharedNode () virtual void CollectFacesSharedNode () virtual void SortNodes () Public Functions Documentation \u00b6 function Grid2D [\u00bd] \u00b6 OpenOasis :: CommImp :: Spatial :: Grid2D :: Grid2D ( const std :: shared_ptr < Grid > & grid ) function Grid2D [2/2] \u00b6 OpenOasis :: CommImp :: Spatial :: Grid2D :: Grid2D ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int > > & faceNodes , std :: unordered_map < int , std :: vector < int > > & cellFaces , std :: unordered_map < std :: string , std :: vector < int > > & patches , std :: unordered_map < std :: string , std :: vector < int > > & zones ) function RefineCell \u00b6 Refine the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid2D :: RefineCell ( int cellIndex ) override Note: The refining wouldn't change the origin nodes. Implements OpenOasis::CommImp::Spatial::Grid::RefineCell function RelaxCell \u00b6 Relax the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid2D :: RelaxCell ( int cellIndex ) override Note: The coarsening wouldn't change the origin nodes. Implements OpenOasis::CommImp::Spatial::Grid::RelaxCell function Type \u00b6 Get the grid type. virtual int OpenOasis :: CommImp :: Spatial :: Grid2D :: Type () override const Returns: Return 1, for 1d grid; 2, for 2d; 3, for 3d; others, for invalid type. Implements OpenOasis::CommImp::Spatial::Grid::Type function ~Grid2D \u00b6 virtual OpenOasis :: CommImp :: Spatial :: Grid2D ::~ Grid2D () = default The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid2D.h","title":"Class OpenOasis::CommImp::Spatial::Grid2D"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid2_d/#class-openoasiscommimpspatialgrid2d","text":"ClassList > OpenOasis > CommImp > Spatial > Grid2D Grid formed by flat cells in 2d. #include <Grid2D.h> Inherits the following classes: OpenOasis::CommImp::Spatial::Grid","title":"Class OpenOasis::CommImp::Spatial::Grid2D"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid2_d/#public-functions","text":"Type Name Grid2D (const std::shared_ptr< Grid > & grid) Grid2D (std::unordered_map< int, Coordinate > & nodeCoords, std::unordered_map< int, Coordinate > & faceCoords, std::unordered_map< int, Coordinate > & cellCoords, std::unordered_map< int, std::vector< int > > & faceNodes, std::unordered_map< int, std::vector< int > > & cellFaces, std::unordered_map< std::string, std::vector< int > > & patches, std::unordered_map< std::string, std::vector< int > > & zones) virtual void RefineCell (int cellIndex) override Refine the cell at the given index for adaptive grid. virtual void RelaxCell (int cellIndex) override Relax the cell at the given index for adaptive grid. virtual int Type () override const Get the grid type. virtual ~Grid2D () = default","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid2_d/#public-functions-inherited-from-openoasiscommimpspatialgrid","text":"See OpenOasis::CommImp::Spatial::Grid Type Name virtual void Activate () Activate the mesh to extract topological information needed for various numerical calculations. const std::vector< int > & GetBoundaryCellIndexes () const double GetBoundaryCenterDistance (int cellIdx, int boundaryFaceIdx) const const MultiIndexMap< double > & GetBoundaryCenterDistances () const const std::vector< int > & GetBoundaryFaceIndexes () const const Cell & GetCell (int cellIndex) const double GetCellCenterDistance (int cellIdx, int neighborCellIdx) const const MultiIndexMap< double > & GetCellCenterDistances () const const MultiIndexMap< double > & GetCellWeightAtFace () const double GetCellWeightAtFace (int cellIdx, int faceIdx) const const Face & GetFace (int faceIndex) const const std::unordered_map< int, Vector < double > > & GetFaceCorrectionVector () const const Vector < double > & GetFaceCorrectionVector (int faceIdx) const const Node & GetNode (int nodeIndex) const int GetNumCells () const int GetNumFaces () const int GetNumNodes () const std::vector< int > GetPatchFaceIndexes (const std::string & patchId) const std::vector< std::string > GetPatchIds () const int GetRawNumCells () const int GetRawNumFaces () const int GetRawNumNodes () const std::vector< int > GetZoneCellIndexes (const std::string & zoneId) const std::vector< std::string > GetZoneIds () const Grid (const std::shared_ptr< Grid > & grid) Grid (std::unordered_map< int, Coordinate > & nodeCoords, std::unordered_map< int, Coordinate > & faceCoords, std::unordered_map< int, Coordinate > & cellCoords, std::unordered_map< int, std::vector< int > > & faceNodes, std::unordered_map< int, std::vector< int > > & cellFaces, std::unordered_map< std::string, std::vector< int > > & patches, std::unordered_map< std::string, std::vector< int > > & zones) virtual void RefineCell (int cellIndex) = 0 Refine the cell at the given index for adaptive grid. virtual void RelaxCell (int cellIndex) = 0 Relax the cell at the given index for adaptive grid. virtual int Type () const = 0 Get the grid type. virtual ~Grid () = default","title":"Public Functions inherited from OpenOasis::CommImp::Spatial::Grid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid2_d/#protected-attributes-inherited-from-openoasiscommimpspatialgrid","text":"See OpenOasis::CommImp::Spatial::Grid Type Name std::vector< int > mBoundaryCells MultiIndexMap< double > mBoundaryCenterDists std::vector< int > mBoundaryFaces MultiIndexMap< double > mCellFaceWeight MultiIndexMap< double > mCenterDists std::unordered_map< int, Vector < double > > mFaceCorrVecs std::unordered_map< int, Coordinate > mFaceIntersection Mesh mMesh std::unordered_map< std::string, std::vector< int > > mPatches int mRawCellsNum int mRawFacesNum int mRawNodesNum std::unordered_map< std::string, std::vector< int > > mZoneCells std::unordered_map< std::string, std::vector< int > > mZones","title":"Protected Attributes inherited from OpenOasis::CommImp::Spatial::Grid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid2_d/#protected-functions-inherited-from-openoasiscommimpspatialgrid","text":"See OpenOasis::CommImp::Spatial::Grid Type Name virtual void CalculateBoundaryCenterDistances () virtual void CalculateCellDistances () virtual void CalculateCellSurface () virtual void CalculateCellVolume () double CalculateDistance (const Coordinate & n1, const Coordinate & n2) const virtual void CalculateFaceArea () virtual void CalculateFaceCorrectionVector () virtual void CalculateFaceDirector () virtual void CalculateFaceIntersections () virtual void CalculateFaceNormal () virtual void CalculateFacePerimeter () virtual void CalculateFaceWeights () virtual void CheckMesh () const virtual void CollectBoundaryFacesAndCells () virtual void CollectCellNeighbors () virtual void CollectCellsInZone () virtual void CollectCellsSharedFace () virtual void CollectCellsSharedNode () virtual void CollectFacesSharedNode () virtual void SortNodes ()","title":"Protected Functions inherited from OpenOasis::CommImp::Spatial::Grid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid2_d/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid2_d/#function-grid2d-12","text":"OpenOasis :: CommImp :: Spatial :: Grid2D :: Grid2D ( const std :: shared_ptr < Grid > & grid )","title":"function Grid2D [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid2_d/#function-grid2d-22","text":"OpenOasis :: CommImp :: Spatial :: Grid2D :: Grid2D ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int > > & faceNodes , std :: unordered_map < int , std :: vector < int > > & cellFaces , std :: unordered_map < std :: string , std :: vector < int > > & patches , std :: unordered_map < std :: string , std :: vector < int > > & zones )","title":"function Grid2D [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid2_d/#function-refinecell","text":"Refine the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid2D :: RefineCell ( int cellIndex ) override Note: The refining wouldn't change the origin nodes. Implements OpenOasis::CommImp::Spatial::Grid::RefineCell","title":"function RefineCell"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid2_d/#function-relaxcell","text":"Relax the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid2D :: RelaxCell ( int cellIndex ) override Note: The coarsening wouldn't change the origin nodes. Implements OpenOasis::CommImp::Spatial::Grid::RelaxCell","title":"function RelaxCell"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid2_d/#function-type","text":"Get the grid type. virtual int OpenOasis :: CommImp :: Spatial :: Grid2D :: Type () override const Returns: Return 1, for 1d grid; 2, for 2d; 3, for 3d; others, for invalid type. Implements OpenOasis::CommImp::Spatial::Grid::Type","title":"function Type"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid2_d/#function-grid2d","text":"virtual OpenOasis :: CommImp :: Spatial :: Grid2D ::~ Grid2D () = default The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid2D.h","title":"function ~Grid2D"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid3_d/","text":"Class OpenOasis::CommImp::Spatial::Grid3D \u00b6 ClassList > OpenOasis > CommImp > Spatial > Grid3D Inherits the following classes: OpenOasis::CommImp::Spatial::Grid Public Functions \u00b6 Type Name Grid3D (const std::shared_ptr< Grid > & grid) Grid3D (std::unordered_map< int, Coordinate > & nodeCoords, std::unordered_map< int, Coordinate > & faceCoords, std::unordered_map< int, Coordinate > & cellCoords, std::unordered_map< int, std::vector< int > > & faceNodes, std::unordered_map< int, std::vector< int > > & cellFaces, std::unordered_map< std::string, std::vector< int > > & patches, std::unordered_map< std::string, std::vector< int > > & zones) virtual void RefineCell (int cellIndex) override Refine the cell at the given index for adaptive grid. virtual void RelaxCell (int cellIndex) override Relax the cell at the given index for adaptive grid. virtual int Type () override const Get the grid type. virtual ~Grid3D () = default Public Functions inherited from OpenOasis::CommImp::Spatial::Grid \u00b6 See OpenOasis::CommImp::Spatial::Grid Type Name virtual void Activate () Activate the mesh to extract topological information needed for various numerical calculations. const std::vector< int > & GetBoundaryCellIndexes () const double GetBoundaryCenterDistance (int cellIdx, int boundaryFaceIdx) const const MultiIndexMap< double > & GetBoundaryCenterDistances () const const std::vector< int > & GetBoundaryFaceIndexes () const const Cell & GetCell (int cellIndex) const double GetCellCenterDistance (int cellIdx, int neighborCellIdx) const const MultiIndexMap< double > & GetCellCenterDistances () const const MultiIndexMap< double > & GetCellWeightAtFace () const double GetCellWeightAtFace (int cellIdx, int faceIdx) const const Face & GetFace (int faceIndex) const const std::unordered_map< int, Vector < double > > & GetFaceCorrectionVector () const const Vector < double > & GetFaceCorrectionVector (int faceIdx) const const Node & GetNode (int nodeIndex) const int GetNumCells () const int GetNumFaces () const int GetNumNodes () const std::vector< int > GetPatchFaceIndexes (const std::string & patchId) const std::vector< std::string > GetPatchIds () const int GetRawNumCells () const int GetRawNumFaces () const int GetRawNumNodes () const std::vector< int > GetZoneCellIndexes (const std::string & zoneId) const std::vector< std::string > GetZoneIds () const Grid (const std::shared_ptr< Grid > & grid) Grid (std::unordered_map< int, Coordinate > & nodeCoords, std::unordered_map< int, Coordinate > & faceCoords, std::unordered_map< int, Coordinate > & cellCoords, std::unordered_map< int, std::vector< int > > & faceNodes, std::unordered_map< int, std::vector< int > > & cellFaces, std::unordered_map< std::string, std::vector< int > > & patches, std::unordered_map< std::string, std::vector< int > > & zones) virtual void RefineCell (int cellIndex) = 0 Refine the cell at the given index for adaptive grid. virtual void RelaxCell (int cellIndex) = 0 Relax the cell at the given index for adaptive grid. virtual int Type () const = 0 Get the grid type. virtual ~Grid () = default Protected Attributes inherited from OpenOasis::CommImp::Spatial::Grid \u00b6 See OpenOasis::CommImp::Spatial::Grid Type Name std::vector< int > mBoundaryCells MultiIndexMap< double > mBoundaryCenterDists std::vector< int > mBoundaryFaces MultiIndexMap< double > mCellFaceWeight MultiIndexMap< double > mCenterDists std::unordered_map< int, Vector < double > > mFaceCorrVecs std::unordered_map< int, Coordinate > mFaceIntersection Mesh mMesh std::unordered_map< std::string, std::vector< int > > mPatches int mRawCellsNum int mRawFacesNum int mRawNodesNum std::unordered_map< std::string, std::vector< int > > mZoneCells std::unordered_map< std::string, std::vector< int > > mZones Protected Functions inherited from OpenOasis::CommImp::Spatial::Grid \u00b6 See OpenOasis::CommImp::Spatial::Grid Type Name virtual void CalculateBoundaryCenterDistances () virtual void CalculateCellDistances () virtual void CalculateCellSurface () virtual void CalculateCellVolume () double CalculateDistance (const Coordinate & n1, const Coordinate & n2) const virtual void CalculateFaceArea () virtual void CalculateFaceCorrectionVector () virtual void CalculateFaceDirector () virtual void CalculateFaceIntersections () virtual void CalculateFaceNormal () virtual void CalculateFacePerimeter () virtual void CalculateFaceWeights () virtual void CheckMesh () const virtual void CollectBoundaryFacesAndCells () virtual void CollectCellNeighbors () virtual void CollectCellsInZone () virtual void CollectCellsSharedFace () virtual void CollectCellsSharedNode () virtual void CollectFacesSharedNode () virtual void SortNodes () Public Functions Documentation \u00b6 function Grid3D [\u00bd] \u00b6 OpenOasis :: CommImp :: Spatial :: Grid3D :: Grid3D ( const std :: shared_ptr < Grid > & grid ) function Grid3D [2/2] \u00b6 OpenOasis :: CommImp :: Spatial :: Grid3D :: Grid3D ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int > > & faceNodes , std :: unordered_map < int , std :: vector < int > > & cellFaces , std :: unordered_map < std :: string , std :: vector < int > > & patches , std :: unordered_map < std :: string , std :: vector < int > > & zones ) function RefineCell \u00b6 Refine the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid3D :: RefineCell ( int cellIndex ) override Note: The refining wouldn't change the origin nodes. Implements OpenOasis::CommImp::Spatial::Grid::RefineCell function RelaxCell \u00b6 Relax the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid3D :: RelaxCell ( int cellIndex ) override Note: The coarsening wouldn't change the origin nodes. Implements OpenOasis::CommImp::Spatial::Grid::RelaxCell function Type \u00b6 Get the grid type. virtual int OpenOasis :: CommImp :: Spatial :: Grid3D :: Type () override const Returns: Return 1, for 1d grid; 2, for 2d; 3, for 3d; others, for invalid type. Implements OpenOasis::CommImp::Spatial::Grid::Type function ~Grid3D \u00b6 virtual OpenOasis :: CommImp :: Spatial :: Grid3D ::~ Grid3D () = default The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid3D.h","title":"Class OpenOasis::CommImp::Spatial::Grid3D"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid3_d/#class-openoasiscommimpspatialgrid3d","text":"ClassList > OpenOasis > CommImp > Spatial > Grid3D Inherits the following classes: OpenOasis::CommImp::Spatial::Grid","title":"Class OpenOasis::CommImp::Spatial::Grid3D"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid3_d/#public-functions","text":"Type Name Grid3D (const std::shared_ptr< Grid > & grid) Grid3D (std::unordered_map< int, Coordinate > & nodeCoords, std::unordered_map< int, Coordinate > & faceCoords, std::unordered_map< int, Coordinate > & cellCoords, std::unordered_map< int, std::vector< int > > & faceNodes, std::unordered_map< int, std::vector< int > > & cellFaces, std::unordered_map< std::string, std::vector< int > > & patches, std::unordered_map< std::string, std::vector< int > > & zones) virtual void RefineCell (int cellIndex) override Refine the cell at the given index for adaptive grid. virtual void RelaxCell (int cellIndex) override Relax the cell at the given index for adaptive grid. virtual int Type () override const Get the grid type. virtual ~Grid3D () = default","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid3_d/#public-functions-inherited-from-openoasiscommimpspatialgrid","text":"See OpenOasis::CommImp::Spatial::Grid Type Name virtual void Activate () Activate the mesh to extract topological information needed for various numerical calculations. const std::vector< int > & GetBoundaryCellIndexes () const double GetBoundaryCenterDistance (int cellIdx, int boundaryFaceIdx) const const MultiIndexMap< double > & GetBoundaryCenterDistances () const const std::vector< int > & GetBoundaryFaceIndexes () const const Cell & GetCell (int cellIndex) const double GetCellCenterDistance (int cellIdx, int neighborCellIdx) const const MultiIndexMap< double > & GetCellCenterDistances () const const MultiIndexMap< double > & GetCellWeightAtFace () const double GetCellWeightAtFace (int cellIdx, int faceIdx) const const Face & GetFace (int faceIndex) const const std::unordered_map< int, Vector < double > > & GetFaceCorrectionVector () const const Vector < double > & GetFaceCorrectionVector (int faceIdx) const const Node & GetNode (int nodeIndex) const int GetNumCells () const int GetNumFaces () const int GetNumNodes () const std::vector< int > GetPatchFaceIndexes (const std::string & patchId) const std::vector< std::string > GetPatchIds () const int GetRawNumCells () const int GetRawNumFaces () const int GetRawNumNodes () const std::vector< int > GetZoneCellIndexes (const std::string & zoneId) const std::vector< std::string > GetZoneIds () const Grid (const std::shared_ptr< Grid > & grid) Grid (std::unordered_map< int, Coordinate > & nodeCoords, std::unordered_map< int, Coordinate > & faceCoords, std::unordered_map< int, Coordinate > & cellCoords, std::unordered_map< int, std::vector< int > > & faceNodes, std::unordered_map< int, std::vector< int > > & cellFaces, std::unordered_map< std::string, std::vector< int > > & patches, std::unordered_map< std::string, std::vector< int > > & zones) virtual void RefineCell (int cellIndex) = 0 Refine the cell at the given index for adaptive grid. virtual void RelaxCell (int cellIndex) = 0 Relax the cell at the given index for adaptive grid. virtual int Type () const = 0 Get the grid type. virtual ~Grid () = default","title":"Public Functions inherited from OpenOasis::CommImp::Spatial::Grid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid3_d/#protected-attributes-inherited-from-openoasiscommimpspatialgrid","text":"See OpenOasis::CommImp::Spatial::Grid Type Name std::vector< int > mBoundaryCells MultiIndexMap< double > mBoundaryCenterDists std::vector< int > mBoundaryFaces MultiIndexMap< double > mCellFaceWeight MultiIndexMap< double > mCenterDists std::unordered_map< int, Vector < double > > mFaceCorrVecs std::unordered_map< int, Coordinate > mFaceIntersection Mesh mMesh std::unordered_map< std::string, std::vector< int > > mPatches int mRawCellsNum int mRawFacesNum int mRawNodesNum std::unordered_map< std::string, std::vector< int > > mZoneCells std::unordered_map< std::string, std::vector< int > > mZones","title":"Protected Attributes inherited from OpenOasis::CommImp::Spatial::Grid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid3_d/#protected-functions-inherited-from-openoasiscommimpspatialgrid","text":"See OpenOasis::CommImp::Spatial::Grid Type Name virtual void CalculateBoundaryCenterDistances () virtual void CalculateCellDistances () virtual void CalculateCellSurface () virtual void CalculateCellVolume () double CalculateDistance (const Coordinate & n1, const Coordinate & n2) const virtual void CalculateFaceArea () virtual void CalculateFaceCorrectionVector () virtual void CalculateFaceDirector () virtual void CalculateFaceIntersections () virtual void CalculateFaceNormal () virtual void CalculateFacePerimeter () virtual void CalculateFaceWeights () virtual void CheckMesh () const virtual void CollectBoundaryFacesAndCells () virtual void CollectCellNeighbors () virtual void CollectCellsInZone () virtual void CollectCellsSharedFace () virtual void CollectCellsSharedNode () virtual void CollectFacesSharedNode () virtual void SortNodes ()","title":"Protected Functions inherited from OpenOasis::CommImp::Spatial::Grid"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid3_d/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid3_d/#function-grid3d-12","text":"OpenOasis :: CommImp :: Spatial :: Grid3D :: Grid3D ( const std :: shared_ptr < Grid > & grid )","title":"function Grid3D [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid3_d/#function-grid3d-22","text":"OpenOasis :: CommImp :: Spatial :: Grid3D :: Grid3D ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int > > & faceNodes , std :: unordered_map < int , std :: vector < int > > & cellFaces , std :: unordered_map < std :: string , std :: vector < int > > & patches , std :: unordered_map < std :: string , std :: vector < int > > & zones )","title":"function Grid3D [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid3_d/#function-refinecell","text":"Refine the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid3D :: RefineCell ( int cellIndex ) override Note: The refining wouldn't change the origin nodes. Implements OpenOasis::CommImp::Spatial::Grid::RefineCell","title":"function RefineCell"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid3_d/#function-relaxcell","text":"Relax the cell at the given index for adaptive grid. virtual void OpenOasis :: CommImp :: Spatial :: Grid3D :: RelaxCell ( int cellIndex ) override Note: The coarsening wouldn't change the origin nodes. Implements OpenOasis::CommImp::Spatial::Grid::RelaxCell","title":"function RelaxCell"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid3_d/#function-type","text":"Get the grid type. virtual int OpenOasis :: CommImp :: Spatial :: Grid3D :: Type () override const Returns: Return 1, for 1d grid; 2, for 2d; 3, for 3d; others, for invalid type. Implements OpenOasis::CommImp::Spatial::Grid::Type","title":"function Type"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_grid3_d/#function-grid3d","text":"virtual OpenOasis :: CommImp :: Spatial :: Grid3D ::~ Grid3D () = default The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid3D.h","title":"function ~Grid3D"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_mesh/","text":"Struct OpenOasis::CommImp::Spatial::Mesh \u00b6 ClassList > OpenOasis > CommImp > Spatial > Mesh Mesh structure. #include <MeshStructs.h> Public Attributes \u00b6 Type Name std::unordered_map< int, Cell > cells std::unordered_map< int, Face > faces std::unordered_map< int, Node > nodes Public Attributes Documentation \u00b6 variable cells \u00b6 std :: unordered_map < int , Cell > OpenOasis :: CommImp :: Spatial :: Mesh :: cells ; variable faces \u00b6 std :: unordered_map < int , Face > OpenOasis :: CommImp :: Spatial :: Mesh :: faces ; variable nodes \u00b6 std :: unordered_map < int , Node > OpenOasis :: CommImp :: Spatial :: Mesh :: nodes ; The documentation for this class was generated from the following file Models/CommImp/Spatial/MeshStructs.h","title":"Struct OpenOasis::CommImp::Spatial::Mesh"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_mesh/#struct-openoasiscommimpspatialmesh","text":"ClassList > OpenOasis > CommImp > Spatial > Mesh Mesh structure. #include <MeshStructs.h>","title":"Struct OpenOasis::CommImp::Spatial::Mesh"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_mesh/#public-attributes","text":"Type Name std::unordered_map< int, Cell > cells std::unordered_map< int, Face > faces std::unordered_map< int, Node > nodes","title":"Public Attributes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_mesh/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_mesh/#variable-cells","text":"std :: unordered_map < int , Cell > OpenOasis :: CommImp :: Spatial :: Mesh :: cells ;","title":"variable cells"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_mesh/#variable-faces","text":"std :: unordered_map < int , Face > OpenOasis :: CommImp :: Spatial :: Mesh :: faces ;","title":"variable faces"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_mesh/#variable-nodes","text":"std :: unordered_map < int , Node > OpenOasis :: CommImp :: Spatial :: Mesh :: nodes ; The documentation for this class was generated from the following file Models/CommImp/Spatial/MeshStructs.h","title":"variable nodes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_node/","text":"Struct OpenOasis::CommImp::Spatial::Node \u00b6 ClassList > OpenOasis > CommImp > Spatial > Node Mesh node data structure. (Point type). #include <MeshStructs.h> Public Attributes \u00b6 Type Name std::vector< int > cellIndexes Coordinate coor std::vector< int > faceIndexes Public Attributes Documentation \u00b6 variable cellIndexes \u00b6 std :: vector < int > OpenOasis :: CommImp :: Spatial :: Node :: cellIndexes ; variable coor \u00b6 Coordinate OpenOasis :: CommImp :: Spatial :: Node :: coor ; variable faceIndexes \u00b6 std :: vector < int > OpenOasis :: CommImp :: Spatial :: Node :: faceIndexes ; The documentation for this class was generated from the following file Models/CommImp/Spatial/MeshStructs.h","title":"Struct OpenOasis::CommImp::Spatial::Node"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_node/#struct-openoasiscommimpspatialnode","text":"ClassList > OpenOasis > CommImp > Spatial > Node Mesh node data structure. (Point type). #include <MeshStructs.h>","title":"Struct OpenOasis::CommImp::Spatial::Node"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_node/#public-attributes","text":"Type Name std::vector< int > cellIndexes Coordinate coor std::vector< int > faceIndexes","title":"Public Attributes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_node/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_node/#variable-cellindexes","text":"std :: vector < int > OpenOasis :: CommImp :: Spatial :: Node :: cellIndexes ;","title":"variable cellIndexes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_node/#variable-coor","text":"Coordinate OpenOasis :: CommImp :: Spatial :: Node :: coor ;","title":"variable coor"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_node/#variable-faceindexes","text":"std :: vector < int > OpenOasis :: CommImp :: Spatial :: Node :: faceIndexes ; The documentation for this class was generated from the following file Models/CommImp/Spatial/MeshStructs.h","title":"variable faceIndexes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/","text":"Struct OpenOasis::CommImp::Spatial::XYExtent \u00b6 ClassList > OpenOasis > CommImp > Spatial > XYExtent Extent is a rectangle in xy-space. #include <XYGeoStructs.h> Public Attributes \u00b6 Type Name double xMax = = 0. double xMin = = 0. double yMax = = 0. double yMin = = 0. Public Functions \u00b6 Type Name void Include (const XYExtent & other) Makes this extent include \"other\". This will grow this extent, if the \"other\" point is outside this extent. void Include (double x, double y) Makes the extent include the xy-point. This will grow this extent, if the xy-point is outside this extent. bool IsContains (double x, double y) const Checks if this extent contains the xy-point. bool IsOverlaps (const XYExtent & other) const Checks if this extent overlaps this specified 'other' extent item. XYExtent () = default XYExtent (const XYPoint & point, double epsilon) XYExtent (const XYLine & line) XYExtent (const XYPolyline & polyline) XYExtent (const XYPolygon & polygon) XYExtent (const XYExtent & obj) XYExtent (double xmin, double xmax, double ymin, double ymax) Public Attributes Documentation \u00b6 variable xMax \u00b6 double OpenOasis :: CommImp :: Spatial :: XYExtent :: xMax ; variable xMin \u00b6 double OpenOasis :: CommImp :: Spatial :: XYExtent :: xMin ; variable yMax \u00b6 double OpenOasis :: CommImp :: Spatial :: XYExtent :: yMax ; variable yMin \u00b6 double OpenOasis :: CommImp :: Spatial :: XYExtent :: yMin ; Public Functions Documentation \u00b6 function Include [\u00bd] \u00b6 void OpenOasis :: CommImp :: Spatial :: XYExtent :: Include ( const XYExtent & other ) function Include [2/2] \u00b6 void OpenOasis :: CommImp :: Spatial :: XYExtent :: Include ( double x , double y ) function IsContains \u00b6 bool OpenOasis :: CommImp :: Spatial :: XYExtent :: IsContains ( double x , double y ) const function IsOverlaps \u00b6 bool OpenOasis :: CommImp :: Spatial :: XYExtent :: IsOverlaps ( const XYExtent & other ) const function XYExtent [1/7] \u00b6 OpenOasis :: CommImp :: Spatial :: XYExtent :: XYExtent () = default function XYExtent [2/7] \u00b6 OpenOasis :: CommImp :: Spatial :: XYExtent :: XYExtent ( const XYPoint & point , double epsilon ) function XYExtent [3/7] \u00b6 OpenOasis :: CommImp :: Spatial :: XYExtent :: XYExtent ( const XYLine & line ) function XYExtent [4/7] \u00b6 OpenOasis :: CommImp :: Spatial :: XYExtent :: XYExtent ( const XYPolyline & polyline ) function XYExtent [5/7] \u00b6 OpenOasis :: CommImp :: Spatial :: XYExtent :: XYExtent ( const XYPolygon & polygon ) function XYExtent [6/7] \u00b6 OpenOasis :: CommImp :: Spatial :: XYExtent :: XYExtent ( const XYExtent & obj ) function XYExtent [7/7] \u00b6 OpenOasis :: CommImp :: Spatial :: XYExtent :: XYExtent ( double xmin , double xmax , double ymin , double ymax ) The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoStructs.h","title":"Struct OpenOasis::CommImp::Spatial::XYExtent"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#struct-openoasiscommimpspatialxyextent","text":"ClassList > OpenOasis > CommImp > Spatial > XYExtent Extent is a rectangle in xy-space. #include <XYGeoStructs.h>","title":"Struct OpenOasis::CommImp::Spatial::XYExtent"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#public-attributes","text":"Type Name double xMax = = 0. double xMin = = 0. double yMax = = 0. double yMin = = 0.","title":"Public Attributes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#public-functions","text":"Type Name void Include (const XYExtent & other) Makes this extent include \"other\". This will grow this extent, if the \"other\" point is outside this extent. void Include (double x, double y) Makes the extent include the xy-point. This will grow this extent, if the xy-point is outside this extent. bool IsContains (double x, double y) const Checks if this extent contains the xy-point. bool IsOverlaps (const XYExtent & other) const Checks if this extent overlaps this specified 'other' extent item. XYExtent () = default XYExtent (const XYPoint & point, double epsilon) XYExtent (const XYLine & line) XYExtent (const XYPolyline & polyline) XYExtent (const XYPolygon & polygon) XYExtent (const XYExtent & obj) XYExtent (double xmin, double xmax, double ymin, double ymax)","title":"Public Functions"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#variable-xmax","text":"double OpenOasis :: CommImp :: Spatial :: XYExtent :: xMax ;","title":"variable xMax"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#variable-xmin","text":"double OpenOasis :: CommImp :: Spatial :: XYExtent :: xMin ;","title":"variable xMin"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#variable-ymax","text":"double OpenOasis :: CommImp :: Spatial :: XYExtent :: yMax ;","title":"variable yMax"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#variable-ymin","text":"double OpenOasis :: CommImp :: Spatial :: XYExtent :: yMin ;","title":"variable yMin"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#function-include-12","text":"void OpenOasis :: CommImp :: Spatial :: XYExtent :: Include ( const XYExtent & other )","title":"function Include [&frac12;]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#function-include-22","text":"void OpenOasis :: CommImp :: Spatial :: XYExtent :: Include ( double x , double y )","title":"function Include [2/2]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#function-iscontains","text":"bool OpenOasis :: CommImp :: Spatial :: XYExtent :: IsContains ( double x , double y ) const","title":"function IsContains"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#function-isoverlaps","text":"bool OpenOasis :: CommImp :: Spatial :: XYExtent :: IsOverlaps ( const XYExtent & other ) const","title":"function IsOverlaps"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#function-xyextent-17","text":"OpenOasis :: CommImp :: Spatial :: XYExtent :: XYExtent () = default","title":"function XYExtent [1/7]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#function-xyextent-27","text":"OpenOasis :: CommImp :: Spatial :: XYExtent :: XYExtent ( const XYPoint & point , double epsilon )","title":"function XYExtent [2/7]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#function-xyextent-37","text":"OpenOasis :: CommImp :: Spatial :: XYExtent :: XYExtent ( const XYLine & line )","title":"function XYExtent [3/7]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#function-xyextent-47","text":"OpenOasis :: CommImp :: Spatial :: XYExtent :: XYExtent ( const XYPolyline & polyline )","title":"function XYExtent [4/7]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#function-xyextent-57","text":"OpenOasis :: CommImp :: Spatial :: XYExtent :: XYExtent ( const XYPolygon & polygon )","title":"function XYExtent [5/7]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#function-xyextent-67","text":"OpenOasis :: CommImp :: Spatial :: XYExtent :: XYExtent ( const XYExtent & obj )","title":"function XYExtent [6/7]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_extent/#function-xyextent-77","text":"OpenOasis :: CommImp :: Spatial :: XYExtent :: XYExtent ( double xmin , double xmax , double ymin , double ymax ) The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoStructs.h","title":"function XYExtent [7/7]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/","text":"Class OpenOasis::CommImp::Spatial::XYGeoTools \u00b6 ClassList > OpenOasis > CommImp > Spatial > XYGeoTools The XYGeoTools class is a collection of general geometry functions. #include <XYGeoTools.h> Public Static Attributes \u00b6 Type Name constexpr double EPSILON = = 1.0e-5 Public Static Functions \u00b6 Type Name XYPoint CalculateIntersectionPoint (const XYLine & l1, const XYLine & l2) Calculates intersection point between two line segments. double CalculateLengthOfLineInsidePolygon (const XYLine & line, const XYPolygon & polygon) Calculates length of line inside polygon. Parts of the line that is on the edge of the polygon only counts with half their length. double CalculateLengthOfPolylineInsidePolygon (const XYPolyline & polyline, const XYPolygon & polygon) Calculates the length of polyline inside polygon. Lines segments on the edges of polygons are included with half their length. double CalculateLineToPointDistance (const XYLine & line, const XYPoint & point) Calculates the distance between a point and a line segment. XYPoint CalculateMidpoint (const XYLine & line) Calculates line segment midpoint. double CalculatePointToPointDistance (const XYPoint & p1, const XYPoint & p2) Calculates the distance between two points. double CalculatePolylineToPointDistance (const XYPolyline & polyline, const XYPoint & point) Calculates the shortest distance between any line segment of the polyline and the point. double CalculateSharedArea (const XYPolygon & polygonA, const XYPolygon & polygonB) Calculates the shared area of two arbitrarily shaped polygons. std::vector< XYPolygon > GetTriangulations (const XYPolygon & polygon) Returns a list of triangles of type XYPolygon describing the triangalation of the polygon. bool IsLinesIntersected (const XYLine & l1, const XYLine & l2) Checks if two line segments intersects. bool IsPointInLine (const XYPoint & point, const XYLine & line) Determines if point is included in a line either in the interior or as one of the end points. bool IsPointInPolygon (const XYPoint & point, const XYPolygon & polygon) Determines if a point is inside or outside a polygon. Inside includes on the edge for this method. Protected Static Functions \u00b6 Type Name double CalculateSharedLength (const XYLine & lineA, const XYLine & lineB) Calculates the length that two lines overlap. double CalculateTriangleSharedArea (const XYPolygon & triangleA, const XYPolygon & triangleB) Calculates the intersection area of triangle xypolygon a and b. int DecrementModula (int i, int n) The method steps to the previous index in a circular list {0, ..., n-1}. int FindTrianglePoints (const XYPolygon & polygon) Finds a set of three concecutive points that form a triangle, that is not intersected by other parts of the polygon. int IncrementModula (int i, int n) The method steps to the next index in a circular list {0, ..., n-1}. void Intersect (const XYPolygon & triangleA, const XYPolygon & triangleB, XYPoint & p, int & i, int & j, XYPolygon & intersectionPolygon) Calculates the intersection points of triangle xypolygon a and b. bool IntersectionPoint (const XYLine & LineA, const XYLine & LineB, XYPoint & intersectionPoint) Checks if the lines lineA and lineB shares a point either as a real crossing point or as a shared end point or a end point of the one line being in the other line. bool IsPointInLineInterior (const XYPoint & point, const XYLine & line) Determines if a point is included in a lines interior and not an endpoint. bool IsTriangleIntersected (const XYPolygon & polygon, int i) Determines if the triangle formed by P(i-1), P(i) and P(i+1) from Polygon are intersected by any of the other points of the polygon. Public Static Attributes Documentation \u00b6 variable EPSILON \u00b6 constexpr double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: EPSILON ; Public Static Functions Documentation \u00b6 function CalculateIntersectionPoint \u00b6 static XYPoint OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateIntersectionPoint ( const XYLine & l1 , const XYLine & l2 ) function CalculateLengthOfLineInsidePolygon \u00b6 static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateLengthOfLineInsidePolygon ( const XYLine & line , const XYPolygon & polygon ) function CalculateLengthOfPolylineInsidePolygon \u00b6 static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateLengthOfPolylineInsidePolygon ( const XYPolyline & polyline , const XYPolygon & polygon ) function CalculateLineToPointDistance \u00b6 static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateLineToPointDistance ( const XYLine & line , const XYPoint & point ) function CalculateMidpoint \u00b6 static XYPoint OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateMidpoint ( const XYLine & line ) function CalculatePointToPointDistance \u00b6 static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculatePointToPointDistance ( const XYPoint & p1 , const XYPoint & p2 ) function CalculatePolylineToPointDistance \u00b6 static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculatePolylineToPointDistance ( const XYPolyline & polyline , const XYPoint & point ) function CalculateSharedArea \u00b6 static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateSharedArea ( const XYPolygon & polygonA , const XYPolygon & polygonB ) function GetTriangulations \u00b6 static std :: vector < XYPolygon > OpenOasis :: CommImp :: Spatial :: XYGeoTools :: GetTriangulations ( const XYPolygon & polygon ) function IsLinesIntersected \u00b6 Checks if two line segments intersects. static bool OpenOasis :: CommImp :: Spatial :: XYGeoTools :: IsLinesIntersected ( const XYLine & l1 , const XYLine & l2 ) The lines are setted to intersected if the lines axctually cross or only share a point, and not if the lines are parrallel. function IsPointInLine \u00b6 static bool OpenOasis :: CommImp :: Spatial :: XYGeoTools :: IsPointInLine ( const XYPoint & point , const XYLine & line ) function IsPointInPolygon \u00b6 static bool OpenOasis :: CommImp :: Spatial :: XYGeoTools :: IsPointInPolygon ( const XYPoint & point , const XYPolygon & polygon ) Protected Static Functions Documentation \u00b6 function CalculateSharedLength \u00b6 static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateSharedLength ( const XYLine & lineA , const XYLine & lineB ) function CalculateTriangleSharedArea \u00b6 static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateTriangleSharedArea ( const XYPolygon & triangleA , const XYPolygon & triangleB ) function DecrementModula \u00b6 The method steps to the previous index in a circular list {0, ..., n-1}. static int OpenOasis :: CommImp :: Spatial :: XYGeoTools :: DecrementModula ( int i , int n ) Parameters: i Index to decrease.. n Module value, one larger than largest index. Returns: The decreased index. function FindTrianglePoints \u00b6 Finds a set of three concecutive points that form a triangle, that is not intersected by other parts of the polygon. static int OpenOasis :: CommImp :: Spatial :: XYGeoTools :: FindTrianglePoints ( const XYPolygon & polygon ) Returns: Index for the \"midlle\" point of triangle that forms an ear. The ear is formed by P(i-1), P(i) and P(i+1), where P are points included in the polygon. function IncrementModula \u00b6 The method steps to the next index in a circular list {0, ..., n-1}. static int OpenOasis :: CommImp :: Spatial :: XYGeoTools :: IncrementModula ( int i , int n ) Parameters: i Index to increase. n Modula value, one larger than largest index. Returns: The increased index. function Intersect \u00b6 Calculates the intersection points of triangle xypolygon a and b. static void OpenOasis :: CommImp :: Spatial :: XYGeoTools :: Intersect ( const XYPolygon & triangleA , const XYPolygon & triangleB , XYPoint & p , int & i , int & j , XYPolygon & intersectionPolygon ) Parameters: triangleA triangle. The search is started along triangleA. triangleB triangle. Intersection with the triangle are sought. p Starting point for the search. p must be part of triangleA. i on input: End index for the first line segment of triangleA. on output: End index for the last intersected line segment in triangleA. j on input: -1 if vertices before intersection isn't to be added. on output: End index for last intersected line of triangleB. intersectionPolygon Polygon eventually describing the intersection area between triangleA and triangleB. Returns: The p, i, j and intersectionPolygon are called by reference and modified in the method. function IntersectionPoint \u00b6 static bool OpenOasis :: CommImp :: Spatial :: XYGeoTools :: IntersectionPoint ( const XYLine & LineA , const XYLine & LineB , XYPoint & intersectionPoint ) function IsPointInLineInterior \u00b6 static bool OpenOasis :: CommImp :: Spatial :: XYGeoTools :: IsPointInLineInterior ( const XYPoint & point , const XYLine & line ) function IsTriangleIntersected \u00b6 Determines if the triangle formed by P(i-1), P(i) and P(i+1) from Polygon are intersected by any of the other points of the polygon. static bool OpenOasis :: CommImp :: Spatial :: XYGeoTools :: IsTriangleIntersected ( const XYPolygon & polygon , int i ) Parameters: i Middle index for the three points that forms the triangle. Returns: true, If the triangle P(i-1), P(i), P(i+1) is intersected by other parts of Polygon; false, otherwise. The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoTools.h","title":"Class OpenOasis::CommImp::Spatial::XYGeoTools"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#class-openoasiscommimpspatialxygeotools","text":"ClassList > OpenOasis > CommImp > Spatial > XYGeoTools The XYGeoTools class is a collection of general geometry functions. #include <XYGeoTools.h>","title":"Class OpenOasis::CommImp::Spatial::XYGeoTools"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#public-static-attributes","text":"Type Name constexpr double EPSILON = = 1.0e-5","title":"Public Static Attributes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#public-static-functions","text":"Type Name XYPoint CalculateIntersectionPoint (const XYLine & l1, const XYLine & l2) Calculates intersection point between two line segments. double CalculateLengthOfLineInsidePolygon (const XYLine & line, const XYPolygon & polygon) Calculates length of line inside polygon. Parts of the line that is on the edge of the polygon only counts with half their length. double CalculateLengthOfPolylineInsidePolygon (const XYPolyline & polyline, const XYPolygon & polygon) Calculates the length of polyline inside polygon. Lines segments on the edges of polygons are included with half their length. double CalculateLineToPointDistance (const XYLine & line, const XYPoint & point) Calculates the distance between a point and a line segment. XYPoint CalculateMidpoint (const XYLine & line) Calculates line segment midpoint. double CalculatePointToPointDistance (const XYPoint & p1, const XYPoint & p2) Calculates the distance between two points. double CalculatePolylineToPointDistance (const XYPolyline & polyline, const XYPoint & point) Calculates the shortest distance between any line segment of the polyline and the point. double CalculateSharedArea (const XYPolygon & polygonA, const XYPolygon & polygonB) Calculates the shared area of two arbitrarily shaped polygons. std::vector< XYPolygon > GetTriangulations (const XYPolygon & polygon) Returns a list of triangles of type XYPolygon describing the triangalation of the polygon. bool IsLinesIntersected (const XYLine & l1, const XYLine & l2) Checks if two line segments intersects. bool IsPointInLine (const XYPoint & point, const XYLine & line) Determines if point is included in a line either in the interior or as one of the end points. bool IsPointInPolygon (const XYPoint & point, const XYPolygon & polygon) Determines if a point is inside or outside a polygon. Inside includes on the edge for this method.","title":"Public Static Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#protected-static-functions","text":"Type Name double CalculateSharedLength (const XYLine & lineA, const XYLine & lineB) Calculates the length that two lines overlap. double CalculateTriangleSharedArea (const XYPolygon & triangleA, const XYPolygon & triangleB) Calculates the intersection area of triangle xypolygon a and b. int DecrementModula (int i, int n) The method steps to the previous index in a circular list {0, ..., n-1}. int FindTrianglePoints (const XYPolygon & polygon) Finds a set of three concecutive points that form a triangle, that is not intersected by other parts of the polygon. int IncrementModula (int i, int n) The method steps to the next index in a circular list {0, ..., n-1}. void Intersect (const XYPolygon & triangleA, const XYPolygon & triangleB, XYPoint & p, int & i, int & j, XYPolygon & intersectionPolygon) Calculates the intersection points of triangle xypolygon a and b. bool IntersectionPoint (const XYLine & LineA, const XYLine & LineB, XYPoint & intersectionPoint) Checks if the lines lineA and lineB shares a point either as a real crossing point or as a shared end point or a end point of the one line being in the other line. bool IsPointInLineInterior (const XYPoint & point, const XYLine & line) Determines if a point is included in a lines interior and not an endpoint. bool IsTriangleIntersected (const XYPolygon & polygon, int i) Determines if the triangle formed by P(i-1), P(i) and P(i+1) from Polygon are intersected by any of the other points of the polygon.","title":"Protected Static Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#public-static-attributes-documentation","text":"","title":"Public Static Attributes Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#variable-epsilon","text":"constexpr double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: EPSILON ;","title":"variable EPSILON"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#public-static-functions-documentation","text":"","title":"Public Static Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-calculateintersectionpoint","text":"static XYPoint OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateIntersectionPoint ( const XYLine & l1 , const XYLine & l2 )","title":"function CalculateIntersectionPoint"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-calculatelengthoflineinsidepolygon","text":"static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateLengthOfLineInsidePolygon ( const XYLine & line , const XYPolygon & polygon )","title":"function CalculateLengthOfLineInsidePolygon"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-calculatelengthofpolylineinsidepolygon","text":"static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateLengthOfPolylineInsidePolygon ( const XYPolyline & polyline , const XYPolygon & polygon )","title":"function CalculateLengthOfPolylineInsidePolygon"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-calculatelinetopointdistance","text":"static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateLineToPointDistance ( const XYLine & line , const XYPoint & point )","title":"function CalculateLineToPointDistance"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-calculatemidpoint","text":"static XYPoint OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateMidpoint ( const XYLine & line )","title":"function CalculateMidpoint"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-calculatepointtopointdistance","text":"static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculatePointToPointDistance ( const XYPoint & p1 , const XYPoint & p2 )","title":"function CalculatePointToPointDistance"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-calculatepolylinetopointdistance","text":"static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculatePolylineToPointDistance ( const XYPolyline & polyline , const XYPoint & point )","title":"function CalculatePolylineToPointDistance"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-calculatesharedarea","text":"static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateSharedArea ( const XYPolygon & polygonA , const XYPolygon & polygonB )","title":"function CalculateSharedArea"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-gettriangulations","text":"static std :: vector < XYPolygon > OpenOasis :: CommImp :: Spatial :: XYGeoTools :: GetTriangulations ( const XYPolygon & polygon )","title":"function GetTriangulations"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-islinesintersected","text":"Checks if two line segments intersects. static bool OpenOasis :: CommImp :: Spatial :: XYGeoTools :: IsLinesIntersected ( const XYLine & l1 , const XYLine & l2 ) The lines are setted to intersected if the lines axctually cross or only share a point, and not if the lines are parrallel.","title":"function IsLinesIntersected"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-ispointinline","text":"static bool OpenOasis :: CommImp :: Spatial :: XYGeoTools :: IsPointInLine ( const XYPoint & point , const XYLine & line )","title":"function IsPointInLine"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-ispointinpolygon","text":"static bool OpenOasis :: CommImp :: Spatial :: XYGeoTools :: IsPointInPolygon ( const XYPoint & point , const XYPolygon & polygon )","title":"function IsPointInPolygon"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#protected-static-functions-documentation","text":"","title":"Protected Static Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-calculatesharedlength","text":"static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateSharedLength ( const XYLine & lineA , const XYLine & lineB )","title":"function CalculateSharedLength"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-calculatetrianglesharedarea","text":"static double OpenOasis :: CommImp :: Spatial :: XYGeoTools :: CalculateTriangleSharedArea ( const XYPolygon & triangleA , const XYPolygon & triangleB )","title":"function CalculateTriangleSharedArea"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-decrementmodula","text":"The method steps to the previous index in a circular list {0, ..., n-1}. static int OpenOasis :: CommImp :: Spatial :: XYGeoTools :: DecrementModula ( int i , int n ) Parameters: i Index to decrease.. n Module value, one larger than largest index. Returns: The decreased index.","title":"function DecrementModula"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-findtrianglepoints","text":"Finds a set of three concecutive points that form a triangle, that is not intersected by other parts of the polygon. static int OpenOasis :: CommImp :: Spatial :: XYGeoTools :: FindTrianglePoints ( const XYPolygon & polygon ) Returns: Index for the \"midlle\" point of triangle that forms an ear. The ear is formed by P(i-1), P(i) and P(i+1), where P are points included in the polygon.","title":"function FindTrianglePoints"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-incrementmodula","text":"The method steps to the next index in a circular list {0, ..., n-1}. static int OpenOasis :: CommImp :: Spatial :: XYGeoTools :: IncrementModula ( int i , int n ) Parameters: i Index to increase. n Modula value, one larger than largest index. Returns: The increased index.","title":"function IncrementModula"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-intersect","text":"Calculates the intersection points of triangle xypolygon a and b. static void OpenOasis :: CommImp :: Spatial :: XYGeoTools :: Intersect ( const XYPolygon & triangleA , const XYPolygon & triangleB , XYPoint & p , int & i , int & j , XYPolygon & intersectionPolygon ) Parameters: triangleA triangle. The search is started along triangleA. triangleB triangle. Intersection with the triangle are sought. p Starting point for the search. p must be part of triangleA. i on input: End index for the first line segment of triangleA. on output: End index for the last intersected line segment in triangleA. j on input: -1 if vertices before intersection isn't to be added. on output: End index for last intersected line of triangleB. intersectionPolygon Polygon eventually describing the intersection area between triangleA and triangleB. Returns: The p, i, j and intersectionPolygon are called by reference and modified in the method.","title":"function Intersect"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-intersectionpoint","text":"static bool OpenOasis :: CommImp :: Spatial :: XYGeoTools :: IntersectionPoint ( const XYLine & LineA , const XYLine & LineB , XYPoint & intersectionPoint )","title":"function IntersectionPoint"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-ispointinlineinterior","text":"static bool OpenOasis :: CommImp :: Spatial :: XYGeoTools :: IsPointInLineInterior ( const XYPoint & point , const XYLine & line )","title":"function IsPointInLineInterior"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_geo_tools/#function-istriangleintersected","text":"Determines if the triangle formed by P(i-1), P(i) and P(i+1) from Polygon are intersected by any of the other points of the polygon. static bool OpenOasis :: CommImp :: Spatial :: XYGeoTools :: IsTriangleIntersected ( const XYPolygon & polygon , int i ) Parameters: i Middle index for the three points that forms the triangle. Returns: true, If the triangle P(i-1), P(i), P(i+1) is intersected by other parts of Polygon; false, otherwise. The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoTools.h","title":"function IsTriangleIntersected"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_line/","text":"Struct OpenOasis::CommImp::Spatial::XYLine \u00b6 ClassList > OpenOasis > CommImp > Spatial > XYLine The XYline struct is used for representing a line segment. #include <XYGeoStructs.h> Public Attributes \u00b6 Type Name XYPoint point1 XYPoint point2 Public Functions \u00b6 Type Name double GetLength () const XYLine () = default XYLine (double x1, double y1, double x2, double y2) XYLine (const XYPoint & p1, const XYPoint & p2) XYLine (const XYLine & line) Public Attributes Documentation \u00b6 variable point1 \u00b6 XYPoint OpenOasis :: CommImp :: Spatial :: XYLine :: point1 ; variable point2 \u00b6 XYPoint OpenOasis :: CommImp :: Spatial :: XYLine :: point2 ; Public Functions Documentation \u00b6 function GetLength \u00b6 double OpenOasis :: CommImp :: Spatial :: XYLine :: GetLength () const function XYLine [\u00bc] \u00b6 OpenOasis :: CommImp :: Spatial :: XYLine :: XYLine () = default function XYLine [2/4] \u00b6 OpenOasis :: CommImp :: Spatial :: XYLine :: XYLine ( double x1 , double y1 , double x2 , double y2 ) function XYLine [\u00be] \u00b6 OpenOasis :: CommImp :: Spatial :: XYLine :: XYLine ( const XYPoint & p1 , const XYPoint & p2 ) function XYLine [4/4] \u00b6 OpenOasis :: CommImp :: Spatial :: XYLine :: XYLine ( const XYLine & line ) The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoStructs.h","title":"Struct OpenOasis::CommImp::Spatial::XYLine"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_line/#struct-openoasiscommimpspatialxyline","text":"ClassList > OpenOasis > CommImp > Spatial > XYLine The XYline struct is used for representing a line segment. #include <XYGeoStructs.h>","title":"Struct OpenOasis::CommImp::Spatial::XYLine"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_line/#public-attributes","text":"Type Name XYPoint point1 XYPoint point2","title":"Public Attributes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_line/#public-functions","text":"Type Name double GetLength () const XYLine () = default XYLine (double x1, double y1, double x2, double y2) XYLine (const XYPoint & p1, const XYPoint & p2) XYLine (const XYLine & line)","title":"Public Functions"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_line/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_line/#variable-point1","text":"XYPoint OpenOasis :: CommImp :: Spatial :: XYLine :: point1 ;","title":"variable point1"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_line/#variable-point2","text":"XYPoint OpenOasis :: CommImp :: Spatial :: XYLine :: point2 ;","title":"variable point2"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_line/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_line/#function-getlength","text":"double OpenOasis :: CommImp :: Spatial :: XYLine :: GetLength () const","title":"function GetLength"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_line/#function-xyline-14","text":"OpenOasis :: CommImp :: Spatial :: XYLine :: XYLine () = default","title":"function XYLine [&frac14;]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_line/#function-xyline-24","text":"OpenOasis :: CommImp :: Spatial :: XYLine :: XYLine ( double x1 , double y1 , double x2 , double y2 )","title":"function XYLine [2/4]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_line/#function-xyline-34","text":"OpenOasis :: CommImp :: Spatial :: XYLine :: XYLine ( const XYPoint & p1 , const XYPoint & p2 )","title":"function XYLine [&frac34;]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_line/#function-xyline-44","text":"OpenOasis :: CommImp :: Spatial :: XYLine :: XYLine ( const XYLine & line ) The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoStructs.h","title":"function XYLine [4/4]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_point/","text":"Struct OpenOasis::CommImp::Spatial::XYPoint \u00b6 ClassList > OpenOasis > CommImp > Spatial > XYPoint XYPoint is simply a x and y coordinate point (has no z coordinate). #include <XYGeoStructs.h> Public Attributes \u00b6 Type Name double x = = 0. double y = = 0. Public Functions \u00b6 Type Name XYPoint () = default XYPoint (const XYPoint & obj) XYPoint (const Coordinate & coor) XYPoint (double coorX, double coorY) Public Attributes Documentation \u00b6 variable x \u00b6 double OpenOasis :: CommImp :: Spatial :: XYPoint :: x ; variable y \u00b6 double OpenOasis :: CommImp :: Spatial :: XYPoint :: y ; Public Functions Documentation \u00b6 function XYPoint [\u00bc] \u00b6 OpenOasis :: CommImp :: Spatial :: XYPoint :: XYPoint () = default function XYPoint [2/4] \u00b6 OpenOasis :: CommImp :: Spatial :: XYPoint :: XYPoint ( const XYPoint & obj ) function XYPoint [\u00be] \u00b6 OpenOasis :: CommImp :: Spatial :: XYPoint :: XYPoint ( const Coordinate & coor ) function XYPoint [4/4] \u00b6 OpenOasis :: CommImp :: Spatial :: XYPoint :: XYPoint ( double coorX , double coorY ) The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoStructs.h","title":"Struct OpenOasis::CommImp::Spatial::XYPoint"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_point/#struct-openoasiscommimpspatialxypoint","text":"ClassList > OpenOasis > CommImp > Spatial > XYPoint XYPoint is simply a x and y coordinate point (has no z coordinate). #include <XYGeoStructs.h>","title":"Struct OpenOasis::CommImp::Spatial::XYPoint"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_point/#public-attributes","text":"Type Name double x = = 0. double y = = 0.","title":"Public Attributes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_point/#public-functions","text":"Type Name XYPoint () = default XYPoint (const XYPoint & obj) XYPoint (const Coordinate & coor) XYPoint (double coorX, double coorY)","title":"Public Functions"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_point/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_point/#variable-x","text":"double OpenOasis :: CommImp :: Spatial :: XYPoint :: x ;","title":"variable x"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_point/#variable-y","text":"double OpenOasis :: CommImp :: Spatial :: XYPoint :: y ;","title":"variable y"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_point/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_point/#function-xypoint-14","text":"OpenOasis :: CommImp :: Spatial :: XYPoint :: XYPoint () = default","title":"function XYPoint [&frac14;]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_point/#function-xypoint-24","text":"OpenOasis :: CommImp :: Spatial :: XYPoint :: XYPoint ( const XYPoint & obj )","title":"function XYPoint [2/4]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_point/#function-xypoint-34","text":"OpenOasis :: CommImp :: Spatial :: XYPoint :: XYPoint ( const Coordinate & coor )","title":"function XYPoint [&frac34;]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_point/#function-xypoint-44","text":"OpenOasis :: CommImp :: Spatial :: XYPoint :: XYPoint ( double coorX , double coorY ) The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoStructs.h","title":"function XYPoint [4/4]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polygon/","text":"Struct OpenOasis::CommImp::Spatial::XYPolygon \u00b6 ClassList > OpenOasis > CommImp > Spatial > XYPolygon The XYPolygon struct defines a polygon in the XY plane (no z coordinate). #include <XYGeoStructs.h> Public Attributes \u00b6 Type Name std::vector< XYPoint > points Public Functions \u00b6 Type Name double GetArea () const Calculates area of the polygon. XYLine GetLine (int lineNumber) const Returns the XYLine that connects XYPoint \"LineNumber\" and the next number (i.e. LineNumber+1 or 0). bool IsConvex (int index) const Decides if the angle at index point is convex or concave. bool Validate () const Checks if the XYPolygon item is valid. The check made are: XYPolygon () = default XYPolygon (const std::vector< XYPoint > & points) XYPolygon (const XYPolygon & polygon) Public Attributes Documentation \u00b6 variable points \u00b6 std :: vector < XYPoint > OpenOasis :: CommImp :: Spatial :: XYPolygon :: points ; Public Functions Documentation \u00b6 function GetArea \u00b6 double OpenOasis :: CommImp :: Spatial :: XYPolygon :: GetArea () const function GetLine \u00b6 XYLine OpenOasis :: CommImp :: Spatial :: XYPolygon :: GetLine ( int lineNumber ) const function IsConvex \u00b6 bool OpenOasis :: CommImp :: Spatial :: XYPolygon :: IsConvex ( int index ) const function Validate \u00b6 Checks if the XYPolygon item is valid. The check made are: bool OpenOasis :: CommImp :: Spatial :: XYPolygon :: Validate () const is number of points >= 3 is the length of all line segments positive is any lines cross is the area positive Exception: Exception is raised if these above constraints aren't met. function XYPolygon [\u2153] \u00b6 OpenOasis :: CommImp :: Spatial :: XYPolygon :: XYPolygon () = default function XYPolygon [\u2154] \u00b6 OpenOasis :: CommImp :: Spatial :: XYPolygon :: XYPolygon ( const std :: vector < XYPoint > & points ) function XYPolygon [3/3] \u00b6 OpenOasis :: CommImp :: Spatial :: XYPolygon :: XYPolygon ( const XYPolygon & polygon ) The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoStructs.h","title":"Struct OpenOasis::CommImp::Spatial::XYPolygon"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polygon/#struct-openoasiscommimpspatialxypolygon","text":"ClassList > OpenOasis > CommImp > Spatial > XYPolygon The XYPolygon struct defines a polygon in the XY plane (no z coordinate). #include <XYGeoStructs.h>","title":"Struct OpenOasis::CommImp::Spatial::XYPolygon"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polygon/#public-attributes","text":"Type Name std::vector< XYPoint > points","title":"Public Attributes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polygon/#public-functions","text":"Type Name double GetArea () const Calculates area of the polygon. XYLine GetLine (int lineNumber) const Returns the XYLine that connects XYPoint \"LineNumber\" and the next number (i.e. LineNumber+1 or 0). bool IsConvex (int index) const Decides if the angle at index point is convex or concave. bool Validate () const Checks if the XYPolygon item is valid. The check made are: XYPolygon () = default XYPolygon (const std::vector< XYPoint > & points) XYPolygon (const XYPolygon & polygon)","title":"Public Functions"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polygon/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polygon/#variable-points","text":"std :: vector < XYPoint > OpenOasis :: CommImp :: Spatial :: XYPolygon :: points ;","title":"variable points"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polygon/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polygon/#function-getarea","text":"double OpenOasis :: CommImp :: Spatial :: XYPolygon :: GetArea () const","title":"function GetArea"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polygon/#function-getline","text":"XYLine OpenOasis :: CommImp :: Spatial :: XYPolygon :: GetLine ( int lineNumber ) const","title":"function GetLine"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polygon/#function-isconvex","text":"bool OpenOasis :: CommImp :: Spatial :: XYPolygon :: IsConvex ( int index ) const","title":"function IsConvex"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polygon/#function-validate","text":"Checks if the XYPolygon item is valid. The check made are: bool OpenOasis :: CommImp :: Spatial :: XYPolygon :: Validate () const is number of points >= 3 is the length of all line segments positive is any lines cross is the area positive Exception: Exception is raised if these above constraints aren't met.","title":"function Validate"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polygon/#function-xypolygon-13","text":"OpenOasis :: CommImp :: Spatial :: XYPolygon :: XYPolygon () = default","title":"function XYPolygon [&#8531;]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polygon/#function-xypolygon-23","text":"OpenOasis :: CommImp :: Spatial :: XYPolygon :: XYPolygon ( const std :: vector < XYPoint > & points )","title":"function XYPolygon [&#8532;]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polygon/#function-xypolygon-33","text":"OpenOasis :: CommImp :: Spatial :: XYPolygon :: XYPolygon ( const XYPolygon & polygon ) The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoStructs.h","title":"function XYPolygon [3/3]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polyline/","text":"Struct OpenOasis::CommImp::Spatial::XYPolyline \u00b6 ClassList > OpenOasis > CommImp > Spatial > XYPolyline XYPolyline is a collection of points (at least 2) connected with straigth lines. XYPolylines are typically used for presentation of 1D data, river network. #include <XYGeoStructs.h> Public Attributes \u00b6 Type Name std::vector< XYPoint > points Public Functions \u00b6 Type Name double GetLength () const Returns the cumulative calculating length of current line. XYLine GetLine (int lineNumber) const Retrieves the lineNumber line segment of the polyline. The index list is zero based. bool Validate () const The validate method check if the XYPolyline is valid. The checks made are: XYPolyline () = default XYPolyline (const std::vector< XYPoint > & points) XYPolyline (const XYPolyline & pline) Public Attributes Documentation \u00b6 variable points \u00b6 std :: vector < XYPoint > OpenOasis :: CommImp :: Spatial :: XYPolyline :: points ; Public Functions Documentation \u00b6 function GetLength \u00b6 double OpenOasis :: CommImp :: Spatial :: XYPolyline :: GetLength () const function GetLine \u00b6 XYLine OpenOasis :: CommImp :: Spatial :: XYPolyline :: GetLine ( int lineNumber ) const function Validate \u00b6 The validate method check if the XYPolyline is valid. The checks made are: bool OpenOasis :: CommImp :: Spatial :: XYPolyline :: Validate () const is number of points >= 2 is the length of all line segments positive Exception: Exception is raised if these above constraints aren't met. function XYPolyline [\u2153] \u00b6 OpenOasis :: CommImp :: Spatial :: XYPolyline :: XYPolyline () = default function XYPolyline [\u2154] \u00b6 OpenOasis :: CommImp :: Spatial :: XYPolyline :: XYPolyline ( const std :: vector < XYPoint > & points ) function XYPolyline [3/3] \u00b6 OpenOasis :: CommImp :: Spatial :: XYPolyline :: XYPolyline ( const XYPolyline & pline ) The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoStructs.h","title":"Struct OpenOasis::CommImp::Spatial::XYPolyline"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polyline/#struct-openoasiscommimpspatialxypolyline","text":"ClassList > OpenOasis > CommImp > Spatial > XYPolyline XYPolyline is a collection of points (at least 2) connected with straigth lines. XYPolylines are typically used for presentation of 1D data, river network. #include <XYGeoStructs.h>","title":"Struct OpenOasis::CommImp::Spatial::XYPolyline"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polyline/#public-attributes","text":"Type Name std::vector< XYPoint > points","title":"Public Attributes"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polyline/#public-functions","text":"Type Name double GetLength () const Returns the cumulative calculating length of current line. XYLine GetLine (int lineNumber) const Retrieves the lineNumber line segment of the polyline. The index list is zero based. bool Validate () const The validate method check if the XYPolyline is valid. The checks made are: XYPolyline () = default XYPolyline (const std::vector< XYPoint > & points) XYPolyline (const XYPolyline & pline)","title":"Public Functions"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polyline/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polyline/#variable-points","text":"std :: vector < XYPoint > OpenOasis :: CommImp :: Spatial :: XYPolyline :: points ;","title":"variable points"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polyline/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polyline/#function-getlength","text":"double OpenOasis :: CommImp :: Spatial :: XYPolyline :: GetLength () const","title":"function GetLength"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polyline/#function-getline","text":"XYLine OpenOasis :: CommImp :: Spatial :: XYPolyline :: GetLine ( int lineNumber ) const","title":"function GetLine"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polyline/#function-validate","text":"The validate method check if the XYPolyline is valid. The checks made are: bool OpenOasis :: CommImp :: Spatial :: XYPolyline :: Validate () const is number of points >= 2 is the length of all line segments positive Exception: Exception is raised if these above constraints aren't met.","title":"function Validate"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polyline/#function-xypolyline-13","text":"OpenOasis :: CommImp :: Spatial :: XYPolyline :: XYPolyline () = default","title":"function XYPolyline [&#8531;]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polyline/#function-xypolyline-23","text":"OpenOasis :: CommImp :: Spatial :: XYPolyline :: XYPolyline ( const std :: vector < XYPoint > & points )","title":"function XYPolyline [&#8532;]"},{"location":"models/struct_open_oasis_1_1_comm_imp_1_1_spatial_1_1_x_y_polyline/#function-xypolyline-33","text":"OpenOasis :: CommImp :: Spatial :: XYPolyline :: XYPolyline ( const XYPolyline & pline ) The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoStructs.h","title":"function XYPolyline [3/3]"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_temporal/","text":"Namespace OpenOasis::CommImp::Temporal \u00b6 Namespace List > OpenOasis > CommImp > Temporal More... Classes \u00b6 Type Name class TimeBuffer The TimeBuffer class provides temporal buffering functionality. Detailed Description \u00b6 @File : TimeBuffer.cpp @Brief : To provide temporal buffering functionalities. The documentation for this class was generated from the following file Models/CommImp/Temporal/TimeBuffer.cpp","title":"Namespace OpenOasis::CommImp::Temporal"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_temporal/#namespace-openoasiscommimptemporal","text":"Namespace List > OpenOasis > CommImp > Temporal More...","title":"Namespace OpenOasis::CommImp::Temporal"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_temporal/#classes","text":"Type Name class TimeBuffer The TimeBuffer class provides temporal buffering functionality.","title":"Classes"},{"location":"models/namespace_open_oasis_1_1_comm_imp_1_1_temporal/#detailed-description","text":"@File : TimeBuffer.cpp @Brief : To provide temporal buffering functionalities. The documentation for this class was generated from the following file Models/CommImp/Temporal/TimeBuffer.cpp","title":"Detailed Description"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/","text":"Class OpenOasis::CommImp::Temporal::TimeBuffer \u00b6 ClassList > OpenOasis > CommImp > Temporal > TimeBuffer The TimeBuffer class provides temporal buffering functionality. #include <TimeBuffer.h> Public Functions \u00b6 Type Name void AddValues (const std::shared_ptr< ITime > & time, const std::vector< real > & values) Adds corresponding values for time and values to the TimeBuffer . The AddValues method will internally make a copy of the added times and values. The reason for doing this is that the times and values arguments are reference, and the corresponding values could be changed by the owner of the classes. void CheckBuffer () const Checks weather the contents of the buffer is valid. void ClearAfter (std::shared_ptr< ITime > time) Clears all times and values in the buffer at/or later than the specified time. If the specified time is span, the start time is used. void ClearBefore (std::shared_ptr< ITime > time) Clears all records in the buffer associated to time that is earlier than the time specified. std::vector< std::vector< real > > GetAllValues () bool GetDoExtendedDataVerification () const bool GetDoExtrapolate () const real GetRelaxationFactor () const std::shared_ptr< ITime > GetTimeAt (int timeStep) const std::shared_ptr< TimeSet > GetTimeSet () const int GetTimesCount () const Number of time streps in the buffer. std::shared_ptr< ValueSet2D > GetValueSet () const std::vector< real > GetValues (const std::shared_ptr< ITime > & requestedTime) Returns the values that corresponds to the requestedTime. The values may be found by interpolation, extrapolation and/or aggregation. std::vector< real > GetValuesAt (int timeStep) const int GetValuesCount () const The number of values in the valuesets contained in the buffer. void Reset () void SetDoExtendedDataVerification (bool value) void SetDoExtrapolate (bool value) void SetOrAddValues (std::shared_ptr< ITime > time, std::vector< real > values) void SetRelaxationFactor (real value) TimeBuffer () TimeBuffer (const TimeBuffer & TimeBuffer) virtual ~TimeBuffer () Protected Attributes \u00b6 Type Name bool mDoExtendedDataVerification = = false bool mDoExtrapolate = = true int mLastBufferSizeMessageCounter = = 0 real mRelaxationFactor = = 0 std::shared_ptr< TimeSet > mTimes = = nullptr std::shared_ptr< ValueSet2D > mValues = = nullptr Protected Functions \u00b6 Type Name void AddValuesToBuffer (const std::shared_ptr< ITime > & time, const std::vector< real > & values) Adds values to the buffer, check the time is increasing, not overlapping(spans), and has durations matching the TimeSet. void Create () std::vector< real > MapFromTimeSpansToTimeSpan (const std::shared_ptr< ITime > & requestedTime) A ValueSet corresponding to a TimeSpan is calculated using interpolation or extrapolation in corresponding lists of ValueSets and TimeSpans. std::vector< real > MapFromTimeSpansToTimeStamp (const std::shared_ptr< ITime > & requestedTimeStamp) A ValueSet for a time stamp is calculated using interpolation or extrapolation in corresponding lists of ValueSets and TimeSpans. std::vector< real > MapFromTimeStampsToTimeSpan (const std::shared_ptr< ITime > & requestedTime) A ValueSet corresponding to a TimeSpan is calculated using interpolation or extrapolation in corresponding lists of ValueSets and TimeStamps. std::vector< real > MapFromTimeStampsToTimeStamp (const std::shared_ptr< ITime > & requestedTimeStamp) A ValueSet corresponding to Time Stamp is calculated using interpolation or extrapolation in corresponding lists of ValueSets and TimeStamps. Public Functions Documentation \u00b6 function AddValues \u00b6 Adds corresponding values for time and values to the TimeBuffer . The AddValues method will internally make a copy of the added times and values. The reason for doing this is that the times and values arguments are reference, and the corresponding values could be changed by the owner of the classes. void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: AddValues ( const std :: shared_ptr < ITime > & time , const std :: vector < real > & values ) Parameters: time Description of the time parameter. valueSet Description of the values parameter. function CheckBuffer \u00b6 void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: CheckBuffer () const function ClearAfter \u00b6 void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: ClearAfter ( std :: shared_ptr < ITime > time ) function ClearBefore \u00b6 void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: ClearBefore ( std :: shared_ptr < ITime > time ) function GetAllValues \u00b6 std :: vector < std :: vector < real > > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetAllValues () function GetDoExtendedDataVerification \u00b6 bool OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetDoExtendedDataVerification () const function GetDoExtrapolate \u00b6 bool OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetDoExtrapolate () const function GetRelaxationFactor \u00b6 real OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetRelaxationFactor () const function GetTimeAt \u00b6 std :: shared_ptr < ITime > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetTimeAt ( int timeStep ) const function GetTimeSet \u00b6 std :: shared_ptr < TimeSet > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetTimeSet () const function GetTimesCount \u00b6 int OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetTimesCount () const function GetValueSet \u00b6 std :: shared_ptr < ValueSet2D > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetValueSet () const function GetValues \u00b6 std :: vector < real > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetValues ( const std :: shared_ptr < ITime > & requestedTime ) function GetValuesAt \u00b6 std :: vector < real > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetValuesAt ( int timeStep ) const function GetValuesCount \u00b6 int OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetValuesCount () const function Reset \u00b6 void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: Reset () function SetDoExtendedDataVerification \u00b6 void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: SetDoExtendedDataVerification ( bool value ) function SetDoExtrapolate \u00b6 void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: SetDoExtrapolate ( bool value ) function SetOrAddValues \u00b6 void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: SetOrAddValues ( std :: shared_ptr < ITime > time , std :: vector < real > values ) function SetRelaxationFactor \u00b6 void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: SetRelaxationFactor ( real value ) function TimeBuffer [\u00bd] \u00b6 OpenOasis :: CommImp :: Temporal :: TimeBuffer :: TimeBuffer () function TimeBuffer [2/2] \u00b6 OpenOasis :: CommImp :: Temporal :: TimeBuffer :: TimeBuffer ( const TimeBuffer & TimeBuffer ) function ~TimeBuffer \u00b6 inline virtual OpenOasis :: CommImp :: Temporal :: TimeBuffer ::~ TimeBuffer () Protected Attributes Documentation \u00b6 variable mDoExtendedDataVerification \u00b6 bool OpenOasis :: CommImp :: Temporal :: TimeBuffer :: mDoExtendedDataVerification ; variable mDoExtrapolate \u00b6 bool OpenOasis :: CommImp :: Temporal :: TimeBuffer :: mDoExtrapolate ; variable mLastBufferSizeMessageCounter \u00b6 int OpenOasis :: CommImp :: Temporal :: TimeBuffer :: mLastBufferSizeMessageCounter ; variable mRelaxationFactor \u00b6 real OpenOasis :: CommImp :: Temporal :: TimeBuffer :: mRelaxationFactor ; variable mTimes \u00b6 std :: shared_ptr < TimeSet > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: mTimes ; variable mValues \u00b6 std :: shared_ptr < ValueSet2D > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: mValues ; Protected Functions Documentation \u00b6 function AddValuesToBuffer \u00b6 void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: AddValuesToBuffer ( const std :: shared_ptr < ITime > & time , const std :: vector < real > & values ) function Create \u00b6 void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: Create () function MapFromTimeSpansToTimeSpan \u00b6 std :: vector < real > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: MapFromTimeSpansToTimeSpan ( const std :: shared_ptr < ITime > & requestedTime ) function MapFromTimeSpansToTimeStamp \u00b6 std :: vector < real > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: MapFromTimeSpansToTimeStamp ( const std :: shared_ptr < ITime > & requestedTimeStamp ) function MapFromTimeStampsToTimeSpan \u00b6 std :: vector < real > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: MapFromTimeStampsToTimeSpan ( const std :: shared_ptr < ITime > & requestedTime ) function MapFromTimeStampsToTimeStamp \u00b6 std :: vector < real > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: MapFromTimeStampsToTimeStamp ( const std :: shared_ptr < ITime > & requestedTimeStamp ) The documentation for this class was generated from the following file Models/CommImp/Temporal/TimeBuffer.h","title":"Class OpenOasis::CommImp::Temporal::TimeBuffer"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#class-openoasiscommimptemporaltimebuffer","text":"ClassList > OpenOasis > CommImp > Temporal > TimeBuffer The TimeBuffer class provides temporal buffering functionality. #include <TimeBuffer.h>","title":"Class OpenOasis::CommImp::Temporal::TimeBuffer"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#public-functions","text":"Type Name void AddValues (const std::shared_ptr< ITime > & time, const std::vector< real > & values) Adds corresponding values for time and values to the TimeBuffer . The AddValues method will internally make a copy of the added times and values. The reason for doing this is that the times and values arguments are reference, and the corresponding values could be changed by the owner of the classes. void CheckBuffer () const Checks weather the contents of the buffer is valid. void ClearAfter (std::shared_ptr< ITime > time) Clears all times and values in the buffer at/or later than the specified time. If the specified time is span, the start time is used. void ClearBefore (std::shared_ptr< ITime > time) Clears all records in the buffer associated to time that is earlier than the time specified. std::vector< std::vector< real > > GetAllValues () bool GetDoExtendedDataVerification () const bool GetDoExtrapolate () const real GetRelaxationFactor () const std::shared_ptr< ITime > GetTimeAt (int timeStep) const std::shared_ptr< TimeSet > GetTimeSet () const int GetTimesCount () const Number of time streps in the buffer. std::shared_ptr< ValueSet2D > GetValueSet () const std::vector< real > GetValues (const std::shared_ptr< ITime > & requestedTime) Returns the values that corresponds to the requestedTime. The values may be found by interpolation, extrapolation and/or aggregation. std::vector< real > GetValuesAt (int timeStep) const int GetValuesCount () const The number of values in the valuesets contained in the buffer. void Reset () void SetDoExtendedDataVerification (bool value) void SetDoExtrapolate (bool value) void SetOrAddValues (std::shared_ptr< ITime > time, std::vector< real > values) void SetRelaxationFactor (real value) TimeBuffer () TimeBuffer (const TimeBuffer & TimeBuffer) virtual ~TimeBuffer ()","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#protected-attributes","text":"Type Name bool mDoExtendedDataVerification = = false bool mDoExtrapolate = = true int mLastBufferSizeMessageCounter = = 0 real mRelaxationFactor = = 0 std::shared_ptr< TimeSet > mTimes = = nullptr std::shared_ptr< ValueSet2D > mValues = = nullptr","title":"Protected Attributes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#protected-functions","text":"Type Name void AddValuesToBuffer (const std::shared_ptr< ITime > & time, const std::vector< real > & values) Adds values to the buffer, check the time is increasing, not overlapping(spans), and has durations matching the TimeSet. void Create () std::vector< real > MapFromTimeSpansToTimeSpan (const std::shared_ptr< ITime > & requestedTime) A ValueSet corresponding to a TimeSpan is calculated using interpolation or extrapolation in corresponding lists of ValueSets and TimeSpans. std::vector< real > MapFromTimeSpansToTimeStamp (const std::shared_ptr< ITime > & requestedTimeStamp) A ValueSet for a time stamp is calculated using interpolation or extrapolation in corresponding lists of ValueSets and TimeSpans. std::vector< real > MapFromTimeStampsToTimeSpan (const std::shared_ptr< ITime > & requestedTime) A ValueSet corresponding to a TimeSpan is calculated using interpolation or extrapolation in corresponding lists of ValueSets and TimeStamps. std::vector< real > MapFromTimeStampsToTimeStamp (const std::shared_ptr< ITime > & requestedTimeStamp) A ValueSet corresponding to Time Stamp is calculated using interpolation or extrapolation in corresponding lists of ValueSets and TimeStamps.","title":"Protected Functions"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-addvalues","text":"Adds corresponding values for time and values to the TimeBuffer . The AddValues method will internally make a copy of the added times and values. The reason for doing this is that the times and values arguments are reference, and the corresponding values could be changed by the owner of the classes. void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: AddValues ( const std :: shared_ptr < ITime > & time , const std :: vector < real > & values ) Parameters: time Description of the time parameter. valueSet Description of the values parameter.","title":"function AddValues"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-checkbuffer","text":"void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: CheckBuffer () const","title":"function CheckBuffer"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-clearafter","text":"void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: ClearAfter ( std :: shared_ptr < ITime > time )","title":"function ClearAfter"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-clearbefore","text":"void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: ClearBefore ( std :: shared_ptr < ITime > time )","title":"function ClearBefore"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-getallvalues","text":"std :: vector < std :: vector < real > > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetAllValues ()","title":"function GetAllValues"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-getdoextendeddataverification","text":"bool OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetDoExtendedDataVerification () const","title":"function GetDoExtendedDataVerification"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-getdoextrapolate","text":"bool OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetDoExtrapolate () const","title":"function GetDoExtrapolate"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-getrelaxationfactor","text":"real OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetRelaxationFactor () const","title":"function GetRelaxationFactor"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-gettimeat","text":"std :: shared_ptr < ITime > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetTimeAt ( int timeStep ) const","title":"function GetTimeAt"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-gettimeset","text":"std :: shared_ptr < TimeSet > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetTimeSet () const","title":"function GetTimeSet"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-gettimescount","text":"int OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetTimesCount () const","title":"function GetTimesCount"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-getvalueset","text":"std :: shared_ptr < ValueSet2D > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetValueSet () const","title":"function GetValueSet"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-getvalues","text":"std :: vector < real > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetValues ( const std :: shared_ptr < ITime > & requestedTime )","title":"function GetValues"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-getvaluesat","text":"std :: vector < real > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetValuesAt ( int timeStep ) const","title":"function GetValuesAt"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-getvaluescount","text":"int OpenOasis :: CommImp :: Temporal :: TimeBuffer :: GetValuesCount () const","title":"function GetValuesCount"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-reset","text":"void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: Reset ()","title":"function Reset"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-setdoextendeddataverification","text":"void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: SetDoExtendedDataVerification ( bool value )","title":"function SetDoExtendedDataVerification"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-setdoextrapolate","text":"void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: SetDoExtrapolate ( bool value )","title":"function SetDoExtrapolate"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-setoraddvalues","text":"void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: SetOrAddValues ( std :: shared_ptr < ITime > time , std :: vector < real > values )","title":"function SetOrAddValues"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-setrelaxationfactor","text":"void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: SetRelaxationFactor ( real value )","title":"function SetRelaxationFactor"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-timebuffer-12","text":"OpenOasis :: CommImp :: Temporal :: TimeBuffer :: TimeBuffer ()","title":"function TimeBuffer [&frac12;]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-timebuffer-22","text":"OpenOasis :: CommImp :: Temporal :: TimeBuffer :: TimeBuffer ( const TimeBuffer & TimeBuffer )","title":"function TimeBuffer [2/2]"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-timebuffer","text":"inline virtual OpenOasis :: CommImp :: Temporal :: TimeBuffer ::~ TimeBuffer ()","title":"function ~TimeBuffer"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#protected-attributes-documentation","text":"","title":"Protected Attributes Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#variable-mdoextendeddataverification","text":"bool OpenOasis :: CommImp :: Temporal :: TimeBuffer :: mDoExtendedDataVerification ;","title":"variable mDoExtendedDataVerification"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#variable-mdoextrapolate","text":"bool OpenOasis :: CommImp :: Temporal :: TimeBuffer :: mDoExtrapolate ;","title":"variable mDoExtrapolate"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#variable-mlastbuffersizemessagecounter","text":"int OpenOasis :: CommImp :: Temporal :: TimeBuffer :: mLastBufferSizeMessageCounter ;","title":"variable mLastBufferSizeMessageCounter"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#variable-mrelaxationfactor","text":"real OpenOasis :: CommImp :: Temporal :: TimeBuffer :: mRelaxationFactor ;","title":"variable mRelaxationFactor"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#variable-mtimes","text":"std :: shared_ptr < TimeSet > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: mTimes ;","title":"variable mTimes"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#variable-mvalues","text":"std :: shared_ptr < ValueSet2D > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: mValues ;","title":"variable mValues"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#protected-functions-documentation","text":"","title":"Protected Functions Documentation"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-addvaluestobuffer","text":"void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: AddValuesToBuffer ( const std :: shared_ptr < ITime > & time , const std :: vector < real > & values )","title":"function AddValuesToBuffer"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-create","text":"void OpenOasis :: CommImp :: Temporal :: TimeBuffer :: Create ()","title":"function Create"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-mapfromtimespanstotimespan","text":"std :: vector < real > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: MapFromTimeSpansToTimeSpan ( const std :: shared_ptr < ITime > & requestedTime )","title":"function MapFromTimeSpansToTimeSpan"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-mapfromtimespanstotimestamp","text":"std :: vector < real > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: MapFromTimeSpansToTimeStamp ( const std :: shared_ptr < ITime > & requestedTimeStamp )","title":"function MapFromTimeSpansToTimeStamp"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-mapfromtimestampstotimespan","text":"std :: vector < real > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: MapFromTimeStampsToTimeSpan ( const std :: shared_ptr < ITime > & requestedTime )","title":"function MapFromTimeStampsToTimeSpan"},{"location":"models/class_open_oasis_1_1_comm_imp_1_1_temporal_1_1_time_buffer/#function-mapfromtimestampstotimestamp","text":"std :: vector < real > OpenOasis :: CommImp :: Temporal :: TimeBuffer :: MapFromTimeStampsToTimeStamp ( const std :: shared_ptr < ITime > & requestedTimeStamp ) The documentation for this class was generated from the following file Models/CommImp/Temporal/TimeBuffer.h","title":"function MapFromTimeStampsToTimeStamp"},{"location":"models/class_open_oasis_1_1_exchange_item_change_event_args/","text":"Class OpenOasis::ExchangeItemChangeEventArgs \u00b6 ClassList > OpenOasis > ExchangeItemChangeEventArgs Class containing the information that will be passed when firing an ExchangeItemValueChanged event. More... #include <ExchangeItemChangeEventArgs.h> Public Functions \u00b6 Type Name virtual std::shared_ptr< IBaseExchangeItem > GetExchangeItem () const = 0 virtual std::string GetMessages () const = 0 virtual void SetExchangeItem (std::shared_ptr< IBaseExchangeItem > obj) = 0 virtual void SetMessages (const std::string & value) = 0 Detailed Description \u00b6 Sending exchange item events is optional, so it should not be used as a mechanism to build critical functionality upon. Public Functions Documentation \u00b6 function GetExchangeItem \u00b6 virtual std :: shared_ptr < IBaseExchangeItem > OpenOasis :: ExchangeItemChangeEventArgs :: GetExchangeItem () const = 0 function GetMessages \u00b6 virtual std :: string OpenOasis :: ExchangeItemChangeEventArgs :: GetMessages () const = 0 function SetExchangeItem \u00b6 virtual void OpenOasis :: ExchangeItemChangeEventArgs :: SetExchangeItem ( std :: shared_ptr < IBaseExchangeItem > obj ) = 0 function SetMessages \u00b6 virtual void OpenOasis :: ExchangeItemChangeEventArgs :: SetMessages ( const std :: string & value ) = 0 The documentation for this class was generated from the following file Models/Inc/ExchangeItemChangeEventArgs.h","title":"Class OpenOasis::ExchangeItemChangeEventArgs"},{"location":"models/class_open_oasis_1_1_exchange_item_change_event_args/#class-openoasisexchangeitemchangeeventargs","text":"ClassList > OpenOasis > ExchangeItemChangeEventArgs Class containing the information that will be passed when firing an ExchangeItemValueChanged event. More... #include <ExchangeItemChangeEventArgs.h>","title":"Class OpenOasis::ExchangeItemChangeEventArgs"},{"location":"models/class_open_oasis_1_1_exchange_item_change_event_args/#public-functions","text":"Type Name virtual std::shared_ptr< IBaseExchangeItem > GetExchangeItem () const = 0 virtual std::string GetMessages () const = 0 virtual void SetExchangeItem (std::shared_ptr< IBaseExchangeItem > obj) = 0 virtual void SetMessages (const std::string & value) = 0","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_exchange_item_change_event_args/#detailed-description","text":"Sending exchange item events is optional, so it should not be used as a mechanism to build critical functionality upon.","title":"Detailed Description"},{"location":"models/class_open_oasis_1_1_exchange_item_change_event_args/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_exchange_item_change_event_args/#function-getexchangeitem","text":"virtual std :: shared_ptr < IBaseExchangeItem > OpenOasis :: ExchangeItemChangeEventArgs :: GetExchangeItem () const = 0","title":"function GetExchangeItem"},{"location":"models/class_open_oasis_1_1_exchange_item_change_event_args/#function-getmessages","text":"virtual std :: string OpenOasis :: ExchangeItemChangeEventArgs :: GetMessages () const = 0","title":"function GetMessages"},{"location":"models/class_open_oasis_1_1_exchange_item_change_event_args/#function-setexchangeitem","text":"virtual void OpenOasis :: ExchangeItemChangeEventArgs :: SetExchangeItem ( std :: shared_ptr < IBaseExchangeItem > obj ) = 0","title":"function SetExchangeItem"},{"location":"models/class_open_oasis_1_1_exchange_item_change_event_args/#function-setmessages","text":"virtual void OpenOasis :: ExchangeItemChangeEventArgs :: SetMessages ( const std :: string & value ) = 0 The documentation for this class was generated from the following file Models/Inc/ExchangeItemChangeEventArgs.h","title":"function SetMessages"},{"location":"models/class_open_oasis_1_1_i_adapted_output/","text":"Class OpenOasis::IAdaptedOutput \u00b6 ClassList > OpenOasis > IAdaptedOutput Extension class for adding data operations on top of an output item. More... #include <IAdaptedOutput.h> Inherits the following classes: OpenOasis::IOutput Public Types inherited from OpenOasis::IBaseExchangeItem \u00b6 See OpenOasis::IBaseExchangeItem Type Name typedef std::function< void(std::shared_ptr< ExchangeItemChangeEventArgs >)> ListenFunc Public Functions \u00b6 Type Name virtual std::weak_ptr< IOutput > GetAdaptee () const = 0 IOutput item that this IAdaptedOutput extracts content from. virtual std::vector< std::shared_ptr< IArgument > > GetArguments () const = 0 Arguments needed to let the adapted output do its work. virtual void Initialize () = 0 Let the adapted output initialize itself based on the current values specified by the arguments. virtual void Refresh () = 0 Requests the adapted output to refresh itself. virtual void SetAdaptee (std::shared_ptr< IOutput > adaptee) = 0 Sets an output which requiring the provided adaptive data operations. Public Functions inherited from OpenOasis::IOutput \u00b6 See OpenOasis::IOutput Type Name virtual void AddAdaptedOutput (std::shared_ptr< IAdaptedOutput > adaptedOutput) = 0 Adds an adapted output to this output item as a transformer. virtual void AddConsumer (std::shared_ptr< IInput > consumer) = 0 Adds a consumer to the output item. Every input item needs to add itself as a consumer first. virtual std::vector< std::shared_ptr< IAdaptedOutput > > GetAdaptedOutputs () const = 0 Gets the adapted outputs. virtual std::vector< std::weak_ptr< IInput > > GetConsumers () const = 0 Gets inputs that will consume the value, by calling the GetValues() method. Every input item needs to call the AddConsumer() method first. virtual void RemoveAdaptedOutput (const std::shared_ptr< IAdaptedOutput > & adaptedOutput) = 0 Removes a IAdaptedOutput . virtual void RemoveConsumer (const std::shared_ptr< IInput > & consumer) = 0 Removes a consumer. Public Functions inherited from OpenOasis::IBaseExchangeItem \u00b6 See OpenOasis::IBaseExchangeItem Type Name virtual void AddListener (const ListenFunc & func) = 0 Adds a listener to the exchange item. virtual std::weak_ptr< ILinkableComponent > GetComponent () const = 0 Gets the owner of the exchange item. virtual std::shared_ptr< IElementSet > GetElementSet () const = 0 Gets the exchange item's elements. If it's id-based, return null. virtual std::shared_ptr< ITimeSet > GetTimeSet () const = 0 Gets the exchange item's available time set. If it's time independent, return null. virtual std::shared_ptr< IValueDefinition > GetValueDefinition () const = 0 Definition of the values in the exchange item. virtual std::shared_ptr< IValueSet > GetValues () = 0 Provides the values matching the value definition specified. Extensions can overwrite this base version to include more details in the query, e.g. time and space. virtual void RemoveListener (const ListenFunc & func) = 0 Removes the listener if it is no more interested at this item. virtual void Reset () = 0 Resets the exchange item. virtual void SetElementSet (std::shared_ptr< IElementSet > elements) = 0 Sets the exchange item's elements. virtual void SetTimeSet (std::shared_ptr< ITimeSet > times) = 0 Sets the exchange item's time set. virtual void SetValues (std::shared_ptr< IValueSet > value) = 0 Sets the exchange item's values. Public Functions inherited from OpenOasis::IIdentifiable \u00b6 See OpenOasis::IIdentifiable Type Name virtual std::string GetId () const = 0 Gets id string. Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Detailed Description \u00b6 The IAdaptedOutput extends an IOutput item with functionality, such as spatial interpolation, temporal interpolation, unit conversion etc. Public Functions Documentation \u00b6 function GetAdaptee \u00b6 IOutput item that this IAdaptedOutput extracts content from. virtual std :: weak_ptr < IOutput > OpenOasis :: IAdaptedOutput :: GetAdaptee () const = 0 In the adapter design pattern, it is the item being adapted. function GetArguments \u00b6 Arguments needed to let the adapted output do its work. virtual std :: vector < std :: shared_ptr < IArgument > > OpenOasis :: IAdaptedOutput :: GetArguments () const = 0 An unmodifiable list of the (modifiable) arguments should be returned that can be used to get info on the arguments and to modify argument values. Returns: Unmodifiable list of IArgument . function Initialize \u00b6 Let the adapted output initialize itself based on the current values specified by the arguments. virtual void OpenOasis :: IAdaptedOutput :: Initialize () = 0 Only after Initialize() is called, the Refresh() method might be called. A component must invoke the Initialize() method of all its adapted outputs at the end of the component's prepare phase. In case of stacked adapted outputs, the adaptee must be initialized firstly. function Refresh \u00b6 Requests the adapted output to refresh itself. virtual void OpenOasis :: IAdaptedOutput :: Refresh () = 0 After updating itself, the adapted output must call Refresh() method on all its adapted outputs, so the chain of outputs refreshes itself. function SetAdaptee \u00b6 virtual void OpenOasis :: IAdaptedOutput :: SetAdaptee ( std :: shared_ptr < IOutput > adaptee ) = 0 The documentation for this class was generated from the following file Models/Inc/IAdaptedOutput.h","title":"Class OpenOasis::IAdaptedOutput"},{"location":"models/class_open_oasis_1_1_i_adapted_output/#class-openoasisiadaptedoutput","text":"ClassList > OpenOasis > IAdaptedOutput Extension class for adding data operations on top of an output item. More... #include <IAdaptedOutput.h> Inherits the following classes: OpenOasis::IOutput","title":"Class OpenOasis::IAdaptedOutput"},{"location":"models/class_open_oasis_1_1_i_adapted_output/#public-types-inherited-from-openoasisibaseexchangeitem","text":"See OpenOasis::IBaseExchangeItem Type Name typedef std::function< void(std::shared_ptr< ExchangeItemChangeEventArgs >)> ListenFunc","title":"Public Types inherited from OpenOasis::IBaseExchangeItem"},{"location":"models/class_open_oasis_1_1_i_adapted_output/#public-functions","text":"Type Name virtual std::weak_ptr< IOutput > GetAdaptee () const = 0 IOutput item that this IAdaptedOutput extracts content from. virtual std::vector< std::shared_ptr< IArgument > > GetArguments () const = 0 Arguments needed to let the adapted output do its work. virtual void Initialize () = 0 Let the adapted output initialize itself based on the current values specified by the arguments. virtual void Refresh () = 0 Requests the adapted output to refresh itself. virtual void SetAdaptee (std::shared_ptr< IOutput > adaptee) = 0 Sets an output which requiring the provided adaptive data operations.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_adapted_output/#public-functions-inherited-from-openoasisioutput","text":"See OpenOasis::IOutput Type Name virtual void AddAdaptedOutput (std::shared_ptr< IAdaptedOutput > adaptedOutput) = 0 Adds an adapted output to this output item as a transformer. virtual void AddConsumer (std::shared_ptr< IInput > consumer) = 0 Adds a consumer to the output item. Every input item needs to add itself as a consumer first. virtual std::vector< std::shared_ptr< IAdaptedOutput > > GetAdaptedOutputs () const = 0 Gets the adapted outputs. virtual std::vector< std::weak_ptr< IInput > > GetConsumers () const = 0 Gets inputs that will consume the value, by calling the GetValues() method. Every input item needs to call the AddConsumer() method first. virtual void RemoveAdaptedOutput (const std::shared_ptr< IAdaptedOutput > & adaptedOutput) = 0 Removes a IAdaptedOutput . virtual void RemoveConsumer (const std::shared_ptr< IInput > & consumer) = 0 Removes a consumer.","title":"Public Functions inherited from OpenOasis::IOutput"},{"location":"models/class_open_oasis_1_1_i_adapted_output/#public-functions-inherited-from-openoasisibaseexchangeitem","text":"See OpenOasis::IBaseExchangeItem Type Name virtual void AddListener (const ListenFunc & func) = 0 Adds a listener to the exchange item. virtual std::weak_ptr< ILinkableComponent > GetComponent () const = 0 Gets the owner of the exchange item. virtual std::shared_ptr< IElementSet > GetElementSet () const = 0 Gets the exchange item's elements. If it's id-based, return null. virtual std::shared_ptr< ITimeSet > GetTimeSet () const = 0 Gets the exchange item's available time set. If it's time independent, return null. virtual std::shared_ptr< IValueDefinition > GetValueDefinition () const = 0 Definition of the values in the exchange item. virtual std::shared_ptr< IValueSet > GetValues () = 0 Provides the values matching the value definition specified. Extensions can overwrite this base version to include more details in the query, e.g. time and space. virtual void RemoveListener (const ListenFunc & func) = 0 Removes the listener if it is no more interested at this item. virtual void Reset () = 0 Resets the exchange item. virtual void SetElementSet (std::shared_ptr< IElementSet > elements) = 0 Sets the exchange item's elements. virtual void SetTimeSet (std::shared_ptr< ITimeSet > times) = 0 Sets the exchange item's time set. virtual void SetValues (std::shared_ptr< IValueSet > value) = 0 Sets the exchange item's values.","title":"Public Functions inherited from OpenOasis::IBaseExchangeItem"},{"location":"models/class_open_oasis_1_1_i_adapted_output/#public-functions-inherited-from-openoasisiidentifiable","text":"See OpenOasis::IIdentifiable Type Name virtual std::string GetId () const = 0 Gets id string.","title":"Public Functions inherited from OpenOasis::IIdentifiable"},{"location":"models/class_open_oasis_1_1_i_adapted_output/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_adapted_output/#detailed-description","text":"The IAdaptedOutput extends an IOutput item with functionality, such as spatial interpolation, temporal interpolation, unit conversion etc.","title":"Detailed Description"},{"location":"models/class_open_oasis_1_1_i_adapted_output/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_adapted_output/#function-getadaptee","text":"IOutput item that this IAdaptedOutput extracts content from. virtual std :: weak_ptr < IOutput > OpenOasis :: IAdaptedOutput :: GetAdaptee () const = 0 In the adapter design pattern, it is the item being adapted.","title":"function GetAdaptee"},{"location":"models/class_open_oasis_1_1_i_adapted_output/#function-getarguments","text":"Arguments needed to let the adapted output do its work. virtual std :: vector < std :: shared_ptr < IArgument > > OpenOasis :: IAdaptedOutput :: GetArguments () const = 0 An unmodifiable list of the (modifiable) arguments should be returned that can be used to get info on the arguments and to modify argument values. Returns: Unmodifiable list of IArgument .","title":"function GetArguments"},{"location":"models/class_open_oasis_1_1_i_adapted_output/#function-initialize","text":"Let the adapted output initialize itself based on the current values specified by the arguments. virtual void OpenOasis :: IAdaptedOutput :: Initialize () = 0 Only after Initialize() is called, the Refresh() method might be called. A component must invoke the Initialize() method of all its adapted outputs at the end of the component's prepare phase. In case of stacked adapted outputs, the adaptee must be initialized firstly.","title":"function Initialize"},{"location":"models/class_open_oasis_1_1_i_adapted_output/#function-refresh","text":"Requests the adapted output to refresh itself. virtual void OpenOasis :: IAdaptedOutput :: Refresh () = 0 After updating itself, the adapted output must call Refresh() method on all its adapted outputs, so the chain of outputs refreshes itself.","title":"function Refresh"},{"location":"models/class_open_oasis_1_1_i_adapted_output/#function-setadaptee","text":"virtual void OpenOasis :: IAdaptedOutput :: SetAdaptee ( std :: shared_ptr < IOutput > adaptee ) = 0 The documentation for this class was generated from the following file Models/Inc/IAdaptedOutput.h","title":"function SetAdaptee"},{"location":"models/class_open_oasis_1_1_i_adapted_output_factory/","text":"Class OpenOasis::IAdaptedOutputFactory \u00b6 ClassList > OpenOasis > IAdaptedOutputFactory Factory class for creating instances of IAdaptedOutput items. #include <IAdaptedOutputFactory.h> Inherits the following classes: OpenOasis::IIdentifiable Public Functions \u00b6 Type Name virtual std::shared_ptr< IAdaptedOutput > CreateAdaptedOutput (const std::shared_ptr< IIdentifiable > & adaptedOutputId, const std::shared_ptr< IOutput > & adaptee, const std::shared_ptr< IInput > & target) = 0 Creates IAdaptedOutput adapting the adaptee, so that it fits the target. virtual std::vector< std::shared_ptr< IIdentifiable > > GetAvailableAdaptedOutputIds (const std::shared_ptr< IOutput > & adaptee, const std::shared_ptr< IInput > & target) = 0 Gets a list of identifier of the available IAdaptedOutput that can make the adaptee match the target. Public Functions inherited from OpenOasis::IIdentifiable \u00b6 See OpenOasis::IIdentifiable Type Name virtual std::string GetId () const = 0 Gets id string. Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Public Functions Documentation \u00b6 function CreateAdaptedOutput \u00b6 Creates IAdaptedOutput adapting the adaptee, so that it fits the target. virtual std :: shared_ptr < IAdaptedOutput > OpenOasis :: IAdaptedOutputFactory :: CreateAdaptedOutput ( const std :: shared_ptr < IIdentifiable > & adaptedOutputId , const std :: shared_ptr < IOutput > & adaptee , const std :: shared_ptr < IInput > & target ) = 0 The adaptedOutputId used must be one of the IIdentifiable instances returned by the GetAvailableAdaptedOutputIds() method. The returned IAdaptedOutput will already be registered with this adaptee. Parameters: adaptedOutputId The identifier of the ' IAdaptedOutput to create. @param adaptee IOutput to adapt. @param target IInput to adapt the adaptee to, can be null`. Returns: The IAdaptedOutput item adaptes the adaptee to fit the target item. function GetAvailableAdaptedOutputIds \u00b6 Gets a list of identifier of the available IAdaptedOutput that can make the adaptee match the target. virtual std :: vector < std :: shared_ptr < IIdentifiable > > OpenOasis :: IAdaptedOutputFactory :: GetAvailableAdaptedOutputIds ( const std :: shared_ptr < IOutput > & adaptee , const std :: shared_ptr < IInput > & target ) = 0 If the target is null, the identifiers of all IAdaptedOutput s that can adapt the adaptee are returned. Parameters: adaptee IOutput to adapt. target IInput to adapt the adaptee to, can be null . Returns: List of identifier of the available IAdaptedOutput . The documentation for this class was generated from the following file Models/Inc/IAdaptedOutputFactory.h","title":"Class OpenOasis::IAdaptedOutputFactory"},{"location":"models/class_open_oasis_1_1_i_adapted_output_factory/#class-openoasisiadaptedoutputfactory","text":"ClassList > OpenOasis > IAdaptedOutputFactory Factory class for creating instances of IAdaptedOutput items. #include <IAdaptedOutputFactory.h> Inherits the following classes: OpenOasis::IIdentifiable","title":"Class OpenOasis::IAdaptedOutputFactory"},{"location":"models/class_open_oasis_1_1_i_adapted_output_factory/#public-functions","text":"Type Name virtual std::shared_ptr< IAdaptedOutput > CreateAdaptedOutput (const std::shared_ptr< IIdentifiable > & adaptedOutputId, const std::shared_ptr< IOutput > & adaptee, const std::shared_ptr< IInput > & target) = 0 Creates IAdaptedOutput adapting the adaptee, so that it fits the target. virtual std::vector< std::shared_ptr< IIdentifiable > > GetAvailableAdaptedOutputIds (const std::shared_ptr< IOutput > & adaptee, const std::shared_ptr< IInput > & target) = 0 Gets a list of identifier of the available IAdaptedOutput that can make the adaptee match the target.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_adapted_output_factory/#public-functions-inherited-from-openoasisiidentifiable","text":"See OpenOasis::IIdentifiable Type Name virtual std::string GetId () const = 0 Gets id string.","title":"Public Functions inherited from OpenOasis::IIdentifiable"},{"location":"models/class_open_oasis_1_1_i_adapted_output_factory/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_adapted_output_factory/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_adapted_output_factory/#function-createadaptedoutput","text":"Creates IAdaptedOutput adapting the adaptee, so that it fits the target. virtual std :: shared_ptr < IAdaptedOutput > OpenOasis :: IAdaptedOutputFactory :: CreateAdaptedOutput ( const std :: shared_ptr < IIdentifiable > & adaptedOutputId , const std :: shared_ptr < IOutput > & adaptee , const std :: shared_ptr < IInput > & target ) = 0 The adaptedOutputId used must be one of the IIdentifiable instances returned by the GetAvailableAdaptedOutputIds() method. The returned IAdaptedOutput will already be registered with this adaptee. Parameters: adaptedOutputId The identifier of the ' IAdaptedOutput to create. @param adaptee IOutput to adapt. @param target IInput to adapt the adaptee to, can be null`. Returns: The IAdaptedOutput item adaptes the adaptee to fit the target item.","title":"function CreateAdaptedOutput"},{"location":"models/class_open_oasis_1_1_i_adapted_output_factory/#function-getavailableadaptedoutputids","text":"Gets a list of identifier of the available IAdaptedOutput that can make the adaptee match the target. virtual std :: vector < std :: shared_ptr < IIdentifiable > > OpenOasis :: IAdaptedOutputFactory :: GetAvailableAdaptedOutputIds ( const std :: shared_ptr < IOutput > & adaptee , const std :: shared_ptr < IInput > & target ) = 0 If the target is null, the identifiers of all IAdaptedOutput s that can adapt the adaptee are returned. Parameters: adaptee IOutput to adapt. target IInput to adapt the adaptee to, can be null . Returns: List of identifier of the available IAdaptedOutput . The documentation for this class was generated from the following file Models/Inc/IAdaptedOutputFactory.h","title":"function GetAvailableAdaptedOutputIds"},{"location":"models/class_open_oasis_1_1_i_argument/","text":"Class OpenOasis::IArgument \u00b6 ClassList > OpenOasis > IArgument Class for providing arguments for an ILinkableComponent and others. #include <IArgument.h> Inherits the following classes: OpenOasis::IIdentifiable Public Functions \u00b6 Type Name virtual std::any GetDefaultValue () const = 0 The default value of the argument. virtual std::vector< std::any > GetPossibleValues () const = 0 List of possible allowed values for the argument. virtual std::any GetValue () const = 0 Gets the current value of the argument. virtual const std::type_info & GetValueType () const = 0 Gets the type of the value of the argument. virtual bool IsOptional () const = 0 Specifies whether the argument is optional. virtual bool IsReadOnly () const = 0 Defines whether the value property can be edited. virtual void SetValue (std::any value) = 0 Sets the argument value, if settable. Public Functions inherited from OpenOasis::IIdentifiable \u00b6 See OpenOasis::IIdentifiable Type Name virtual std::string GetId () const = 0 Gets id string. Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Public Functions Documentation \u00b6 function GetDefaultValue \u00b6 virtual std :: any OpenOasis :: IArgument :: GetDefaultValue () const = 0 function GetPossibleValues \u00b6 virtual std :: vector < std :: any > OpenOasis :: IArgument :: GetPossibleValues () const = 0 function GetValue \u00b6 Gets the current value of the argument. virtual std :: any OpenOasis :: IArgument :: GetValue () const = 0 If no value has been set yet, default value is returned. function GetValueType \u00b6 virtual const std :: type_info & OpenOasis :: IArgument :: GetValueType () const = 0 function IsOptional \u00b6 Specifies whether the argument is optional. virtual bool OpenOasis :: IArgument :: IsOptional () const = 0 If false, the argument's value must be set before it could be used. function IsReadOnly \u00b6 virtual bool OpenOasis :: IArgument :: IsReadOnly () const = 0 function SetValue \u00b6 virtual void OpenOasis :: IArgument :: SetValue ( std :: any value ) = 0 The documentation for this class was generated from the following file Models/Inc/IArgument.h","title":"Class OpenOasis::IArgument"},{"location":"models/class_open_oasis_1_1_i_argument/#class-openoasisiargument","text":"ClassList > OpenOasis > IArgument Class for providing arguments for an ILinkableComponent and others. #include <IArgument.h> Inherits the following classes: OpenOasis::IIdentifiable","title":"Class OpenOasis::IArgument"},{"location":"models/class_open_oasis_1_1_i_argument/#public-functions","text":"Type Name virtual std::any GetDefaultValue () const = 0 The default value of the argument. virtual std::vector< std::any > GetPossibleValues () const = 0 List of possible allowed values for the argument. virtual std::any GetValue () const = 0 Gets the current value of the argument. virtual const std::type_info & GetValueType () const = 0 Gets the type of the value of the argument. virtual bool IsOptional () const = 0 Specifies whether the argument is optional. virtual bool IsReadOnly () const = 0 Defines whether the value property can be edited. virtual void SetValue (std::any value) = 0 Sets the argument value, if settable.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_argument/#public-functions-inherited-from-openoasisiidentifiable","text":"See OpenOasis::IIdentifiable Type Name virtual std::string GetId () const = 0 Gets id string.","title":"Public Functions inherited from OpenOasis::IIdentifiable"},{"location":"models/class_open_oasis_1_1_i_argument/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_argument/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_argument/#function-getdefaultvalue","text":"virtual std :: any OpenOasis :: IArgument :: GetDefaultValue () const = 0","title":"function GetDefaultValue"},{"location":"models/class_open_oasis_1_1_i_argument/#function-getpossiblevalues","text":"virtual std :: vector < std :: any > OpenOasis :: IArgument :: GetPossibleValues () const = 0","title":"function GetPossibleValues"},{"location":"models/class_open_oasis_1_1_i_argument/#function-getvalue","text":"Gets the current value of the argument. virtual std :: any OpenOasis :: IArgument :: GetValue () const = 0 If no value has been set yet, default value is returned.","title":"function GetValue"},{"location":"models/class_open_oasis_1_1_i_argument/#function-getvaluetype","text":"virtual const std :: type_info & OpenOasis :: IArgument :: GetValueType () const = 0","title":"function GetValueType"},{"location":"models/class_open_oasis_1_1_i_argument/#function-isoptional","text":"Specifies whether the argument is optional. virtual bool OpenOasis :: IArgument :: IsOptional () const = 0 If false, the argument's value must be set before it could be used.","title":"function IsOptional"},{"location":"models/class_open_oasis_1_1_i_argument/#function-isreadonly","text":"virtual bool OpenOasis :: IArgument :: IsReadOnly () const = 0","title":"function IsReadOnly"},{"location":"models/class_open_oasis_1_1_i_argument/#function-setvalue","text":"virtual void OpenOasis :: IArgument :: SetValue ( std :: any value ) = 0 The documentation for this class was generated from the following file Models/Inc/IArgument.h","title":"function SetValue"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/","text":"Class OpenOasis::IBaseExchangeItem \u00b6 ClassList > OpenOasis > IBaseExchangeItem Class presenting a item that can be exchanged, either as an input or output. #include <IBaseExchangeItem.h> Inherits the following classes: OpenOasis::IIdentifiable Inherited by the following classes: OpenOasis::IInput , OpenOasis::IOutput Public Types \u00b6 Type Name typedef std::function< void(std::shared_ptr< ExchangeItemChangeEventArgs >)> ListenFunc Public Functions \u00b6 Type Name virtual void AddListener (const ListenFunc & func) = 0 Adds a listener to the exchange item. virtual std::weak_ptr< ILinkableComponent > GetComponent () const = 0 Gets the owner of the exchange item. virtual std::shared_ptr< IElementSet > GetElementSet () const = 0 Gets the exchange item's elements. If it's id-based, return null. virtual std::shared_ptr< ITimeSet > GetTimeSet () const = 0 Gets the exchange item's available time set. If it's time independent, return null. virtual std::shared_ptr< IValueDefinition > GetValueDefinition () const = 0 Definition of the values in the exchange item. virtual std::shared_ptr< IValueSet > GetValues () = 0 Provides the values matching the value definition specified. Extensions can overwrite this base version to include more details in the query, e.g. time and space. virtual void RemoveListener (const ListenFunc & func) = 0 Removes the listener if it is no more interested at this item. virtual void Reset () = 0 Resets the exchange item. virtual void SetElementSet (std::shared_ptr< IElementSet > elements) = 0 Sets the exchange item's elements. virtual void SetTimeSet (std::shared_ptr< ITimeSet > times) = 0 Sets the exchange item's time set. virtual void SetValues (std::shared_ptr< IValueSet > value) = 0 Sets the exchange item's values. Public Functions inherited from OpenOasis::IIdentifiable \u00b6 See OpenOasis::IIdentifiable Type Name virtual std::string GetId () const = 0 Gets id string. Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Public Types Documentation \u00b6 typedef ListenFunc \u00b6 using OpenOasis :: IBaseExchangeItem :: ListenFunc = std :: function < void ( std :: shared_ptr < ExchangeItemChangeEventArgs > ) > ; Public Functions Documentation \u00b6 function AddListener \u00b6 virtual void OpenOasis :: IBaseExchangeItem :: AddListener ( const ListenFunc & func ) = 0 function GetComponent \u00b6 Gets the owner of the exchange item. virtual std :: weak_ptr < ILinkableComponent > OpenOasis :: IBaseExchangeItem :: GetComponent () const = 0 For an output exchange item this is the component responsible for providing the content of the output item. It's possible for an exchange item to have no owner, in this case the method will return null. function GetElementSet \u00b6 virtual std :: shared_ptr < IElementSet > OpenOasis :: IBaseExchangeItem :: GetElementSet () const = 0 function GetTimeSet \u00b6 virtual std :: shared_ptr < ITimeSet > OpenOasis :: IBaseExchangeItem :: GetTimeSet () const = 0 function GetValueDefinition \u00b6 Definition of the values in the exchange item. virtual std :: shared_ptr < IValueDefinition > OpenOasis :: IBaseExchangeItem :: GetValueDefinition () const = 0 This IValueDefinition should never be returned directly; all implementing classes should return either IQuality , IQuantity , or a custom derived value definition interface. function GetValues \u00b6 Provides the values matching the value definition specified. Extensions can overwrite this base version to include more details in the query, e.g. time and space. virtual std :: shared_ptr < IValueSet > OpenOasis :: IBaseExchangeItem :: GetValues () = 0 For an input item, this means to get the input item's value pulled from its provider(s). For an output item, this means to provide the values required by consumers. function RemoveListener \u00b6 virtual void OpenOasis :: IBaseExchangeItem :: RemoveListener ( const ListenFunc & func ) = 0 function Reset \u00b6 virtual void OpenOasis :: IBaseExchangeItem :: Reset () = 0 function SetElementSet \u00b6 virtual void OpenOasis :: IBaseExchangeItem :: SetElementSet ( std :: shared_ptr < IElementSet > elements ) = 0 function SetTimeSet \u00b6 virtual void OpenOasis :: IBaseExchangeItem :: SetTimeSet ( std :: shared_ptr < ITimeSet > times ) = 0 function SetValues \u00b6 virtual void OpenOasis :: IBaseExchangeItem :: SetValues ( std :: shared_ptr < IValueSet > value ) = 0 The documentation for this class was generated from the following file Models/Inc/IBaseExchangeItem.h","title":"Class OpenOasis::IBaseExchangeItem"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#class-openoasisibaseexchangeitem","text":"ClassList > OpenOasis > IBaseExchangeItem Class presenting a item that can be exchanged, either as an input or output. #include <IBaseExchangeItem.h> Inherits the following classes: OpenOasis::IIdentifiable Inherited by the following classes: OpenOasis::IInput , OpenOasis::IOutput","title":"Class OpenOasis::IBaseExchangeItem"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#public-types","text":"Type Name typedef std::function< void(std::shared_ptr< ExchangeItemChangeEventArgs >)> ListenFunc","title":"Public Types"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#public-functions","text":"Type Name virtual void AddListener (const ListenFunc & func) = 0 Adds a listener to the exchange item. virtual std::weak_ptr< ILinkableComponent > GetComponent () const = 0 Gets the owner of the exchange item. virtual std::shared_ptr< IElementSet > GetElementSet () const = 0 Gets the exchange item's elements. If it's id-based, return null. virtual std::shared_ptr< ITimeSet > GetTimeSet () const = 0 Gets the exchange item's available time set. If it's time independent, return null. virtual std::shared_ptr< IValueDefinition > GetValueDefinition () const = 0 Definition of the values in the exchange item. virtual std::shared_ptr< IValueSet > GetValues () = 0 Provides the values matching the value definition specified. Extensions can overwrite this base version to include more details in the query, e.g. time and space. virtual void RemoveListener (const ListenFunc & func) = 0 Removes the listener if it is no more interested at this item. virtual void Reset () = 0 Resets the exchange item. virtual void SetElementSet (std::shared_ptr< IElementSet > elements) = 0 Sets the exchange item's elements. virtual void SetTimeSet (std::shared_ptr< ITimeSet > times) = 0 Sets the exchange item's time set. virtual void SetValues (std::shared_ptr< IValueSet > value) = 0 Sets the exchange item's values.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#public-functions-inherited-from-openoasisiidentifiable","text":"See OpenOasis::IIdentifiable Type Name virtual std::string GetId () const = 0 Gets id string.","title":"Public Functions inherited from OpenOasis::IIdentifiable"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#typedef-listenfunc","text":"using OpenOasis :: IBaseExchangeItem :: ListenFunc = std :: function < void ( std :: shared_ptr < ExchangeItemChangeEventArgs > ) > ;","title":"typedef ListenFunc"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#function-addlistener","text":"virtual void OpenOasis :: IBaseExchangeItem :: AddListener ( const ListenFunc & func ) = 0","title":"function AddListener"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#function-getcomponent","text":"Gets the owner of the exchange item. virtual std :: weak_ptr < ILinkableComponent > OpenOasis :: IBaseExchangeItem :: GetComponent () const = 0 For an output exchange item this is the component responsible for providing the content of the output item. It's possible for an exchange item to have no owner, in this case the method will return null.","title":"function GetComponent"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#function-getelementset","text":"virtual std :: shared_ptr < IElementSet > OpenOasis :: IBaseExchangeItem :: GetElementSet () const = 0","title":"function GetElementSet"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#function-gettimeset","text":"virtual std :: shared_ptr < ITimeSet > OpenOasis :: IBaseExchangeItem :: GetTimeSet () const = 0","title":"function GetTimeSet"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#function-getvaluedefinition","text":"Definition of the values in the exchange item. virtual std :: shared_ptr < IValueDefinition > OpenOasis :: IBaseExchangeItem :: GetValueDefinition () const = 0 This IValueDefinition should never be returned directly; all implementing classes should return either IQuality , IQuantity , or a custom derived value definition interface.","title":"function GetValueDefinition"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#function-getvalues","text":"Provides the values matching the value definition specified. Extensions can overwrite this base version to include more details in the query, e.g. time and space. virtual std :: shared_ptr < IValueSet > OpenOasis :: IBaseExchangeItem :: GetValues () = 0 For an input item, this means to get the input item's value pulled from its provider(s). For an output item, this means to provide the values required by consumers.","title":"function GetValues"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#function-removelistener","text":"virtual void OpenOasis :: IBaseExchangeItem :: RemoveListener ( const ListenFunc & func ) = 0","title":"function RemoveListener"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#function-reset","text":"virtual void OpenOasis :: IBaseExchangeItem :: Reset () = 0","title":"function Reset"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#function-setelementset","text":"virtual void OpenOasis :: IBaseExchangeItem :: SetElementSet ( std :: shared_ptr < IElementSet > elements ) = 0","title":"function SetElementSet"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#function-settimeset","text":"virtual void OpenOasis :: IBaseExchangeItem :: SetTimeSet ( std :: shared_ptr < ITimeSet > times ) = 0","title":"function SetTimeSet"},{"location":"models/class_open_oasis_1_1_i_base_exchange_item/#function-setvalues","text":"virtual void OpenOasis :: IBaseExchangeItem :: SetValues ( std :: shared_ptr < IValueSet > value ) = 0 The documentation for this class was generated from the following file Models/Inc/IBaseExchangeItem.h","title":"function SetValues"},{"location":"models/class_open_oasis_1_1_i_byte_state_converter/","text":"Class OpenOasis::IByteStateConverter \u00b6 ClassList > OpenOasis > IByteStateConverter An optional interface to save and transform the model state. More... #include <IByteStateConverter.h> Public Functions \u00b6 Type Name virtual std::shared_ptr< IIdentifiable > ConvertFromByteStream (const std::stringstream & byteStream) = 0 Creates a state from a byte stream and return the identifier. virtual std::stringstream ConvertToByteStream (const std::shared_ptr< IIdentifiable > & stateId) = 0 Converts the state with the stateId into a byte stream. Detailed Description \u00b6 This interface is an optional complement to the IManageState interface.Both are extensions to ILinkableComponent , meant to provide state management. It defines methods for converting a state into a byte stream and reading in a state from a byte stream. This facilitates external modules, e.g. a GUI or an operational control system, to save a model's state somewhere as persistent state. Public Functions Documentation \u00b6 function ConvertFromByteStream \u00b6 Creates a state from a byte stream and return the identifier. virtual std :: shared_ptr < IIdentifiable > OpenOasis :: IByteStateConverter :: ConvertFromByteStream ( const std :: stringstream & byteStream ) = 0 Parameters: byteStream State as a byte stream. Returns: IIdentifiable identifying the state. function ConvertToByteStream \u00b6 Converts the state with the stateId into a byte stream. virtual std :: stringstream OpenOasis :: IByteStateConverter :: ConvertToByteStream ( const std :: shared_ptr < IIdentifiable > & stateId ) = 0 Parameters: stateId Id of the state. Returns: The state identified by stateId as a byte stream. The documentation for this class was generated from the following file Models/Inc/IByteStateConverter.h","title":"Class OpenOasis::IByteStateConverter"},{"location":"models/class_open_oasis_1_1_i_byte_state_converter/#class-openoasisibytestateconverter","text":"ClassList > OpenOasis > IByteStateConverter An optional interface to save and transform the model state. More... #include <IByteStateConverter.h>","title":"Class OpenOasis::IByteStateConverter"},{"location":"models/class_open_oasis_1_1_i_byte_state_converter/#public-functions","text":"Type Name virtual std::shared_ptr< IIdentifiable > ConvertFromByteStream (const std::stringstream & byteStream) = 0 Creates a state from a byte stream and return the identifier. virtual std::stringstream ConvertToByteStream (const std::shared_ptr< IIdentifiable > & stateId) = 0 Converts the state with the stateId into a byte stream.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_byte_state_converter/#detailed-description","text":"This interface is an optional complement to the IManageState interface.Both are extensions to ILinkableComponent , meant to provide state management. It defines methods for converting a state into a byte stream and reading in a state from a byte stream. This facilitates external modules, e.g. a GUI or an operational control system, to save a model's state somewhere as persistent state.","title":"Detailed Description"},{"location":"models/class_open_oasis_1_1_i_byte_state_converter/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_byte_state_converter/#function-convertfrombytestream","text":"Creates a state from a byte stream and return the identifier. virtual std :: shared_ptr < IIdentifiable > OpenOasis :: IByteStateConverter :: ConvertFromByteStream ( const std :: stringstream & byteStream ) = 0 Parameters: byteStream State as a byte stream. Returns: IIdentifiable identifying the state.","title":"function ConvertFromByteStream"},{"location":"models/class_open_oasis_1_1_i_byte_state_converter/#function-converttobytestream","text":"Converts the state with the stateId into a byte stream. virtual std :: stringstream OpenOasis :: IByteStateConverter :: ConvertToByteStream ( const std :: shared_ptr < IIdentifiable > & stateId ) = 0 Parameters: stateId Id of the state. Returns: The state identified by stateId as a byte stream. The documentation for this class was generated from the following file Models/Inc/IByteStateConverter.h","title":"function ConvertToByteStream"},{"location":"models/class_open_oasis_1_1_i_category/","text":"Class OpenOasis::ICategory \u00b6 ClassList > OpenOasis > ICategory Class describes one item of a possible categorization. More... #include <ICategory.h> Inherits the following classes: OpenOasis::IDescribable Public Functions \u00b6 Type Name virtual std::any GetValue () const = 0 Value for this category. Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Detailed Description \u00b6 It is used by the IQuality interface for describing qualitative data. A category defines one \"class\" within a \"set of classes\". For qualitative data the IValueSet exchanged between ILinkableComponent contains one of the possible ICategory instances per data element. Public Functions Documentation \u00b6 function GetValue \u00b6 Value for this category. virtual std :: any OpenOasis :: ICategory :: GetValue () const = 0 Example, \"blue\" in a {\"red\", \"green\", \"blue\"} set. The documentation for this class was generated from the following file Models/Inc/ICategory.h","title":"Class OpenOasis::ICategory"},{"location":"models/class_open_oasis_1_1_i_category/#class-openoasisicategory","text":"ClassList > OpenOasis > ICategory Class describes one item of a possible categorization. More... #include <ICategory.h> Inherits the following classes: OpenOasis::IDescribable","title":"Class OpenOasis::ICategory"},{"location":"models/class_open_oasis_1_1_i_category/#public-functions","text":"Type Name virtual std::any GetValue () const = 0 Value for this category.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_category/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_category/#detailed-description","text":"It is used by the IQuality interface for describing qualitative data. A category defines one \"class\" within a \"set of classes\". For qualitative data the IValueSet exchanged between ILinkableComponent contains one of the possible ICategory instances per data element.","title":"Detailed Description"},{"location":"models/class_open_oasis_1_1_i_category/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_category/#function-getvalue","text":"Value for this category. virtual std :: any OpenOasis :: ICategory :: GetValue () const = 0 Example, \"blue\" in a {\"red\", \"green\", \"blue\"} set. The documentation for this class was generated from the following file Models/Inc/ICategory.h","title":"function GetValue"},{"location":"models/class_open_oasis_1_1_i_describable/","text":"Class OpenOasis::IDescribable \u00b6 ClassList > OpenOasis > IDescribable An entity that is describable has a caption (title or heading) and a description. These are not to be used for identification. #include <IDescribable.h> Inherited by the following classes: OpenOasis::ICategory , OpenOasis::IIdentifiable , OpenOasis::ISpatialDefinition , OpenOasis::IUnit , OpenOasis::IValueDefinition Public Functions \u00b6 Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Public Functions Documentation \u00b6 function GetCaption \u00b6 virtual std :: string OpenOasis :: IDescribable :: GetCaption () const = 0 function GetDescription \u00b6 virtual std :: string OpenOasis :: IDescribable :: GetDescription () const = 0 function SetCaption \u00b6 virtual void OpenOasis :: IDescribable :: SetCaption ( const std :: string & value ) = 0 function SetDescription \u00b6 virtual void OpenOasis :: IDescribable :: SetDescription ( const std :: string & value ) = 0 The documentation for this class was generated from the following file Models/Inc/IDescribable.h","title":"Class OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_describable/#class-openoasisidescribable","text":"ClassList > OpenOasis > IDescribable An entity that is describable has a caption (title or heading) and a description. These are not to be used for identification. #include <IDescribable.h> Inherited by the following classes: OpenOasis::ICategory , OpenOasis::IIdentifiable , OpenOasis::ISpatialDefinition , OpenOasis::IUnit , OpenOasis::IValueDefinition","title":"Class OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_describable/#public-functions","text":"Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_describable/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_describable/#function-getcaption","text":"virtual std :: string OpenOasis :: IDescribable :: GetCaption () const = 0","title":"function GetCaption"},{"location":"models/class_open_oasis_1_1_i_describable/#function-getdescription","text":"virtual std :: string OpenOasis :: IDescribable :: GetDescription () const = 0","title":"function GetDescription"},{"location":"models/class_open_oasis_1_1_i_describable/#function-setcaption","text":"virtual void OpenOasis :: IDescribable :: SetCaption ( const std :: string & value ) = 0","title":"function SetCaption"},{"location":"models/class_open_oasis_1_1_i_describable/#function-setdescription","text":"virtual void OpenOasis :: IDescribable :: SetDescription ( const std :: string & value ) = 0 The documentation for this class was generated from the following file Models/Inc/IDescribable.h","title":"function SetDescription"},{"location":"models/class_open_oasis_1_1_i_dimension/","text":"Class OpenOasis::IDimension \u00b6 ClassList > OpenOasis > IDimension Define the order of each dimension in DimensionBase for a unit. #include <IDimension.h> Public Functions \u00b6 Type Name virtual double GetPower ( DimensionBase baseQuantity) const = 0 Gets the power for the requested dimension. virtual void SetPower ( DimensionBase baseQuantity, double power) = 0 Sets a power for a base dimension. Public Functions Documentation \u00b6 function GetPower \u00b6 Gets the power for the requested dimension. virtual double OpenOasis :: IDimension :: GetPower ( DimensionBase baseQuantity ) const = 0 Example, For a quantity such as flow, which may have the unit m3/s, the GetPower method must work as follows: Flow.GetPower(DimensionBase::AmountOfSubstance) --> returns 0 Flow.GetPower(DimensionBase::Currency) --> returns 0 Flow.GetPower(DimensionBase::ElectricCurrent) --> returns 0 Flow.GetPower(DimensionBase::Length) --> returns 3 Flow.GetPower(DimensionBase::LuminousIntensity) --> returns 0 Flow.GetPower(DimensionBase::Mass) --> returns 0 Flow.GetPower(DimensionBase::Temperature) --> returns 0 Flow.GetPower(DimensionBase::Time) --> returns -1 function SetPower \u00b6 Sets a power for a base dimension. virtual void OpenOasis :: IDimension :: SetPower ( DimensionBase baseQuantity , double power ) = 0 Parameters: baseQuantity The base dimension. power The power. The documentation for this class was generated from the following file Models/Inc/IDimension.h","title":"Class OpenOasis::IDimension"},{"location":"models/class_open_oasis_1_1_i_dimension/#class-openoasisidimension","text":"ClassList > OpenOasis > IDimension Define the order of each dimension in DimensionBase for a unit. #include <IDimension.h>","title":"Class OpenOasis::IDimension"},{"location":"models/class_open_oasis_1_1_i_dimension/#public-functions","text":"Type Name virtual double GetPower ( DimensionBase baseQuantity) const = 0 Gets the power for the requested dimension. virtual void SetPower ( DimensionBase baseQuantity, double power) = 0 Sets a power for a base dimension.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_dimension/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_dimension/#function-getpower","text":"Gets the power for the requested dimension. virtual double OpenOasis :: IDimension :: GetPower ( DimensionBase baseQuantity ) const = 0 Example, For a quantity such as flow, which may have the unit m3/s, the GetPower method must work as follows: Flow.GetPower(DimensionBase::AmountOfSubstance) --> returns 0 Flow.GetPower(DimensionBase::Currency) --> returns 0 Flow.GetPower(DimensionBase::ElectricCurrent) --> returns 0 Flow.GetPower(DimensionBase::Length) --> returns 3 Flow.GetPower(DimensionBase::LuminousIntensity) --> returns 0 Flow.GetPower(DimensionBase::Mass) --> returns 0 Flow.GetPower(DimensionBase::Temperature) --> returns 0 Flow.GetPower(DimensionBase::Time) --> returns -1","title":"function GetPower"},{"location":"models/class_open_oasis_1_1_i_dimension/#function-setpower","text":"Sets a power for a base dimension. virtual void OpenOasis :: IDimension :: SetPower ( DimensionBase baseQuantity , double power ) = 0 Parameters: baseQuantity The base dimension. power The power. The documentation for this class was generated from the following file Models/Inc/IDimension.h","title":"function SetPower"},{"location":"models/class_open_oasis_1_1_i_element_set/","text":"Class OpenOasis::IElementSet \u00b6 ClassList > OpenOasis > IElementSet An list of elements having a common type. #include <IElementSet.h> Inherits the following classes: OpenOasis::ISpatialDefinition Public Functions \u00b6 Type Name virtual std::string GetElementId (int index) = 0 Gets Id of the index element in the element set. virtual int GetElementIndex (const std::string & elementId) = 0 Index of element with id 'elementId' in the element set. virtual ElementType GetElementType () const = 0 Gets ElementType of the elementset. virtual int GetFaceCount (int elementIndex) = 0 Gets the number of faces in a element. virtual std::vector< int > GetFaceNodeIndices (int elementIndex, int faceIndex) = 0 Gets an array with the node indices for a face. virtual int GetNodeCount (int elementIndex) = 0 Gets number of nodes for the element specified by the index. virtual double GetNodeXCoordinate (int elementIndex, int nodeIndex) = 0 X coordinate for the node with nodeIndex of the element with elementIndex. virtual double GetNodeYCoordinate (int elementIndex, int nodeIndex) = 0 Y coordinate for the node with nodeIndex of the element with elementIndex. virtual double GetNodeZCoordinate (int elementIndex, int nodeIndex) = 0 Z coordinate for the node with nodeIndex of the element with elementIndex. Public Functions inherited from OpenOasis::ISpatialDefinition \u00b6 See OpenOasis::ISpatialDefinition Type Name virtual int GetElementCount () const = 0 Gets number of data elements in the spatial axis. virtual std::string GetSpatialReferenceSystem () const = 0 Specifies the OGC Well-Known Text(WKT) representation of spatial reference system to be used in association with the coordinates in the ISpatialDefinition . virtual int GetVersion () const = 0 Gets the version number for the spatial axis. Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Public Functions Documentation \u00b6 function GetElementId \u00b6 Gets Id of the index element in the element set. virtual std :: string OpenOasis :: IElementSet :: GetElementId ( int index ) = 0 Parameters: index The element index for which the element Id is requested. Returns: The id of the element with the specified index. If the ElementType of the elementset is not IdBased , an empty string may be returned. Exception: If the index outside the range, throw an exception. function GetElementIndex \u00b6 Index of element with id 'elementId' in the element set. virtual int OpenOasis :: IElementSet :: GetElementIndex ( const std :: string & elementId ) = 0 Parameters: elementId Identification string of the element required. Returns: Index of the element with the specified id; return -1 if not found. function GetElementType \u00b6 virtual ElementType OpenOasis :: IElementSet :: GetElementType () const = 0 function GetFaceCount \u00b6 Gets the number of faces in a element. virtual int OpenOasis :: IElementSet :: GetFaceCount ( int elementIndex ) = 0 Parameters: elementIndex Index for the element. Returns: Number of faces. Exception: If the index outside the range, throw an exception. function GetFaceNodeIndices \u00b6 Gets an array with the node indices for a face. virtual std :: vector < int > OpenOasis :: IElementSet :: GetFaceNodeIndices ( int elementIndex , int faceIndex ) = 0 Parameters: elementIndex Element index. faceIndex Face index. Returns: The node indices for this face. function GetNodeCount \u00b6 Gets number of nodes for the element specified by the index. virtual int OpenOasis :: IElementSet :: GetNodeCount ( int elementIndex ) = 0 Parameters: elementIndex The element index for the element. Returns: Number of nodes in element defined by the elementIndex. Exception: If the index outside the range, throw an exception. If the method is invoked with type IdBased , throw an exception. function GetNodeXCoordinate \u00b6 X coordinate for the node with nodeIndex of the element with elementIndex. virtual double OpenOasis :: IElementSet :: GetNodeXCoordinate ( int elementIndex , int nodeIndex ) = 0 Parameters: elementIndex Element index. nodeIndex Node index in the element with index elementIndex. Returns: X coordinate for the node. function GetNodeYCoordinate \u00b6 Y coordinate for the node with nodeIndex of the element with elementIndex. virtual double OpenOasis :: IElementSet :: GetNodeYCoordinate ( int elementIndex , int nodeIndex ) = 0 Parameters: elementIndex Element index. nodeIndex Node index in the element with index elementIndex. Returns: Y coordinate for the node. function GetNodeZCoordinate \u00b6 Z coordinate for the node with nodeIndex of the element with elementIndex. virtual double OpenOasis :: IElementSet :: GetNodeZCoordinate ( int elementIndex , int nodeIndex ) = 0 Parameters: elementIndex Element index. nodeIndex Node index in the element with index elementIndex. Returns: Z coordinate for the node. The documentation for this class was generated from the following file Models/Inc/IElementSet.h","title":"Class OpenOasis::IElementSet"},{"location":"models/class_open_oasis_1_1_i_element_set/#class-openoasisielementset","text":"ClassList > OpenOasis > IElementSet An list of elements having a common type. #include <IElementSet.h> Inherits the following classes: OpenOasis::ISpatialDefinition","title":"Class OpenOasis::IElementSet"},{"location":"models/class_open_oasis_1_1_i_element_set/#public-functions","text":"Type Name virtual std::string GetElementId (int index) = 0 Gets Id of the index element in the element set. virtual int GetElementIndex (const std::string & elementId) = 0 Index of element with id 'elementId' in the element set. virtual ElementType GetElementType () const = 0 Gets ElementType of the elementset. virtual int GetFaceCount (int elementIndex) = 0 Gets the number of faces in a element. virtual std::vector< int > GetFaceNodeIndices (int elementIndex, int faceIndex) = 0 Gets an array with the node indices for a face. virtual int GetNodeCount (int elementIndex) = 0 Gets number of nodes for the element specified by the index. virtual double GetNodeXCoordinate (int elementIndex, int nodeIndex) = 0 X coordinate for the node with nodeIndex of the element with elementIndex. virtual double GetNodeYCoordinate (int elementIndex, int nodeIndex) = 0 Y coordinate for the node with nodeIndex of the element with elementIndex. virtual double GetNodeZCoordinate (int elementIndex, int nodeIndex) = 0 Z coordinate for the node with nodeIndex of the element with elementIndex.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_element_set/#public-functions-inherited-from-openoasisispatialdefinition","text":"See OpenOasis::ISpatialDefinition Type Name virtual int GetElementCount () const = 0 Gets number of data elements in the spatial axis. virtual std::string GetSpatialReferenceSystem () const = 0 Specifies the OGC Well-Known Text(WKT) representation of spatial reference system to be used in association with the coordinates in the ISpatialDefinition . virtual int GetVersion () const = 0 Gets the version number for the spatial axis.","title":"Public Functions inherited from OpenOasis::ISpatialDefinition"},{"location":"models/class_open_oasis_1_1_i_element_set/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_element_set/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_element_set/#function-getelementid","text":"Gets Id of the index element in the element set. virtual std :: string OpenOasis :: IElementSet :: GetElementId ( int index ) = 0 Parameters: index The element index for which the element Id is requested. Returns: The id of the element with the specified index. If the ElementType of the elementset is not IdBased , an empty string may be returned. Exception: If the index outside the range, throw an exception.","title":"function GetElementId"},{"location":"models/class_open_oasis_1_1_i_element_set/#function-getelementindex","text":"Index of element with id 'elementId' in the element set. virtual int OpenOasis :: IElementSet :: GetElementIndex ( const std :: string & elementId ) = 0 Parameters: elementId Identification string of the element required. Returns: Index of the element with the specified id; return -1 if not found.","title":"function GetElementIndex"},{"location":"models/class_open_oasis_1_1_i_element_set/#function-getelementtype","text":"virtual ElementType OpenOasis :: IElementSet :: GetElementType () const = 0","title":"function GetElementType"},{"location":"models/class_open_oasis_1_1_i_element_set/#function-getfacecount","text":"Gets the number of faces in a element. virtual int OpenOasis :: IElementSet :: GetFaceCount ( int elementIndex ) = 0 Parameters: elementIndex Index for the element. Returns: Number of faces. Exception: If the index outside the range, throw an exception.","title":"function GetFaceCount"},{"location":"models/class_open_oasis_1_1_i_element_set/#function-getfacenodeindices","text":"Gets an array with the node indices for a face. virtual std :: vector < int > OpenOasis :: IElementSet :: GetFaceNodeIndices ( int elementIndex , int faceIndex ) = 0 Parameters: elementIndex Element index. faceIndex Face index. Returns: The node indices for this face.","title":"function GetFaceNodeIndices"},{"location":"models/class_open_oasis_1_1_i_element_set/#function-getnodecount","text":"Gets number of nodes for the element specified by the index. virtual int OpenOasis :: IElementSet :: GetNodeCount ( int elementIndex ) = 0 Parameters: elementIndex The element index for the element. Returns: Number of nodes in element defined by the elementIndex. Exception: If the index outside the range, throw an exception. If the method is invoked with type IdBased , throw an exception.","title":"function GetNodeCount"},{"location":"models/class_open_oasis_1_1_i_element_set/#function-getnodexcoordinate","text":"X coordinate for the node with nodeIndex of the element with elementIndex. virtual double OpenOasis :: IElementSet :: GetNodeXCoordinate ( int elementIndex , int nodeIndex ) = 0 Parameters: elementIndex Element index. nodeIndex Node index in the element with index elementIndex. Returns: X coordinate for the node.","title":"function GetNodeXCoordinate"},{"location":"models/class_open_oasis_1_1_i_element_set/#function-getnodeycoordinate","text":"Y coordinate for the node with nodeIndex of the element with elementIndex. virtual double OpenOasis :: IElementSet :: GetNodeYCoordinate ( int elementIndex , int nodeIndex ) = 0 Parameters: elementIndex Element index. nodeIndex Node index in the element with index elementIndex. Returns: Y coordinate for the node.","title":"function GetNodeYCoordinate"},{"location":"models/class_open_oasis_1_1_i_element_set/#function-getnodezcoordinate","text":"Z coordinate for the node with nodeIndex of the element with elementIndex. virtual double OpenOasis :: IElementSet :: GetNodeZCoordinate ( int elementIndex , int nodeIndex ) = 0 Parameters: elementIndex Element index. nodeIndex Node index in the element with index elementIndex. Returns: Z coordinate for the node. The documentation for this class was generated from the following file Models/Inc/IElementSet.h","title":"function GetNodeZCoordinate"},{"location":"models/class_open_oasis_1_1_i_identifiable/","text":"Class OpenOasis::IIdentifiable \u00b6 ClassList > OpenOasis > IIdentifiable To define a method to get the Id of an OpenOasis entity. #include <IIdentifiable.h> Inherits the following classes: OpenOasis::IDescribable Inherited by the following classes: OpenOasis::IAdaptedOutputFactory , OpenOasis::IArgument , OpenOasis::IBaseExchangeItem , OpenOasis::ILinkableComponent Public Functions \u00b6 Type Name virtual std::string GetId () const = 0 Gets id string. Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Public Functions Documentation \u00b6 function GetId \u00b6 Gets id string. virtual std :: string OpenOasis :: IIdentifiable :: GetId () const = 0 The Id must be unique within its context but does not need to be globally unique. e.g. the id of an input exchange item must be unique in the list of inputs of ILinkableComponent , but a similar Id might be used by an exchange item of another ILinkableComponent . The documentation for this class was generated from the following file Models/Inc/IIdentifiable.h","title":"Class OpenOasis::IIdentifiable"},{"location":"models/class_open_oasis_1_1_i_identifiable/#class-openoasisiidentifiable","text":"ClassList > OpenOasis > IIdentifiable To define a method to get the Id of an OpenOasis entity. #include <IIdentifiable.h> Inherits the following classes: OpenOasis::IDescribable Inherited by the following classes: OpenOasis::IAdaptedOutputFactory , OpenOasis::IArgument , OpenOasis::IBaseExchangeItem , OpenOasis::ILinkableComponent","title":"Class OpenOasis::IIdentifiable"},{"location":"models/class_open_oasis_1_1_i_identifiable/#public-functions","text":"Type Name virtual std::string GetId () const = 0 Gets id string.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_identifiable/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_identifiable/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_identifiable/#function-getid","text":"Gets id string. virtual std :: string OpenOasis :: IIdentifiable :: GetId () const = 0 The Id must be unique within its context but does not need to be globally unique. e.g. the id of an input exchange item must be unique in the list of inputs of ILinkableComponent , but a similar Id might be used by an exchange item of another ILinkableComponent . The documentation for this class was generated from the following file Models/Inc/IIdentifiable.h","title":"function GetId"},{"location":"models/class_open_oasis_1_1_i_input/","text":"Class OpenOasis::IInput \u00b6 ClassList > OpenOasis > IInput An input item that can accept values for an ILinkableComponent . The input item may have multiple providers. #include <IInput.h> Inherits the following classes: OpenOasis::IBaseExchangeItem Public Types inherited from OpenOasis::IBaseExchangeItem \u00b6 See OpenOasis::IBaseExchangeItem Type Name typedef std::function< void(std::shared_ptr< ExchangeItemChangeEventArgs >)> ListenFunc Public Functions \u00b6 Type Name virtual void AddProvider (std::shared_ptr< IOutput > provider) = 0 Adds a provider for this input item. virtual std::vector< std::weak_ptr< IOutput > > GetProviders () const = 0 Gets the providers that this input should get its values from. virtual void RemoveProvider (const std::shared_ptr< IOutput > & provider) = 0 Removes specified provider from this input item. Public Functions inherited from OpenOasis::IBaseExchangeItem \u00b6 See OpenOasis::IBaseExchangeItem Type Name virtual void AddListener (const ListenFunc & func) = 0 Adds a listener to the exchange item. virtual std::weak_ptr< ILinkableComponent > GetComponent () const = 0 Gets the owner of the exchange item. virtual std::shared_ptr< IElementSet > GetElementSet () const = 0 Gets the exchange item's elements. If it's id-based, return null. virtual std::shared_ptr< ITimeSet > GetTimeSet () const = 0 Gets the exchange item's available time set. If it's time independent, return null. virtual std::shared_ptr< IValueDefinition > GetValueDefinition () const = 0 Definition of the values in the exchange item. virtual std::shared_ptr< IValueSet > GetValues () = 0 Provides the values matching the value definition specified. Extensions can overwrite this base version to include more details in the query, e.g. time and space. virtual void RemoveListener (const ListenFunc & func) = 0 Removes the listener if it is no more interested at this item. virtual void Reset () = 0 Resets the exchange item. virtual void SetElementSet (std::shared_ptr< IElementSet > elements) = 0 Sets the exchange item's elements. virtual void SetTimeSet (std::shared_ptr< ITimeSet > times) = 0 Sets the exchange item's time set. virtual void SetValues (std::shared_ptr< IValueSet > value) = 0 Sets the exchange item's values. Public Functions inherited from OpenOasis::IIdentifiable \u00b6 See OpenOasis::IIdentifiable Type Name virtual std::string GetId () const = 0 Gets id string. Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Public Functions Documentation \u00b6 function AddProvider \u00b6 virtual void OpenOasis :: IInput :: AddProvider ( std :: shared_ptr < IOutput > provider ) = 0 function GetProviders \u00b6 Gets the providers that this input should get its values from. virtual std :: vector < std :: weak_ptr < IOutput > > OpenOasis :: IInput :: GetProviders () const = 0 An IOutput item provides data while calling its GetValues() . function RemoveProvider \u00b6 virtual void OpenOasis :: IInput :: RemoveProvider ( const std :: shared_ptr < IOutput > & provider ) = 0 The documentation for this class was generated from the following file Models/Inc/IInput.h","title":"Class OpenOasis::IInput"},{"location":"models/class_open_oasis_1_1_i_input/#class-openoasisiinput","text":"ClassList > OpenOasis > IInput An input item that can accept values for an ILinkableComponent . The input item may have multiple providers. #include <IInput.h> Inherits the following classes: OpenOasis::IBaseExchangeItem","title":"Class OpenOasis::IInput"},{"location":"models/class_open_oasis_1_1_i_input/#public-types-inherited-from-openoasisibaseexchangeitem","text":"See OpenOasis::IBaseExchangeItem Type Name typedef std::function< void(std::shared_ptr< ExchangeItemChangeEventArgs >)> ListenFunc","title":"Public Types inherited from OpenOasis::IBaseExchangeItem"},{"location":"models/class_open_oasis_1_1_i_input/#public-functions","text":"Type Name virtual void AddProvider (std::shared_ptr< IOutput > provider) = 0 Adds a provider for this input item. virtual std::vector< std::weak_ptr< IOutput > > GetProviders () const = 0 Gets the providers that this input should get its values from. virtual void RemoveProvider (const std::shared_ptr< IOutput > & provider) = 0 Removes specified provider from this input item.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_input/#public-functions-inherited-from-openoasisibaseexchangeitem","text":"See OpenOasis::IBaseExchangeItem Type Name virtual void AddListener (const ListenFunc & func) = 0 Adds a listener to the exchange item. virtual std::weak_ptr< ILinkableComponent > GetComponent () const = 0 Gets the owner of the exchange item. virtual std::shared_ptr< IElementSet > GetElementSet () const = 0 Gets the exchange item's elements. If it's id-based, return null. virtual std::shared_ptr< ITimeSet > GetTimeSet () const = 0 Gets the exchange item's available time set. If it's time independent, return null. virtual std::shared_ptr< IValueDefinition > GetValueDefinition () const = 0 Definition of the values in the exchange item. virtual std::shared_ptr< IValueSet > GetValues () = 0 Provides the values matching the value definition specified. Extensions can overwrite this base version to include more details in the query, e.g. time and space. virtual void RemoveListener (const ListenFunc & func) = 0 Removes the listener if it is no more interested at this item. virtual void Reset () = 0 Resets the exchange item. virtual void SetElementSet (std::shared_ptr< IElementSet > elements) = 0 Sets the exchange item's elements. virtual void SetTimeSet (std::shared_ptr< ITimeSet > times) = 0 Sets the exchange item's time set. virtual void SetValues (std::shared_ptr< IValueSet > value) = 0 Sets the exchange item's values.","title":"Public Functions inherited from OpenOasis::IBaseExchangeItem"},{"location":"models/class_open_oasis_1_1_i_input/#public-functions-inherited-from-openoasisiidentifiable","text":"See OpenOasis::IIdentifiable Type Name virtual std::string GetId () const = 0 Gets id string.","title":"Public Functions inherited from OpenOasis::IIdentifiable"},{"location":"models/class_open_oasis_1_1_i_input/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_input/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_input/#function-addprovider","text":"virtual void OpenOasis :: IInput :: AddProvider ( std :: shared_ptr < IOutput > provider ) = 0","title":"function AddProvider"},{"location":"models/class_open_oasis_1_1_i_input/#function-getproviders","text":"Gets the providers that this input should get its values from. virtual std :: vector < std :: weak_ptr < IOutput > > OpenOasis :: IInput :: GetProviders () const = 0 An IOutput item provides data while calling its GetValues() .","title":"function GetProviders"},{"location":"models/class_open_oasis_1_1_i_input/#function-removeprovider","text":"virtual void OpenOasis :: IInput :: RemoveProvider ( const std :: shared_ptr < IOutput > & provider ) = 0 The documentation for this class was generated from the following file Models/Inc/IInput.h","title":"function RemoveProvider"},{"location":"models/class_open_oasis_1_1_i_linkable_component/","text":"Class OpenOasis::ILinkableComponent \u00b6 ClassList > OpenOasis > ILinkableComponent The key interface class for linkable modules connection and data transfer. #include <ILinkableComponent.h> Inherits the following classes: OpenOasis::IIdentifiable Public Types \u00b6 Type Name typedef std::function< void(std::shared_ptr< LinkableComponentStatusChangeEventArgs >)> ListenFunc Public Functions \u00b6 Type Name virtual void AddListener (const ListenFunc & func) = 0 virtual void Finish () = 0 Finishes the component computation, and then restart it if needed. virtual std::vector< std::shared_ptr< IAdaptedOutputFactory > > GetAdaptedOutputFactories () const = 0 Gets the list of IAdaptedOutputFactory , each allowing to create IAdaptedOutput item for making output fit to inputs in case they do not already do so. virtual std::vector< std::shared_ptr< IArgument > > GetArguments () const = 0 Gets arguments needed to let the component do its work. virtual std::vector< std::shared_ptr< IInput > > GetInputs () const = 0 Gets the input items for recieving values. virtual std::vector< std::shared_ptr< IOutput > > GetOutputs () const = 0 Gets the output items for producing results. virtual LinkableComponentStatus GetStatus () const = 0 Gets status of the linkable component. virtual void Initialize () = 0 Initializes the component. virtual void Prepare () = 0 Prepares the component for calls to the Update() . virtual void RemoveListener (const ListenFunc & func) = 0 virtual void Update () = 0 Updates the linkable component itself, thus reaching its next state. virtual std::vector< std::string > Validate () = 0 Validates the populated instance of the component. Public Functions inherited from OpenOasis::IIdentifiable \u00b6 See OpenOasis::IIdentifiable Type Name virtual std::string GetId () const = 0 Gets id string. Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Public Types Documentation \u00b6 typedef ListenFunc \u00b6 using OpenOasis :: ILinkableComponent :: ListenFunc = std :: function < void ( std :: shared_ptr < LinkableComponentStatusChangeEventArgs > ) > ; Public Functions Documentation \u00b6 function AddListener \u00b6 virtual void OpenOasis :: ILinkableComponent :: AddListener ( const ListenFunc & func ) = 0 function Finish \u00b6 Finishes the component computation, and then restart it if needed. virtual void OpenOasis :: ILinkableComponent :: Finish () = 0 This method is and must be invoked as the last of any methods in the ILinkableComponent interfaces. Immediatly after this method is invoked, it changes the component's status to Finishing . Once the finishing is completed, the component changes status to Finished if it can't be restarted; Created , otherwise. Exception: This method must be accessible after the Prepare() method has been invoked. Otherwise,the component can't handled this, an exception must be thrown. function GetAdaptedOutputFactories \u00b6 virtual std :: vector < std :: shared_ptr < IAdaptedOutputFactory > > OpenOasis :: ILinkableComponent :: GetAdaptedOutputFactories () const = 0 function GetArguments \u00b6 Gets arguments needed to let the component do its work. virtual std :: vector < std :: shared_ptr < IArgument > > OpenOasis :: ILinkableComponent :: GetArguments () const = 0 Arguments validations can be done either when they occur, or when the Initialize() method is called. function GetInputs \u00b6 Gets the input items for recieving values. virtual std :: vector < std :: shared_ptr < IInput > > OpenOasis :: ILinkableComponent :: GetInputs () const = 0 Exception: The method must be accessible after Initialize() method has been called and until the Validate() method has been invoked. Otherwise, LinkableComponent can't handle this, an exception must be thrown. function GetOutputs \u00b6 Gets the output items for producing results. virtual std :: vector < std :: shared_ptr < IOutput > > OpenOasis :: ILinkableComponent :: GetOutputs () const = 0 Exception: The method must be accessible after Initialize() method has been invoked and until Validate() method has been invoked. Otherwise, LinkableComponent cant handle this, an exception must be thrown. function GetStatus \u00b6 Gets status of the linkable component. virtual LinkableComponentStatus OpenOasis :: ILinkableComponent :: GetStatus () const = 0 The first status that a component sets is Created , as soon after it has been created. function Initialize \u00b6 Initializes the component. virtual void OpenOasis :: ILinkableComponent :: Initialize () = 0 The Initialize() will and must be invoked before any other methods in the ILinkableComponent interface is invoked or accessed, except for the GetArguments . Immediatly after the method is been invoked, it changes the linkable component's status to Initializing . If component initializes succesfully, the status is changed to Initialized . The method will typically populate the component based on values specified in its arguments. Settings can be used to read input files, allocate memory, and organize input and output items. Exception: When the method is executed and an error occurs, the status will change to Failed , and an exception will be thrown. It's only required that Initialize() can be invoked once. If the Initialize() method is invoked more than once, ILinkableComponent can't handle this, thrown an exception. function Prepare \u00b6 Prepares the component for calls to the Update() . virtual void OpenOasis :: ILinkableComponent :: Prepare () = 0 Before Prepare() is called, the component are not required to honor any type of action that retrieves values from the component. After Prepare() is called, the component must be ready for providing values. Immediatly after the method is invoked, it changes the component's status to Preparing . When the method has finished, the status of the component has changed to either Updated or Failed . Exception: The method must be accessible after the Initialize() method has been called and until the Finish() method has been invoked. Otherwise, the linkable component can't handle it, an exception must be thrown. It's required the Prepare() method can be invoked once. Otherwise, the linkable component can't handle this, an exception must be thrown. function RemoveListener \u00b6 virtual void OpenOasis :: ILinkableComponent :: RemoveListener ( const ListenFunc & func ) = 0 function Update \u00b6 Updates the linkable component itself, thus reaching its next state. virtual void OpenOasis :: ILinkableComponent :: Update () = 0 Immediately after Update() is invoked, it changes the component's status to Updating . If the method is performed succesfully, the component sets its status to Updated , unless after this update action is at the end of its computation, in which case it will set its status to Done . According to the 'pull-driven' approach, linkable components can be connected in a chain, where invoking Update() method on the last component in the chain trigger the entire stack of data exchange. The type of actions a component takes during the Update() method depends on the type of component. A numerical model that progresses in time will typically compute a time step. A database would typically look at the consumers of its output items, and perform one or more queries to be able to provide the values that the consumers required. Exception: If during the Update() method problem arises, the component sets its state to Failed and throws an exception. function Validate \u00b6 Validates the populated instance of the component. virtual std :: vector < std :: string > OpenOasis :: ILinkableComponent :: Validate () = 0 The method will must be invoked after various provider/consumer relations between this component's exchange items and the exchange items of other components present in the composition. Immediatly after this method is invoked, it changes the component's status to Validating . When the method has finished, the status of the component has changed to either Valid or Invalid . If there are messages while components status is Valid , the messages are purely informative. If there're messages while components status is Invalid , at least one of the messages indicates a fatal error. Exception: The method must be accessible after the Initialize() has been called and until the Finish() method has been invoked. Otherwise, the linkable component can not handle this, an exception must be thrown. The documentation for this class was generated from the following file Models/Inc/ILinkableComponent.h","title":"Class OpenOasis::ILinkableComponent"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#class-openoasisilinkablecomponent","text":"ClassList > OpenOasis > ILinkableComponent The key interface class for linkable modules connection and data transfer. #include <ILinkableComponent.h> Inherits the following classes: OpenOasis::IIdentifiable","title":"Class OpenOasis::ILinkableComponent"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#public-types","text":"Type Name typedef std::function< void(std::shared_ptr< LinkableComponentStatusChangeEventArgs >)> ListenFunc","title":"Public Types"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#public-functions","text":"Type Name virtual void AddListener (const ListenFunc & func) = 0 virtual void Finish () = 0 Finishes the component computation, and then restart it if needed. virtual std::vector< std::shared_ptr< IAdaptedOutputFactory > > GetAdaptedOutputFactories () const = 0 Gets the list of IAdaptedOutputFactory , each allowing to create IAdaptedOutput item for making output fit to inputs in case they do not already do so. virtual std::vector< std::shared_ptr< IArgument > > GetArguments () const = 0 Gets arguments needed to let the component do its work. virtual std::vector< std::shared_ptr< IInput > > GetInputs () const = 0 Gets the input items for recieving values. virtual std::vector< std::shared_ptr< IOutput > > GetOutputs () const = 0 Gets the output items for producing results. virtual LinkableComponentStatus GetStatus () const = 0 Gets status of the linkable component. virtual void Initialize () = 0 Initializes the component. virtual void Prepare () = 0 Prepares the component for calls to the Update() . virtual void RemoveListener (const ListenFunc & func) = 0 virtual void Update () = 0 Updates the linkable component itself, thus reaching its next state. virtual std::vector< std::string > Validate () = 0 Validates the populated instance of the component.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#public-functions-inherited-from-openoasisiidentifiable","text":"See OpenOasis::IIdentifiable Type Name virtual std::string GetId () const = 0 Gets id string.","title":"Public Functions inherited from OpenOasis::IIdentifiable"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#public-types-documentation","text":"","title":"Public Types Documentation"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#typedef-listenfunc","text":"using OpenOasis :: ILinkableComponent :: ListenFunc = std :: function < void ( std :: shared_ptr < LinkableComponentStatusChangeEventArgs > ) > ;","title":"typedef ListenFunc"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#function-addlistener","text":"virtual void OpenOasis :: ILinkableComponent :: AddListener ( const ListenFunc & func ) = 0","title":"function AddListener"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#function-finish","text":"Finishes the component computation, and then restart it if needed. virtual void OpenOasis :: ILinkableComponent :: Finish () = 0 This method is and must be invoked as the last of any methods in the ILinkableComponent interfaces. Immediatly after this method is invoked, it changes the component's status to Finishing . Once the finishing is completed, the component changes status to Finished if it can't be restarted; Created , otherwise. Exception: This method must be accessible after the Prepare() method has been invoked. Otherwise,the component can't handled this, an exception must be thrown.","title":"function Finish"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#function-getadaptedoutputfactories","text":"virtual std :: vector < std :: shared_ptr < IAdaptedOutputFactory > > OpenOasis :: ILinkableComponent :: GetAdaptedOutputFactories () const = 0","title":"function GetAdaptedOutputFactories"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#function-getarguments","text":"Gets arguments needed to let the component do its work. virtual std :: vector < std :: shared_ptr < IArgument > > OpenOasis :: ILinkableComponent :: GetArguments () const = 0 Arguments validations can be done either when they occur, or when the Initialize() method is called.","title":"function GetArguments"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#function-getinputs","text":"Gets the input items for recieving values. virtual std :: vector < std :: shared_ptr < IInput > > OpenOasis :: ILinkableComponent :: GetInputs () const = 0 Exception: The method must be accessible after Initialize() method has been called and until the Validate() method has been invoked. Otherwise, LinkableComponent can't handle this, an exception must be thrown.","title":"function GetInputs"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#function-getoutputs","text":"Gets the output items for producing results. virtual std :: vector < std :: shared_ptr < IOutput > > OpenOasis :: ILinkableComponent :: GetOutputs () const = 0 Exception: The method must be accessible after Initialize() method has been invoked and until Validate() method has been invoked. Otherwise, LinkableComponent cant handle this, an exception must be thrown.","title":"function GetOutputs"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#function-getstatus","text":"Gets status of the linkable component. virtual LinkableComponentStatus OpenOasis :: ILinkableComponent :: GetStatus () const = 0 The first status that a component sets is Created , as soon after it has been created.","title":"function GetStatus"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#function-initialize","text":"Initializes the component. virtual void OpenOasis :: ILinkableComponent :: Initialize () = 0 The Initialize() will and must be invoked before any other methods in the ILinkableComponent interface is invoked or accessed, except for the GetArguments . Immediatly after the method is been invoked, it changes the linkable component's status to Initializing . If component initializes succesfully, the status is changed to Initialized . The method will typically populate the component based on values specified in its arguments. Settings can be used to read input files, allocate memory, and organize input and output items. Exception: When the method is executed and an error occurs, the status will change to Failed , and an exception will be thrown. It's only required that Initialize() can be invoked once. If the Initialize() method is invoked more than once, ILinkableComponent can't handle this, thrown an exception.","title":"function Initialize"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#function-prepare","text":"Prepares the component for calls to the Update() . virtual void OpenOasis :: ILinkableComponent :: Prepare () = 0 Before Prepare() is called, the component are not required to honor any type of action that retrieves values from the component. After Prepare() is called, the component must be ready for providing values. Immediatly after the method is invoked, it changes the component's status to Preparing . When the method has finished, the status of the component has changed to either Updated or Failed . Exception: The method must be accessible after the Initialize() method has been called and until the Finish() method has been invoked. Otherwise, the linkable component can't handle it, an exception must be thrown. It's required the Prepare() method can be invoked once. Otherwise, the linkable component can't handle this, an exception must be thrown.","title":"function Prepare"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#function-removelistener","text":"virtual void OpenOasis :: ILinkableComponent :: RemoveListener ( const ListenFunc & func ) = 0","title":"function RemoveListener"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#function-update","text":"Updates the linkable component itself, thus reaching its next state. virtual void OpenOasis :: ILinkableComponent :: Update () = 0 Immediately after Update() is invoked, it changes the component's status to Updating . If the method is performed succesfully, the component sets its status to Updated , unless after this update action is at the end of its computation, in which case it will set its status to Done . According to the 'pull-driven' approach, linkable components can be connected in a chain, where invoking Update() method on the last component in the chain trigger the entire stack of data exchange. The type of actions a component takes during the Update() method depends on the type of component. A numerical model that progresses in time will typically compute a time step. A database would typically look at the consumers of its output items, and perform one or more queries to be able to provide the values that the consumers required. Exception: If during the Update() method problem arises, the component sets its state to Failed and throws an exception.","title":"function Update"},{"location":"models/class_open_oasis_1_1_i_linkable_component/#function-validate","text":"Validates the populated instance of the component. virtual std :: vector < std :: string > OpenOasis :: ILinkableComponent :: Validate () = 0 The method will must be invoked after various provider/consumer relations between this component's exchange items and the exchange items of other components present in the composition. Immediatly after this method is invoked, it changes the component's status to Validating . When the method has finished, the status of the component has changed to either Valid or Invalid . If there are messages while components status is Valid , the messages are purely informative. If there're messages while components status is Invalid , at least one of the messages indicates a fatal error. Exception: The method must be accessible after the Initialize() has been called and until the Finish() method has been invoked. Otherwise, the linkable component can not handle this, an exception must be thrown. The documentation for this class was generated from the following file Models/Inc/ILinkableComponent.h","title":"function Validate"},{"location":"models/class_open_oasis_1_1_i_manage_state/","text":"Class OpenOasis::IManageState \u00b6 ClassList > OpenOasis > IManageState It provides additional methods for handling component state so it can be saved, restored and cleared. More... #include <IManageState.h> Public Functions \u00b6 Type Name virtual void ClearState (const std::shared_ptr< IIdentifiable > & stateId) = 0 Clears a state from the linkable component. virtual std::shared_ptr< IIdentifiable > KeepCurrentState () = 0 Stores the linkable component's current state to a snapshot. virtual void RestoreState (const std::shared_ptr< IIdentifiable > & stateId) = 0 Restores the state identified by the stateId. Detailed Description \u00b6 An optional interface to be implemented by components in addition to the ILinkableComponent interface. It can be left completely to the component to handle persistence of state or it can also implement IByteStateConverter and provide ways for state to be converted to and from an array of bytes. Public Functions Documentation \u00b6 function ClearState \u00b6 Clears a state from the linkable component. virtual void OpenOasis :: IManageState :: ClearState ( const std :: shared_ptr < IIdentifiable > & stateId ) = 0 Parameters: stateId Identifier of the componentstate to be cleared. Exception: If the stateId identifier is not known by the linkable component, an exception should be trown. function KeepCurrentState \u00b6 Stores the linkable component's current state to a snapshot. virtual std :: shared_ptr < IIdentifiable > OpenOasis :: IManageState :: KeepCurrentState () = 0 Returns: Identifier of the stored state. function RestoreState \u00b6 Restores the state identified by the stateId. virtual void OpenOasis :: IManageState :: RestoreState ( const std :: shared_ptr < IIdentifiable > & stateId ) = 0 Parameters: stateId Identifier of the component state to be restored. Exception: If the stateId identifier is not known by the linkable component, an exception should be thrown. The documentation for this class was generated from the following file Models/Inc/IManageState.h","title":"Class OpenOasis::IManageState"},{"location":"models/class_open_oasis_1_1_i_manage_state/#class-openoasisimanagestate","text":"ClassList > OpenOasis > IManageState It provides additional methods for handling component state so it can be saved, restored and cleared. More... #include <IManageState.h>","title":"Class OpenOasis::IManageState"},{"location":"models/class_open_oasis_1_1_i_manage_state/#public-functions","text":"Type Name virtual void ClearState (const std::shared_ptr< IIdentifiable > & stateId) = 0 Clears a state from the linkable component. virtual std::shared_ptr< IIdentifiable > KeepCurrentState () = 0 Stores the linkable component's current state to a snapshot. virtual void RestoreState (const std::shared_ptr< IIdentifiable > & stateId) = 0 Restores the state identified by the stateId.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_manage_state/#detailed-description","text":"An optional interface to be implemented by components in addition to the ILinkableComponent interface. It can be left completely to the component to handle persistence of state or it can also implement IByteStateConverter and provide ways for state to be converted to and from an array of bytes.","title":"Detailed Description"},{"location":"models/class_open_oasis_1_1_i_manage_state/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_manage_state/#function-clearstate","text":"Clears a state from the linkable component. virtual void OpenOasis :: IManageState :: ClearState ( const std :: shared_ptr < IIdentifiable > & stateId ) = 0 Parameters: stateId Identifier of the componentstate to be cleared. Exception: If the stateId identifier is not known by the linkable component, an exception should be trown.","title":"function ClearState"},{"location":"models/class_open_oasis_1_1_i_manage_state/#function-keepcurrentstate","text":"Stores the linkable component's current state to a snapshot. virtual std :: shared_ptr < IIdentifiable > OpenOasis :: IManageState :: KeepCurrentState () = 0 Returns: Identifier of the stored state.","title":"function KeepCurrentState"},{"location":"models/class_open_oasis_1_1_i_manage_state/#function-restorestate","text":"Restores the state identified by the stateId. virtual void OpenOasis :: IManageState :: RestoreState ( const std :: shared_ptr < IIdentifiable > & stateId ) = 0 Parameters: stateId Identifier of the component state to be restored. Exception: If the stateId identifier is not known by the linkable component, an exception should be thrown. The documentation for this class was generated from the following file Models/Inc/IManageState.h","title":"function RestoreState"},{"location":"models/class_open_oasis_1_1_i_output/","text":"Class OpenOasis::IOutput \u00b6 ClassList > OpenOasis > IOutput Output exchange item that can deliver values from an ILinkableComponent . More... #include <IOutput.h> Inherits the following classes: OpenOasis::IBaseExchangeItem Inherited by the following classes: OpenOasis::IAdaptedOutput Public Types inherited from OpenOasis::IBaseExchangeItem \u00b6 See OpenOasis::IBaseExchangeItem Type Name typedef std::function< void(std::shared_ptr< ExchangeItemChangeEventArgs >)> ListenFunc Public Functions \u00b6 Type Name virtual void AddAdaptedOutput (std::shared_ptr< IAdaptedOutput > adaptedOutput) = 0 Adds an adapted output to this output item as a transformer. virtual void AddConsumer (std::shared_ptr< IInput > consumer) = 0 Adds a consumer to the output item. Every input item needs to add itself as a consumer first. virtual std::vector< std::shared_ptr< IAdaptedOutput > > GetAdaptedOutputs () const = 0 Gets the adapted outputs. virtual std::vector< std::weak_ptr< IInput > > GetConsumers () const = 0 Gets inputs that will consume the value, by calling the GetValues() method. Every input item needs to call the AddConsumer() method first. virtual void RemoveAdaptedOutput (const std::shared_ptr< IAdaptedOutput > & adaptedOutput) = 0 Removes a IAdaptedOutput . virtual void RemoveConsumer (const std::shared_ptr< IInput > & consumer) = 0 Removes a consumer. Public Functions inherited from OpenOasis::IBaseExchangeItem \u00b6 See OpenOasis::IBaseExchangeItem Type Name virtual void AddListener (const ListenFunc & func) = 0 Adds a listener to the exchange item. virtual std::weak_ptr< ILinkableComponent > GetComponent () const = 0 Gets the owner of the exchange item. virtual std::shared_ptr< IElementSet > GetElementSet () const = 0 Gets the exchange item's elements. If it's id-based, return null. virtual std::shared_ptr< ITimeSet > GetTimeSet () const = 0 Gets the exchange item's available time set. If it's time independent, return null. virtual std::shared_ptr< IValueDefinition > GetValueDefinition () const = 0 Definition of the values in the exchange item. virtual std::shared_ptr< IValueSet > GetValues () = 0 Provides the values matching the value definition specified. Extensions can overwrite this base version to include more details in the query, e.g. time and space. virtual void RemoveListener (const ListenFunc & func) = 0 Removes the listener if it is no more interested at this item. virtual void Reset () = 0 Resets the exchange item. virtual void SetElementSet (std::shared_ptr< IElementSet > elements) = 0 Sets the exchange item's elements. virtual void SetTimeSet (std::shared_ptr< ITimeSet > times) = 0 Sets the exchange item's time set. virtual void SetValues (std::shared_ptr< IValueSet > value) = 0 Sets the exchange item's values. Public Functions inherited from OpenOasis::IIdentifiable \u00b6 See OpenOasis::IIdentifiable Type Name virtual std::string GetId () const = 0 Gets id string. Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Detailed Description \u00b6 If an output does not provide the data in the way a consumer would like to have, the output can be adapted by an IAdaptedOutput , which can transform the data according to the consumer's wishes. Public Functions Documentation \u00b6 function AddAdaptedOutput \u00b6 Adds an adapted output to this output item as a transformer. virtual void OpenOasis :: IOutput :: AddAdaptedOutput ( std :: shared_ptr < IAdaptedOutput > adaptedOutput ) = 0 The AddAdaptedOutput() method must and will automatically add the adapted output's adaptee by calling its SetAdaptee() method. Exception: If an IAdaptedOutput item is added that can not be handled or is incompatible with the already added IAdaptedOutput s, an exception will be thrown. function AddConsumer \u00b6 Adds a consumer to the output item. Every input item needs to add itself as a consumer first. virtual void OpenOasis :: IOutput :: AddConsumer ( std :: shared_ptr < IInput > consumer ) = 0 The AddConsumer() method must and will automatically add the consumer provider by calling the IInput::AddProvider() method. Exception: If a consumer is added that can't be handled, or it's incompatible with the already added consumers, throw an exception. function GetAdaptedOutputs \u00b6 Gets the adapted outputs. virtual std :: vector < std :: shared_ptr < IAdaptedOutput > > OpenOasis :: IOutput :: GetAdaptedOutputs () const = 0 As the output item's values have been updated, each IAdaptedOutput its Refresh() method must be called after. function GetConsumers \u00b6 Gets inputs that will consume the value, by calling the GetValues() method. Every input item needs to call the AddConsumer() method first. virtual std :: vector < std :: weak_ptr < IInput > > OpenOasis :: IOutput :: GetConsumers () const = 0 Please be aware that the unadulterated value in the output item provided by the read only ' GetValues() ' method, may be called anyway, even if there are no values available. function RemoveAdaptedOutput \u00b6 Removes a IAdaptedOutput . virtual void OpenOasis :: IOutput :: RemoveAdaptedOutput ( const std :: shared_ptr < IAdaptedOutput > & adaptedOutput ) = 0 If an IAdaptedOutput is not interested any longer in this output item's data, it should remove itself by calling this method. The RemoveAdaptedOutput() method must and will automatically remove the adapted output's adaptee by setting it to null. function RemoveConsumer \u00b6 Removes a consumer. virtual void OpenOasis :: IOutput :: RemoveConsumer ( const std :: shared_ptr < IInput > & consumer ) = 0 If an input item isn't interested any longer in calling GetValues() method, it should remove the input item. The RemoveConsumer() method must and will automatically remove the consumer's provider by calling the IInput::RemoveProvider() method. The documentation for this class was generated from the following file Models/Inc/IOutput.h","title":"Class OpenOasis::IOutput"},{"location":"models/class_open_oasis_1_1_i_output/#class-openoasisioutput","text":"ClassList > OpenOasis > IOutput Output exchange item that can deliver values from an ILinkableComponent . More... #include <IOutput.h> Inherits the following classes: OpenOasis::IBaseExchangeItem Inherited by the following classes: OpenOasis::IAdaptedOutput","title":"Class OpenOasis::IOutput"},{"location":"models/class_open_oasis_1_1_i_output/#public-types-inherited-from-openoasisibaseexchangeitem","text":"See OpenOasis::IBaseExchangeItem Type Name typedef std::function< void(std::shared_ptr< ExchangeItemChangeEventArgs >)> ListenFunc","title":"Public Types inherited from OpenOasis::IBaseExchangeItem"},{"location":"models/class_open_oasis_1_1_i_output/#public-functions","text":"Type Name virtual void AddAdaptedOutput (std::shared_ptr< IAdaptedOutput > adaptedOutput) = 0 Adds an adapted output to this output item as a transformer. virtual void AddConsumer (std::shared_ptr< IInput > consumer) = 0 Adds a consumer to the output item. Every input item needs to add itself as a consumer first. virtual std::vector< std::shared_ptr< IAdaptedOutput > > GetAdaptedOutputs () const = 0 Gets the adapted outputs. virtual std::vector< std::weak_ptr< IInput > > GetConsumers () const = 0 Gets inputs that will consume the value, by calling the GetValues() method. Every input item needs to call the AddConsumer() method first. virtual void RemoveAdaptedOutput (const std::shared_ptr< IAdaptedOutput > & adaptedOutput) = 0 Removes a IAdaptedOutput . virtual void RemoveConsumer (const std::shared_ptr< IInput > & consumer) = 0 Removes a consumer.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_output/#public-functions-inherited-from-openoasisibaseexchangeitem","text":"See OpenOasis::IBaseExchangeItem Type Name virtual void AddListener (const ListenFunc & func) = 0 Adds a listener to the exchange item. virtual std::weak_ptr< ILinkableComponent > GetComponent () const = 0 Gets the owner of the exchange item. virtual std::shared_ptr< IElementSet > GetElementSet () const = 0 Gets the exchange item's elements. If it's id-based, return null. virtual std::shared_ptr< ITimeSet > GetTimeSet () const = 0 Gets the exchange item's available time set. If it's time independent, return null. virtual std::shared_ptr< IValueDefinition > GetValueDefinition () const = 0 Definition of the values in the exchange item. virtual std::shared_ptr< IValueSet > GetValues () = 0 Provides the values matching the value definition specified. Extensions can overwrite this base version to include more details in the query, e.g. time and space. virtual void RemoveListener (const ListenFunc & func) = 0 Removes the listener if it is no more interested at this item. virtual void Reset () = 0 Resets the exchange item. virtual void SetElementSet (std::shared_ptr< IElementSet > elements) = 0 Sets the exchange item's elements. virtual void SetTimeSet (std::shared_ptr< ITimeSet > times) = 0 Sets the exchange item's time set. virtual void SetValues (std::shared_ptr< IValueSet > value) = 0 Sets the exchange item's values.","title":"Public Functions inherited from OpenOasis::IBaseExchangeItem"},{"location":"models/class_open_oasis_1_1_i_output/#public-functions-inherited-from-openoasisiidentifiable","text":"See OpenOasis::IIdentifiable Type Name virtual std::string GetId () const = 0 Gets id string.","title":"Public Functions inherited from OpenOasis::IIdentifiable"},{"location":"models/class_open_oasis_1_1_i_output/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_output/#detailed-description","text":"If an output does not provide the data in the way a consumer would like to have, the output can be adapted by an IAdaptedOutput , which can transform the data according to the consumer's wishes.","title":"Detailed Description"},{"location":"models/class_open_oasis_1_1_i_output/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_output/#function-addadaptedoutput","text":"Adds an adapted output to this output item as a transformer. virtual void OpenOasis :: IOutput :: AddAdaptedOutput ( std :: shared_ptr < IAdaptedOutput > adaptedOutput ) = 0 The AddAdaptedOutput() method must and will automatically add the adapted output's adaptee by calling its SetAdaptee() method. Exception: If an IAdaptedOutput item is added that can not be handled or is incompatible with the already added IAdaptedOutput s, an exception will be thrown.","title":"function AddAdaptedOutput"},{"location":"models/class_open_oasis_1_1_i_output/#function-addconsumer","text":"Adds a consumer to the output item. Every input item needs to add itself as a consumer first. virtual void OpenOasis :: IOutput :: AddConsumer ( std :: shared_ptr < IInput > consumer ) = 0 The AddConsumer() method must and will automatically add the consumer provider by calling the IInput::AddProvider() method. Exception: If a consumer is added that can't be handled, or it's incompatible with the already added consumers, throw an exception.","title":"function AddConsumer"},{"location":"models/class_open_oasis_1_1_i_output/#function-getadaptedoutputs","text":"Gets the adapted outputs. virtual std :: vector < std :: shared_ptr < IAdaptedOutput > > OpenOasis :: IOutput :: GetAdaptedOutputs () const = 0 As the output item's values have been updated, each IAdaptedOutput its Refresh() method must be called after.","title":"function GetAdaptedOutputs"},{"location":"models/class_open_oasis_1_1_i_output/#function-getconsumers","text":"Gets inputs that will consume the value, by calling the GetValues() method. Every input item needs to call the AddConsumer() method first. virtual std :: vector < std :: weak_ptr < IInput > > OpenOasis :: IOutput :: GetConsumers () const = 0 Please be aware that the unadulterated value in the output item provided by the read only ' GetValues() ' method, may be called anyway, even if there are no values available.","title":"function GetConsumers"},{"location":"models/class_open_oasis_1_1_i_output/#function-removeadaptedoutput","text":"Removes a IAdaptedOutput . virtual void OpenOasis :: IOutput :: RemoveAdaptedOutput ( const std :: shared_ptr < IAdaptedOutput > & adaptedOutput ) = 0 If an IAdaptedOutput is not interested any longer in this output item's data, it should remove itself by calling this method. The RemoveAdaptedOutput() method must and will automatically remove the adapted output's adaptee by setting it to null.","title":"function RemoveAdaptedOutput"},{"location":"models/class_open_oasis_1_1_i_output/#function-removeconsumer","text":"Removes a consumer. virtual void OpenOasis :: IOutput :: RemoveConsumer ( const std :: shared_ptr < IInput > & consumer ) = 0 If an input item isn't interested any longer in calling GetValues() method, it should remove the input item. The RemoveConsumer() method must and will automatically remove the consumer's provider by calling the IInput::RemoveProvider() method. The documentation for this class was generated from the following file Models/Inc/IOutput.h","title":"function RemoveConsumer"},{"location":"models/class_open_oasis_1_1_i_quality/","text":"Class OpenOasis::IQuality \u00b6 ClassList > OpenOasis > IQuality Class describes qualitative data, where a value is specified as one category within a number of predefined (possible) categories. More... #include <IQuality.h> Inherits the following classes: OpenOasis::IValueDefinition Public Functions \u00b6 Type Name virtual std::vector< std::shared_ptr< ICategory > > GetCategories () const = 0 Gets a list of the possible ICategory allowed. virtual bool IsOrdered () const = 0 Checks if this IQuality is defined by an ordered set or not. Public Functions inherited from OpenOasis::IValueDefinition \u00b6 See OpenOasis::IValueDefinition Type Name virtual std::any GetMissingDataValue () const = 0 Gets flag representing missing data. virtual const std::type_info & GetValueType () const = 0 Gets object value type. Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Detailed Description \u00b6 Qualitative data described items in terms of some quality or categorization that may be 'informal' or may use relatively ill-defined characteristics such as warmth and flavour. However, qualitative data can include well-defined aspects such as gender, nationality or commodity type. For qualitative data the IValueSet exchanged between ILinkableComponent s contains one of the possible ICategory instances per element in the element set involved. For examples: Colors : red, green, blue; Land use: nature, recreation, industry, infrastructure; Rating : worse, same, better. Public Functions Documentation \u00b6 function GetCategories \u00b6 Gets a list of the possible ICategory allowed. virtual std :: vector < std :: shared_ptr < ICategory > > OpenOasis :: IQuality :: GetCategories () const = 0 If the quality is not ordered, the list contains the ICategory s in an unspecified order. When it's ordered, the list contains the ICategory s in the same sequence. function IsOrdered \u00b6 virtual bool OpenOasis :: IQuality :: IsOrdered () const = 0 The documentation for this class was generated from the following file Models/Inc/IQuality.h","title":"Class OpenOasis::IQuality"},{"location":"models/class_open_oasis_1_1_i_quality/#class-openoasisiquality","text":"ClassList > OpenOasis > IQuality Class describes qualitative data, where a value is specified as one category within a number of predefined (possible) categories. More... #include <IQuality.h> Inherits the following classes: OpenOasis::IValueDefinition","title":"Class OpenOasis::IQuality"},{"location":"models/class_open_oasis_1_1_i_quality/#public-functions","text":"Type Name virtual std::vector< std::shared_ptr< ICategory > > GetCategories () const = 0 Gets a list of the possible ICategory allowed. virtual bool IsOrdered () const = 0 Checks if this IQuality is defined by an ordered set or not.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_quality/#public-functions-inherited-from-openoasisivaluedefinition","text":"See OpenOasis::IValueDefinition Type Name virtual std::any GetMissingDataValue () const = 0 Gets flag representing missing data. virtual const std::type_info & GetValueType () const = 0 Gets object value type.","title":"Public Functions inherited from OpenOasis::IValueDefinition"},{"location":"models/class_open_oasis_1_1_i_quality/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_quality/#detailed-description","text":"Qualitative data described items in terms of some quality or categorization that may be 'informal' or may use relatively ill-defined characteristics such as warmth and flavour. However, qualitative data can include well-defined aspects such as gender, nationality or commodity type. For qualitative data the IValueSet exchanged between ILinkableComponent s contains one of the possible ICategory instances per element in the element set involved. For examples: Colors : red, green, blue; Land use: nature, recreation, industry, infrastructure; Rating : worse, same, better.","title":"Detailed Description"},{"location":"models/class_open_oasis_1_1_i_quality/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_quality/#function-getcategories","text":"Gets a list of the possible ICategory allowed. virtual std :: vector < std :: shared_ptr < ICategory > > OpenOasis :: IQuality :: GetCategories () const = 0 If the quality is not ordered, the list contains the ICategory s in an unspecified order. When it's ordered, the list contains the ICategory s in the same sequence.","title":"function GetCategories"},{"location":"models/class_open_oasis_1_1_i_quality/#function-isordered","text":"virtual bool OpenOasis :: IQuality :: IsOrdered () const = 0 The documentation for this class was generated from the following file Models/Inc/IQuality.h","title":"function IsOrdered"},{"location":"models/class_open_oasis_1_1_i_quantity/","text":"Class OpenOasis::IQuantity \u00b6 ClassList > OpenOasis > IQuantity Class specifies values as an amount of some unit. #include <IQuantity.h> Inherits the following classes: OpenOasis::IValueDefinition Public Functions \u00b6 Type Name virtual std::shared_ptr< IUnit > GetUnit () const = 0 Unit of quantity. Public Functions inherited from OpenOasis::IValueDefinition \u00b6 See OpenOasis::IValueDefinition Type Name virtual std::any GetMissingDataValue () const = 0 Gets flag representing missing data. virtual const std::type_info & GetValueType () const = 0 Gets object value type. Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Public Functions Documentation \u00b6 function GetUnit \u00b6 virtual std :: shared_ptr < IUnit > OpenOasis :: IQuantity :: GetUnit () const = 0 The documentation for this class was generated from the following file Models/Inc/IQuantity.h","title":"Class OpenOasis::IQuantity"},{"location":"models/class_open_oasis_1_1_i_quantity/#class-openoasisiquantity","text":"ClassList > OpenOasis > IQuantity Class specifies values as an amount of some unit. #include <IQuantity.h> Inherits the following classes: OpenOasis::IValueDefinition","title":"Class OpenOasis::IQuantity"},{"location":"models/class_open_oasis_1_1_i_quantity/#public-functions","text":"Type Name virtual std::shared_ptr< IUnit > GetUnit () const = 0 Unit of quantity.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_quantity/#public-functions-inherited-from-openoasisivaluedefinition","text":"See OpenOasis::IValueDefinition Type Name virtual std::any GetMissingDataValue () const = 0 Gets flag representing missing data. virtual const std::type_info & GetValueType () const = 0 Gets object value type.","title":"Public Functions inherited from OpenOasis::IValueDefinition"},{"location":"models/class_open_oasis_1_1_i_quantity/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_quantity/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_quantity/#function-getunit","text":"virtual std :: shared_ptr < IUnit > OpenOasis :: IQuantity :: GetUnit () const = 0 The documentation for this class was generated from the following file Models/Inc/IQuantity.h","title":"function GetUnit"},{"location":"models/class_open_oasis_1_1_i_spatial_definition/","text":"Class OpenOasis::ISpatialDefinition \u00b6 ClassList > OpenOasis > ISpatialDefinition General spatial construct that all other spatial constructions extend from. #include <ISpatialDefinition.h> Inherits the following classes: OpenOasis::IDescribable Inherited by the following classes: OpenOasis::IElementSet Public Functions \u00b6 Type Name virtual int GetElementCount () const = 0 Gets number of data elements in the spatial axis. virtual std::string GetSpatialReferenceSystem () const = 0 Specifies the OGC Well-Known Text(WKT) representation of spatial reference system to be used in association with the coordinates in the ISpatialDefinition . virtual int GetVersion () const = 0 Gets the version number for the spatial axis. Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Public Functions Documentation \u00b6 function GetElementCount \u00b6 virtual int OpenOasis :: ISpatialDefinition :: GetElementCount () const = 0 function GetSpatialReferenceSystem \u00b6 virtual std :: string OpenOasis :: ISpatialDefinition :: GetSpatialReferenceSystem () const = 0 function GetVersion \u00b6 Gets the version number for the spatial axis. virtual int OpenOasis :: ISpatialDefinition :: GetVersion () const = 0 The version must be incremented if anything inside the spatial axis is changed, or if an entirely new spatial axis is provided. The documentation for this class was generated from the following file Models/Inc/ISpatialDefinition.h","title":"Class OpenOasis::ISpatialDefinition"},{"location":"models/class_open_oasis_1_1_i_spatial_definition/#class-openoasisispatialdefinition","text":"ClassList > OpenOasis > ISpatialDefinition General spatial construct that all other spatial constructions extend from. #include <ISpatialDefinition.h> Inherits the following classes: OpenOasis::IDescribable Inherited by the following classes: OpenOasis::IElementSet","title":"Class OpenOasis::ISpatialDefinition"},{"location":"models/class_open_oasis_1_1_i_spatial_definition/#public-functions","text":"Type Name virtual int GetElementCount () const = 0 Gets number of data elements in the spatial axis. virtual std::string GetSpatialReferenceSystem () const = 0 Specifies the OGC Well-Known Text(WKT) representation of spatial reference system to be used in association with the coordinates in the ISpatialDefinition . virtual int GetVersion () const = 0 Gets the version number for the spatial axis.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_spatial_definition/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_spatial_definition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_spatial_definition/#function-getelementcount","text":"virtual int OpenOasis :: ISpatialDefinition :: GetElementCount () const = 0","title":"function GetElementCount"},{"location":"models/class_open_oasis_1_1_i_spatial_definition/#function-getspatialreferencesystem","text":"virtual std :: string OpenOasis :: ISpatialDefinition :: GetSpatialReferenceSystem () const = 0","title":"function GetSpatialReferenceSystem"},{"location":"models/class_open_oasis_1_1_i_spatial_definition/#function-getversion","text":"Gets the version number for the spatial axis. virtual int OpenOasis :: ISpatialDefinition :: GetVersion () const = 0 The version must be incremented if anything inside the spatial axis is changed, or if an entirely new spatial axis is provided. The documentation for this class was generated from the following file Models/Inc/ISpatialDefinition.h","title":"function GetVersion"},{"location":"models/class_open_oasis_1_1_i_time/","text":"Class OpenOasis::ITime \u00b6 ClassList > OpenOasis > ITime Time interface to support a time stamp as well as a time interval. #include <ITime.h> Public Functions \u00b6 Type Name virtual double GetDurationInDays () const = 0 Duration in days for time interval. 0 if time is a time stamp. virtual double GetTimeStamp () const = 0 Time stamp as days since 08:00::00 January 1, 1970. Public Functions Documentation \u00b6 function GetDurationInDays \u00b6 virtual double OpenOasis :: ITime :: GetDurationInDays () const = 0 function GetTimeStamp \u00b6 virtual double OpenOasis :: ITime :: GetTimeStamp () const = 0 The documentation for this class was generated from the following file Models/Inc/ITime.h","title":"Class OpenOasis::ITime"},{"location":"models/class_open_oasis_1_1_i_time/#class-openoasisitime","text":"ClassList > OpenOasis > ITime Time interface to support a time stamp as well as a time interval. #include <ITime.h>","title":"Class OpenOasis::ITime"},{"location":"models/class_open_oasis_1_1_i_time/#public-functions","text":"Type Name virtual double GetDurationInDays () const = 0 Duration in days for time interval. 0 if time is a time stamp. virtual double GetTimeStamp () const = 0 Time stamp as days since 08:00::00 January 1, 1970.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_time/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_time/#function-getdurationindays","text":"virtual double OpenOasis :: ITime :: GetDurationInDays () const = 0","title":"function GetDurationInDays"},{"location":"models/class_open_oasis_1_1_i_time/#function-gettimestamp","text":"virtual double OpenOasis :: ITime :: GetTimeStamp () const = 0 The documentation for this class was generated from the following file Models/Inc/ITime.h","title":"function GetTimeStamp"},{"location":"models/class_open_oasis_1_1_i_time_set/","text":"Class OpenOasis::ITimeSet \u00b6 ClassList > OpenOasis > ITimeSet Set of time stamps or time intervals, used to indicate when an output has and can provide values, and when an input item does or may require values. #include <ITimeSet.h> Public Functions \u00b6 Type Name virtual void AddTime (std::shared_ptr< ITime > time) = 0 Adds a ITime to this time set. virtual double GetOffsetFromUtcInHours () const = 0 Time zone offset from UTC, expressed in the number of hours. virtual std::shared_ptr< ITime > GetTimeHorizon () const = 0 Gets the time horizon for what timespan it may require/provide values. virtual std::vector< std::shared_ptr< ITime > > GetTimes () const = 0 Time stamps or spans as available in of an output item, or as required by an input item. Times should be ordered. virtual bool HasDurations () const = 0 Whether each ITime have duration. In this case,duration value greater than zero is expected for each ITime in the GetTimes() list. virtual void RemoveTime (int index) = 0 Removes the ITime element with specified index. After removing time, the duration must be updated automatically. Public Functions Documentation \u00b6 function AddTime \u00b6 Adds a ITime to this time set. virtual void OpenOasis :: ITimeSet :: AddTime ( std :: shared_ptr < ITime > time ) = 0 Usually, a timeset item is ordered by timestamp, it means the insertion will trigger interval sorting. After adding time, the duration must be updated automatically. function GetOffsetFromUtcInHours \u00b6 Time zone offset from UTC, expressed in the number of hours. virtual double OpenOasis :: ITimeSet :: GetOffsetFromUtcInHours () const = 0 Since some of the world's time zone differ half an hour from their neighbour the value is specified as a double. function GetTimeHorizon \u00b6 Gets the time horizon for what timespan it may require/provide values. virtual std :: shared_ptr < ITime > OpenOasis :: ITimeSet :: GetTimeHorizon () const = 0 The providers of this input can assume that the input item never go back further in time than the time horizon's begin time: GetTimeHorizon() ->GetTimeStamp() . Also, it will never go further ahead than the time horizon's end time:: GetTimeHorizon() ->GetTimeStamp() + GetTimeHorizon() ->GetDurationInDays() . For an output item, thus for an adapted output, the time horizon indicates in what time span the item can provide values. Specific values: GetTimeHorizon() ->GetTimeStamp() == - Infinity: far back in time; GetTimeHorizon() ->GetDurationInDays() == + Infinity: far in the future. function GetTimes \u00b6 Time stamps or spans as available in of an output item, or as required by an input item. Times should be ordered. virtual std :: vector < std :: shared_ptr < ITime > > OpenOasis :: ITimeSet :: GetTimes () const = 0 Specific values: * TimeSet::GetTimes().size() == 0 , in case of input: time dependent item, but currently no values required. * TimeSet::GetTimes().size() == 0 , in case of output: time dependent item, but no values available yet or required yet. function HasDurations \u00b6 virtual bool OpenOasis :: ITimeSet :: HasDurations () const = 0 function RemoveTime \u00b6 virtual void OpenOasis :: ITimeSet :: RemoveTime ( int index ) = 0 The documentation for this class was generated from the following file Models/Inc/ITimeSet.h","title":"Class OpenOasis::ITimeSet"},{"location":"models/class_open_oasis_1_1_i_time_set/#class-openoasisitimeset","text":"ClassList > OpenOasis > ITimeSet Set of time stamps or time intervals, used to indicate when an output has and can provide values, and when an input item does or may require values. #include <ITimeSet.h>","title":"Class OpenOasis::ITimeSet"},{"location":"models/class_open_oasis_1_1_i_time_set/#public-functions","text":"Type Name virtual void AddTime (std::shared_ptr< ITime > time) = 0 Adds a ITime to this time set. virtual double GetOffsetFromUtcInHours () const = 0 Time zone offset from UTC, expressed in the number of hours. virtual std::shared_ptr< ITime > GetTimeHorizon () const = 0 Gets the time horizon for what timespan it may require/provide values. virtual std::vector< std::shared_ptr< ITime > > GetTimes () const = 0 Time stamps or spans as available in of an output item, or as required by an input item. Times should be ordered. virtual bool HasDurations () const = 0 Whether each ITime have duration. In this case,duration value greater than zero is expected for each ITime in the GetTimes() list. virtual void RemoveTime (int index) = 0 Removes the ITime element with specified index. After removing time, the duration must be updated automatically.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_time_set/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_time_set/#function-addtime","text":"Adds a ITime to this time set. virtual void OpenOasis :: ITimeSet :: AddTime ( std :: shared_ptr < ITime > time ) = 0 Usually, a timeset item is ordered by timestamp, it means the insertion will trigger interval sorting. After adding time, the duration must be updated automatically.","title":"function AddTime"},{"location":"models/class_open_oasis_1_1_i_time_set/#function-getoffsetfromutcinhours","text":"Time zone offset from UTC, expressed in the number of hours. virtual double OpenOasis :: ITimeSet :: GetOffsetFromUtcInHours () const = 0 Since some of the world's time zone differ half an hour from their neighbour the value is specified as a double.","title":"function GetOffsetFromUtcInHours"},{"location":"models/class_open_oasis_1_1_i_time_set/#function-gettimehorizon","text":"Gets the time horizon for what timespan it may require/provide values. virtual std :: shared_ptr < ITime > OpenOasis :: ITimeSet :: GetTimeHorizon () const = 0 The providers of this input can assume that the input item never go back further in time than the time horizon's begin time: GetTimeHorizon() ->GetTimeStamp() . Also, it will never go further ahead than the time horizon's end time:: GetTimeHorizon() ->GetTimeStamp() + GetTimeHorizon() ->GetDurationInDays() . For an output item, thus for an adapted output, the time horizon indicates in what time span the item can provide values. Specific values: GetTimeHorizon() ->GetTimeStamp() == - Infinity: far back in time; GetTimeHorizon() ->GetDurationInDays() == + Infinity: far in the future.","title":"function GetTimeHorizon"},{"location":"models/class_open_oasis_1_1_i_time_set/#function-gettimes","text":"Time stamps or spans as available in of an output item, or as required by an input item. Times should be ordered. virtual std :: vector < std :: shared_ptr < ITime > > OpenOasis :: ITimeSet :: GetTimes () const = 0 Specific values: * TimeSet::GetTimes().size() == 0 , in case of input: time dependent item, but currently no values required. * TimeSet::GetTimes().size() == 0 , in case of output: time dependent item, but no values available yet or required yet.","title":"function GetTimes"},{"location":"models/class_open_oasis_1_1_i_time_set/#function-hasdurations","text":"virtual bool OpenOasis :: ITimeSet :: HasDurations () const = 0","title":"function HasDurations"},{"location":"models/class_open_oasis_1_1_i_time_set/#function-removetime","text":"virtual void OpenOasis :: ITimeSet :: RemoveTime ( int index ) = 0 The documentation for this class was generated from the following file Models/Inc/ITimeSet.h","title":"function RemoveTime"},{"location":"models/class_open_oasis_1_1_i_unit/","text":"Class OpenOasis::IUnit \u00b6 ClassList > OpenOasis > IUnit Unit interface describes the physical unit. #include <IUnit.h> Inherits the following classes: OpenOasis::IDescribable Public Functions \u00b6 Type Name virtual double GetConversionFactorToSI () const = 0 Conversion factor to SI. ('A' in: SI-value = A * quantValue + B). virtual std::shared_ptr< IDimension > GetDimension () const = 0 The unit's dimension. virtual double GetOffSetToSI () const = 0 OffSet to SI. ('B' in: SI-value = A * quantValue + B). Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Public Functions Documentation \u00b6 function GetConversionFactorToSI \u00b6 virtual double OpenOasis :: IUnit :: GetConversionFactorToSI () const = 0 function GetDimension \u00b6 virtual std :: shared_ptr < IDimension > OpenOasis :: IUnit :: GetDimension () const = 0 function GetOffSetToSI \u00b6 virtual double OpenOasis :: IUnit :: GetOffSetToSI () const = 0 The documentation for this class was generated from the following file Models/Inc/IUnit.h","title":"Class OpenOasis::IUnit"},{"location":"models/class_open_oasis_1_1_i_unit/#class-openoasisiunit","text":"ClassList > OpenOasis > IUnit Unit interface describes the physical unit. #include <IUnit.h> Inherits the following classes: OpenOasis::IDescribable","title":"Class OpenOasis::IUnit"},{"location":"models/class_open_oasis_1_1_i_unit/#public-functions","text":"Type Name virtual double GetConversionFactorToSI () const = 0 Conversion factor to SI. ('A' in: SI-value = A * quantValue + B). virtual std::shared_ptr< IDimension > GetDimension () const = 0 The unit's dimension. virtual double GetOffSetToSI () const = 0 OffSet to SI. ('B' in: SI-value = A * quantValue + B).","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_unit/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_unit/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_unit/#function-getconversionfactortosi","text":"virtual double OpenOasis :: IUnit :: GetConversionFactorToSI () const = 0","title":"function GetConversionFactorToSI"},{"location":"models/class_open_oasis_1_1_i_unit/#function-getdimension","text":"virtual std :: shared_ptr < IDimension > OpenOasis :: IUnit :: GetDimension () const = 0","title":"function GetDimension"},{"location":"models/class_open_oasis_1_1_i_unit/#function-getoffsettosi","text":"virtual double OpenOasis :: IUnit :: GetOffSetToSI () const = 0 The documentation for this class was generated from the following file Models/Inc/IUnit.h","title":"function GetOffSetToSI"},{"location":"models/class_open_oasis_1_1_i_value_definition/","text":"Class OpenOasis::IValueDefinition \u00b6 ClassList > OpenOasis > IValueDefinition Class describes value definition. #include <IValueDefinition.h> Inherits the following classes: OpenOasis::IDescribable Inherited by the following classes: OpenOasis::IQuality , OpenOasis::IQuantity Public Functions \u00b6 Type Name virtual std::any GetMissingDataValue () const = 0 Gets flag representing missing data. virtual const std::type_info & GetValueType () const = 0 Gets object value type. Public Functions inherited from OpenOasis::IDescribable \u00b6 See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0 Public Functions Documentation \u00b6 function GetMissingDataValue \u00b6 virtual std :: any OpenOasis :: IValueDefinition :: GetMissingDataValue () const = 0 function GetValueType \u00b6 virtual const std :: type_info & OpenOasis :: IValueDefinition :: GetValueType () const = 0 The documentation for this class was generated from the following file Models/Inc/IValueDefinition.h","title":"Class OpenOasis::IValueDefinition"},{"location":"models/class_open_oasis_1_1_i_value_definition/#class-openoasisivaluedefinition","text":"ClassList > OpenOasis > IValueDefinition Class describes value definition. #include <IValueDefinition.h> Inherits the following classes: OpenOasis::IDescribable Inherited by the following classes: OpenOasis::IQuality , OpenOasis::IQuantity","title":"Class OpenOasis::IValueDefinition"},{"location":"models/class_open_oasis_1_1_i_value_definition/#public-functions","text":"Type Name virtual std::any GetMissingDataValue () const = 0 Gets flag representing missing data. virtual const std::type_info & GetValueType () const = 0 Gets object value type.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_value_definition/#public-functions-inherited-from-openoasisidescribable","text":"See OpenOasis::IDescribable Type Name virtual std::string GetCaption () const = 0 virtual std::string GetDescription () const = 0 virtual void SetCaption (const std::string & value) = 0 virtual void SetDescription (const std::string & value) = 0","title":"Public Functions inherited from OpenOasis::IDescribable"},{"location":"models/class_open_oasis_1_1_i_value_definition/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_value_definition/#function-getmissingdatavalue","text":"virtual std :: any OpenOasis :: IValueDefinition :: GetMissingDataValue () const = 0","title":"function GetMissingDataValue"},{"location":"models/class_open_oasis_1_1_i_value_definition/#function-getvaluetype","text":"virtual const std :: type_info & OpenOasis :: IValueDefinition :: GetValueType () const = 0 The documentation for this class was generated from the following file Models/Inc/IValueDefinition.h","title":"function GetValueType"},{"location":"models/class_open_oasis_1_1_i_value_set/","text":"Class OpenOasis::IValueSet \u00b6 ClassList > OpenOasis > IValueSet Class represents a general(ordered) multi-dimensional set of values. More... #include <IValueSet.h> Public Functions \u00b6 Type Name virtual std::vector< std::any > GetElementValuesForTime (int timeIndex) const = 0 Gets the values, for all elements, for the given timeIndex. If data is time independent, timeIndex must be specified as 0. virtual int GetIndexCount (const std::vector< int > & indices) const = 0 Returns the length of the dimension specified. virtual int GetNumberOfIndices () const = 0 Returns the number of possible indices (dimensions). virtual std::vector< std::any > GetTimeSeriesValuesForElement (int elementIndex) const = 0 Gets the values, for all times, for the given elementIndex. If the data is spatial independent, elementIndex must be specified as 0. virtual std::any GetValue (const std::vector< int > & indices) const = 0 Returns the value object specified by the given indices array. virtual std::shared_ptr< IValueDefinition > GetValueDefinition () const = 0 Definition of the values in the value set. virtual bool IsValues2D () const = 0 Whether this value set is a specified two-dimensional type. virtual void RemoveValue (const std::vector< int > & indices) = 0 Removes the values specified by the given indices. virtual void SetElementValuesForTime (int timeIndex, const std::vector< std::any > & values) = 0 Sets the values, for all elements, for the given timeIndex. If data is time independent, timeIndex must be specified as 0. virtual void SetOrAddValue (const std::vector< int > & indices, const std::any & value) = 0 Sets or adds the value object specified by the given indices. virtual void SetTimeSeriesValuesForElement (int elementIndex, const std::vector< std::any > & values) = 0 Sets the values, for all times, for the given elementIndex. If the data is spatial independent, elementIndex must be specified as 0. Detailed Description \u00b6 The size of each dimension can vary, depending on the indices provided, e.g. In a 2D matrix, each row can have different lengths. For example, assuming the data is stored as a double matrix, then matrix[1].Size need not equal to matrix[2].Size. Public Functions Documentation \u00b6 function GetElementValuesForTime \u00b6 Gets the values, for all elements, for the given timeIndex. If data is time independent, timeIndex must be specified as 0. virtual std :: vector < std :: any > OpenOasis :: IValueSet :: GetElementValuesForTime ( int timeIndex ) const = 0 Parameters: timeIndex Index of time in ITimeSet . Returns: Element valueset at given time. Exception: If timeIndex is out of range, throw an exception. function GetIndexCount \u00b6 Returns the length of the dimension specified. virtual int OpenOasis :: IValueSet :: GetIndexCount ( const std :: vector < int > & indices ) const = 0 To get the size of the specified dimension, use zero-length int array as input argument. Length of indice must be a least one smaller than the GetNumberOfIndices() . Parameters: indices Indices of the dimension to get the size of. Returns: Length of the specified dimension. function GetNumberOfIndices \u00b6 Returns the number of possible indices (dimensions). virtual int OpenOasis :: IValueSet :: GetNumberOfIndices () const = 0 Returns: number of indices, zero based. function GetTimeSeriesValuesForElement \u00b6 Gets the values, for all times, for the given elementIndex. If the data is spatial independent, elementIndex must be specified as 0. virtual std :: vector < std :: any > OpenOasis :: IValueSet :: GetTimeSeriesValuesForElement ( int elementIndex ) const = 0 Parameters: elementIndex Index of element in IElementSet . Returns: The timeseries values. Exception: If the elementIndex is out of range, throw an exception. function GetValue \u00b6 Returns the value object specified by the given indices array. virtual std :: any OpenOasis :: IValueSet :: GetValue ( const std :: vector < int > & indices ) const = 0 Parameters: indices Indices of each dimension. Returns: The value object for the given indices. Exception: The length of the array of indices is N, so that the index for each dimension is specified. Otherwise throw an exception. function GetValueDefinition \u00b6 Definition of the values in the value set. virtual std :: shared_ptr < IValueDefinition > OpenOasis :: IValueSet :: GetValueDefinition () const = 0 The \"IValueDefinition\" should never be returned directly; The all implementing classes should return either an IQuality , an IQuantity , or a custom derived value definition interface. function IsValues2D \u00b6 virtual bool OpenOasis :: IValueSet :: IsValues2D () const = 0 function RemoveValue \u00b6 Removes the values specified by the given indices. virtual void OpenOasis :: IValueSet :: RemoveValue ( const std :: vector < int > & indices ) = 0 It is possible to remove not just a single value item, but also the whole set of values for the given indices. Parameters: indices Indices of specified dimension. function SetElementValuesForTime \u00b6 Sets the values, for all elements, for the given timeIndex. If data is time independent, timeIndex must be specified as 0. virtual void OpenOasis :: IValueSet :: SetElementValuesForTime ( int timeIndex , const std :: vector < std :: any > & values ) = 0 Parameters: timeIndex Index of time in ITimeSet . values Element valueset at given time. Exception: If timeIndex is out of range, throw an exception. function SetOrAddValue \u00b6 Sets or adds the value object specified by the given indices. virtual void OpenOasis :: IValueSet :: SetOrAddValue ( const std :: vector < int > & indices , const std :: any & value ) = 0 Parameters: indices Indices of each dimension. value Value object to be set or added. Exception: The length of the array of indices is N, so that the index for each dimension is specified. Otherwise throw an exception. function SetTimeSeriesValuesForElement \u00b6 Sets the values, for all times, for the given elementIndex. If the data is spatial independent, elementIndex must be specified as 0. virtual void OpenOasis :: IValueSet :: SetTimeSeriesValuesForElement ( int elementIndex , const std :: vector < std :: any > & values ) = 0 Parameters: elementIndex Index of element in IElementSet . values Timeseries values for given element. Exception: If the elementIndex is out of range, throw an exception. The documentation for this class was generated from the following file Models/Inc/IValueSet.h","title":"Class OpenOasis::IValueSet"},{"location":"models/class_open_oasis_1_1_i_value_set/#class-openoasisivalueset","text":"ClassList > OpenOasis > IValueSet Class represents a general(ordered) multi-dimensional set of values. More... #include <IValueSet.h>","title":"Class OpenOasis::IValueSet"},{"location":"models/class_open_oasis_1_1_i_value_set/#public-functions","text":"Type Name virtual std::vector< std::any > GetElementValuesForTime (int timeIndex) const = 0 Gets the values, for all elements, for the given timeIndex. If data is time independent, timeIndex must be specified as 0. virtual int GetIndexCount (const std::vector< int > & indices) const = 0 Returns the length of the dimension specified. virtual int GetNumberOfIndices () const = 0 Returns the number of possible indices (dimensions). virtual std::vector< std::any > GetTimeSeriesValuesForElement (int elementIndex) const = 0 Gets the values, for all times, for the given elementIndex. If the data is spatial independent, elementIndex must be specified as 0. virtual std::any GetValue (const std::vector< int > & indices) const = 0 Returns the value object specified by the given indices array. virtual std::shared_ptr< IValueDefinition > GetValueDefinition () const = 0 Definition of the values in the value set. virtual bool IsValues2D () const = 0 Whether this value set is a specified two-dimensional type. virtual void RemoveValue (const std::vector< int > & indices) = 0 Removes the values specified by the given indices. virtual void SetElementValuesForTime (int timeIndex, const std::vector< std::any > & values) = 0 Sets the values, for all elements, for the given timeIndex. If data is time independent, timeIndex must be specified as 0. virtual void SetOrAddValue (const std::vector< int > & indices, const std::any & value) = 0 Sets or adds the value object specified by the given indices. virtual void SetTimeSeriesValuesForElement (int elementIndex, const std::vector< std::any > & values) = 0 Sets the values, for all times, for the given elementIndex. If the data is spatial independent, elementIndex must be specified as 0.","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_i_value_set/#detailed-description","text":"The size of each dimension can vary, depending on the indices provided, e.g. In a 2D matrix, each row can have different lengths. For example, assuming the data is stored as a double matrix, then matrix[1].Size need not equal to matrix[2].Size.","title":"Detailed Description"},{"location":"models/class_open_oasis_1_1_i_value_set/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_i_value_set/#function-getelementvaluesfortime","text":"Gets the values, for all elements, for the given timeIndex. If data is time independent, timeIndex must be specified as 0. virtual std :: vector < std :: any > OpenOasis :: IValueSet :: GetElementValuesForTime ( int timeIndex ) const = 0 Parameters: timeIndex Index of time in ITimeSet . Returns: Element valueset at given time. Exception: If timeIndex is out of range, throw an exception.","title":"function GetElementValuesForTime"},{"location":"models/class_open_oasis_1_1_i_value_set/#function-getindexcount","text":"Returns the length of the dimension specified. virtual int OpenOasis :: IValueSet :: GetIndexCount ( const std :: vector < int > & indices ) const = 0 To get the size of the specified dimension, use zero-length int array as input argument. Length of indice must be a least one smaller than the GetNumberOfIndices() . Parameters: indices Indices of the dimension to get the size of. Returns: Length of the specified dimension.","title":"function GetIndexCount"},{"location":"models/class_open_oasis_1_1_i_value_set/#function-getnumberofindices","text":"Returns the number of possible indices (dimensions). virtual int OpenOasis :: IValueSet :: GetNumberOfIndices () const = 0 Returns: number of indices, zero based.","title":"function GetNumberOfIndices"},{"location":"models/class_open_oasis_1_1_i_value_set/#function-gettimeseriesvaluesforelement","text":"Gets the values, for all times, for the given elementIndex. If the data is spatial independent, elementIndex must be specified as 0. virtual std :: vector < std :: any > OpenOasis :: IValueSet :: GetTimeSeriesValuesForElement ( int elementIndex ) const = 0 Parameters: elementIndex Index of element in IElementSet . Returns: The timeseries values. Exception: If the elementIndex is out of range, throw an exception.","title":"function GetTimeSeriesValuesForElement"},{"location":"models/class_open_oasis_1_1_i_value_set/#function-getvalue","text":"Returns the value object specified by the given indices array. virtual std :: any OpenOasis :: IValueSet :: GetValue ( const std :: vector < int > & indices ) const = 0 Parameters: indices Indices of each dimension. Returns: The value object for the given indices. Exception: The length of the array of indices is N, so that the index for each dimension is specified. Otherwise throw an exception.","title":"function GetValue"},{"location":"models/class_open_oasis_1_1_i_value_set/#function-getvaluedefinition","text":"Definition of the values in the value set. virtual std :: shared_ptr < IValueDefinition > OpenOasis :: IValueSet :: GetValueDefinition () const = 0 The \"IValueDefinition\" should never be returned directly; The all implementing classes should return either an IQuality , an IQuantity , or a custom derived value definition interface.","title":"function GetValueDefinition"},{"location":"models/class_open_oasis_1_1_i_value_set/#function-isvalues2d","text":"virtual bool OpenOasis :: IValueSet :: IsValues2D () const = 0","title":"function IsValues2D"},{"location":"models/class_open_oasis_1_1_i_value_set/#function-removevalue","text":"Removes the values specified by the given indices. virtual void OpenOasis :: IValueSet :: RemoveValue ( const std :: vector < int > & indices ) = 0 It is possible to remove not just a single value item, but also the whole set of values for the given indices. Parameters: indices Indices of specified dimension.","title":"function RemoveValue"},{"location":"models/class_open_oasis_1_1_i_value_set/#function-setelementvaluesfortime","text":"Sets the values, for all elements, for the given timeIndex. If data is time independent, timeIndex must be specified as 0. virtual void OpenOasis :: IValueSet :: SetElementValuesForTime ( int timeIndex , const std :: vector < std :: any > & values ) = 0 Parameters: timeIndex Index of time in ITimeSet . values Element valueset at given time. Exception: If timeIndex is out of range, throw an exception.","title":"function SetElementValuesForTime"},{"location":"models/class_open_oasis_1_1_i_value_set/#function-setoraddvalue","text":"Sets or adds the value object specified by the given indices. virtual void OpenOasis :: IValueSet :: SetOrAddValue ( const std :: vector < int > & indices , const std :: any & value ) = 0 Parameters: indices Indices of each dimension. value Value object to be set or added. Exception: The length of the array of indices is N, so that the index for each dimension is specified. Otherwise throw an exception.","title":"function SetOrAddValue"},{"location":"models/class_open_oasis_1_1_i_value_set/#function-settimeseriesvaluesforelement","text":"Sets the values, for all times, for the given elementIndex. If the data is spatial independent, elementIndex must be specified as 0. virtual void OpenOasis :: IValueSet :: SetTimeSeriesValuesForElement ( int elementIndex , const std :: vector < std :: any > & values ) = 0 Parameters: elementIndex Index of element in IElementSet . values Timeseries values for given element. Exception: If the elementIndex is out of range, throw an exception. The documentation for this class was generated from the following file Models/Inc/IValueSet.h","title":"function SetTimeSeriesValuesForElement"},{"location":"models/class_open_oasis_1_1_linkable_component_status_change_event_args/","text":"Class OpenOasis::LinkableComponentStatusChangeEventArgs \u00b6 ClassList > OpenOasis > LinkableComponentStatusChangeEventArgs Class contains the information that will be passed when the ILinkableComponent fires the StatusChanged event. #include <LinkableComponentStatusChangeEventArgs.h> Public Functions \u00b6 Type Name virtual std::shared_ptr< ILinkableComponent > GetLinkableComponent () const = 0 virtual std::string GetMessages () const = 0 virtual LinkableComponentStatus GetNewStatus () const = 0 virtual LinkableComponentStatus GetOldStatus () const = 0 virtual void SetLinkableComponent (std::shared_ptr< ILinkableComponent > obj) = 0 virtual void SetMessages (const std::string & msg) = 0 virtual void SetNewStatus ( LinkableComponentStatus value) = 0 virtual void SetOldStatus ( LinkableComponentStatus value) = 0 Public Functions Documentation \u00b6 function GetLinkableComponent \u00b6 virtual std :: shared_ptr < ILinkableComponent > OpenOasis :: LinkableComponentStatusChangeEventArgs :: GetLinkableComponent () const = 0 function GetMessages \u00b6 virtual std :: string OpenOasis :: LinkableComponentStatusChangeEventArgs :: GetMessages () const = 0 function GetNewStatus \u00b6 virtual LinkableComponentStatus OpenOasis :: LinkableComponentStatusChangeEventArgs :: GetNewStatus () const = 0 function GetOldStatus \u00b6 virtual LinkableComponentStatus OpenOasis :: LinkableComponentStatusChangeEventArgs :: GetOldStatus () const = 0 function SetLinkableComponent \u00b6 virtual void OpenOasis :: LinkableComponentStatusChangeEventArgs :: SetLinkableComponent ( std :: shared_ptr < ILinkableComponent > obj ) = 0 function SetMessages \u00b6 virtual void OpenOasis :: LinkableComponentStatusChangeEventArgs :: SetMessages ( const std :: string & msg ) = 0 function SetNewStatus \u00b6 virtual void OpenOasis :: LinkableComponentStatusChangeEventArgs :: SetNewStatus ( LinkableComponentStatus value ) = 0 function SetOldStatus \u00b6 virtual void OpenOasis :: LinkableComponentStatusChangeEventArgs :: SetOldStatus ( LinkableComponentStatus value ) = 0 The documentation for this class was generated from the following file Models/Inc/LinkableComponentStatusChangeEventArgs.h","title":"Class OpenOasis::LinkableComponentStatusChangeEventArgs"},{"location":"models/class_open_oasis_1_1_linkable_component_status_change_event_args/#class-openoasislinkablecomponentstatuschangeeventargs","text":"ClassList > OpenOasis > LinkableComponentStatusChangeEventArgs Class contains the information that will be passed when the ILinkableComponent fires the StatusChanged event. #include <LinkableComponentStatusChangeEventArgs.h>","title":"Class OpenOasis::LinkableComponentStatusChangeEventArgs"},{"location":"models/class_open_oasis_1_1_linkable_component_status_change_event_args/#public-functions","text":"Type Name virtual std::shared_ptr< ILinkableComponent > GetLinkableComponent () const = 0 virtual std::string GetMessages () const = 0 virtual LinkableComponentStatus GetNewStatus () const = 0 virtual LinkableComponentStatus GetOldStatus () const = 0 virtual void SetLinkableComponent (std::shared_ptr< ILinkableComponent > obj) = 0 virtual void SetMessages (const std::string & msg) = 0 virtual void SetNewStatus ( LinkableComponentStatus value) = 0 virtual void SetOldStatus ( LinkableComponentStatus value) = 0","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_linkable_component_status_change_event_args/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_linkable_component_status_change_event_args/#function-getlinkablecomponent","text":"virtual std :: shared_ptr < ILinkableComponent > OpenOasis :: LinkableComponentStatusChangeEventArgs :: GetLinkableComponent () const = 0","title":"function GetLinkableComponent"},{"location":"models/class_open_oasis_1_1_linkable_component_status_change_event_args/#function-getmessages","text":"virtual std :: string OpenOasis :: LinkableComponentStatusChangeEventArgs :: GetMessages () const = 0","title":"function GetMessages"},{"location":"models/class_open_oasis_1_1_linkable_component_status_change_event_args/#function-getnewstatus","text":"virtual LinkableComponentStatus OpenOasis :: LinkableComponentStatusChangeEventArgs :: GetNewStatus () const = 0","title":"function GetNewStatus"},{"location":"models/class_open_oasis_1_1_linkable_component_status_change_event_args/#function-getoldstatus","text":"virtual LinkableComponentStatus OpenOasis :: LinkableComponentStatusChangeEventArgs :: GetOldStatus () const = 0","title":"function GetOldStatus"},{"location":"models/class_open_oasis_1_1_linkable_component_status_change_event_args/#function-setlinkablecomponent","text":"virtual void OpenOasis :: LinkableComponentStatusChangeEventArgs :: SetLinkableComponent ( std :: shared_ptr < ILinkableComponent > obj ) = 0","title":"function SetLinkableComponent"},{"location":"models/class_open_oasis_1_1_linkable_component_status_change_event_args/#function-setmessages","text":"virtual void OpenOasis :: LinkableComponentStatusChangeEventArgs :: SetMessages ( const std :: string & msg ) = 0","title":"function SetMessages"},{"location":"models/class_open_oasis_1_1_linkable_component_status_change_event_args/#function-setnewstatus","text":"virtual void OpenOasis :: LinkableComponentStatusChangeEventArgs :: SetNewStatus ( LinkableComponentStatus value ) = 0","title":"function SetNewStatus"},{"location":"models/class_open_oasis_1_1_linkable_component_status_change_event_args/#function-setoldstatus","text":"virtual void OpenOasis :: LinkableComponentStatusChangeEventArgs :: SetOldStatus ( LinkableComponentStatus value ) = 0 The documentation for this class was generated from the following file Models/Inc/LinkableComponentStatusChangeEventArgs.h","title":"function SetOldStatus"},{"location":"models/namespace_open_oasis_1_1_syst_heats/","text":"Namespace OpenOasis::SystHeats \u00b6 Namespace List > OpenOasis > SystHeats More... Classes \u00b6 Type Name class HeatConductionModel Detailed Description \u00b6 @File : HeatConductionModel.cpp @Brief : Heat conduction model. The documentation for this class was generated from the following file Models/SystHeats/HeatConductionModel/HeatConductionModel.cpp","title":"Heats"},{"location":"models/namespace_open_oasis_1_1_syst_heats/#namespace-openoasissystheats","text":"Namespace List > OpenOasis > SystHeats More...","title":"Namespace OpenOasis::SystHeats"},{"location":"models/namespace_open_oasis_1_1_syst_heats/#classes","text":"Type Name class HeatConductionModel","title":"Classes"},{"location":"models/namespace_open_oasis_1_1_syst_heats/#detailed-description","text":"@File : HeatConductionModel.cpp @Brief : Heat conduction model. The documentation for this class was generated from the following file Models/SystHeats/HeatConductionModel/HeatConductionModel.cpp","title":"Detailed Description"},{"location":"models/class_open_oasis_1_1_syst_heats_1_1_heat_conduction_model/","text":"Class OpenOasis::SystHeats::HeatConductionModel \u00b6 ClassList > OpenOasis > SystHeats > HeatConductionModel Inherits the following classes: LinkableComponent Public Functions \u00b6 Type Name HeatConductionModel (const std::string & id, const std::string & taskFile) virtual ~HeatConductionModel () = default Public Functions Documentation \u00b6 function HeatConductionModel \u00b6 OpenOasis :: SystHeats :: HeatConductionModel :: HeatConductionModel ( const std :: string & id , const std :: string & taskFile ) function ~HeatConductionModel \u00b6 virtual OpenOasis :: SystHeats :: HeatConductionModel ::~ HeatConductionModel () = default The documentation for this class was generated from the following file Models/SystHeats/HeatConductionModel/HeatConductionModel.h","title":"Class OpenOasis::SystHeats::HeatConductionModel"},{"location":"models/class_open_oasis_1_1_syst_heats_1_1_heat_conduction_model/#class-openoasissystheatsheatconductionmodel","text":"ClassList > OpenOasis > SystHeats > HeatConductionModel Inherits the following classes: LinkableComponent","title":"Class OpenOasis::SystHeats::HeatConductionModel"},{"location":"models/class_open_oasis_1_1_syst_heats_1_1_heat_conduction_model/#public-functions","text":"Type Name HeatConductionModel (const std::string & id, const std::string & taskFile) virtual ~HeatConductionModel () = default","title":"Public Functions"},{"location":"models/class_open_oasis_1_1_syst_heats_1_1_heat_conduction_model/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"models/class_open_oasis_1_1_syst_heats_1_1_heat_conduction_model/#function-heatconductionmodel","text":"OpenOasis :: SystHeats :: HeatConductionModel :: HeatConductionModel ( const std :: string & id , const std :: string & taskFile )","title":"function HeatConductionModel"},{"location":"models/class_open_oasis_1_1_syst_heats_1_1_heat_conduction_model/#function-heatconductionmodel_1","text":"virtual OpenOasis :: SystHeats :: HeatConductionModel ::~ HeatConductionModel () = default The documentation for this class was generated from the following file Models/SystHeats/HeatConductionModel/HeatConductionModel.h","title":"function ~HeatConductionModel"},{"location":"models/namespace_utils/","text":"Namespace Utils \u00b6 Namespace List > Utils The documentation for this class was generated from the following file Models/SystHeats/HeatConductionModel/HeatConductionModel.cpp","title":"Namespace Utils"},{"location":"models/namespace_utils/#namespace-utils","text":"Namespace List > Utils The documentation for this class was generated from the following file Models/SystHeats/HeatConductionModel/HeatConductionModel.cpp","title":"Namespace Utils"},{"location":"models/namespacestd/","text":"Namespace std \u00b6 Namespace List > std The documentation for this class was generated from the following file Models/SystHeats/HeatConductionModel/HeatConductionModel.cpp","title":"Namespace std"},{"location":"models/namespacestd/#namespace-std","text":"Namespace List > std The documentation for this class was generated from the following file Models/SystHeats/HeatConductionModel/HeatConductionModel.cpp","title":"Namespace std"},{"location":"models/dir_22305cb0964bbe63c21991dd2265ce48/","text":"Dir Models \u00b6 FileList > Models Directories \u00b6 Type Name dir CommImp dir Inc dir SystHeats The documentation for this class was generated from the following file Models/","title":"Dir Models"},{"location":"models/dir_22305cb0964bbe63c21991dd2265ce48/#dir-models","text":"FileList > Models","title":"Dir Models"},{"location":"models/dir_22305cb0964bbe63c21991dd2265ce48/#directories","text":"Type Name dir CommImp dir Inc dir SystHeats The documentation for this class was generated from the following file Models/","title":"Directories"},{"location":"models/dir_6202b98a8704f42b1ea358646461643f/","text":"Dir Models/CommImp \u00b6 FileList > CommImp Directories \u00b6 Type Name dir IO dir Numeric dir Spatial dir Temporal The documentation for this class was generated from the following file Models/CommImp/","title":"Dir Models/CommImp"},{"location":"models/dir_6202b98a8704f42b1ea358646461643f/#dir-modelscommimp","text":"FileList > CommImp","title":"Dir Models/CommImp"},{"location":"models/dir_6202b98a8704f42b1ea358646461643f/#directories","text":"Type Name dir IO dir Numeric dir Spatial dir Temporal The documentation for this class was generated from the following file Models/CommImp/","title":"Directories"},{"location":"models/dir_3b1940e7bde9c1f91eabae8dc723b4f2/","text":"Dir Models/CommImp/IO \u00b6 FileList > CommImp > IO Files \u00b6 Type Name file LinkLoader.cpp file LinkLoader.h file Logger.cpp file Logger.h file MeshLoader.cpp file MeshLoader.h file NetworkLoader.h file OutputCsv.h file TaskLoader.h The documentation for this class was generated from the following file Models/CommImp/IO/","title":"Dir Models/CommImp/IO"},{"location":"models/dir_3b1940e7bde9c1f91eabae8dc723b4f2/#dir-modelscommimpio","text":"FileList > CommImp > IO","title":"Dir Models/CommImp/IO"},{"location":"models/dir_3b1940e7bde9c1f91eabae8dc723b4f2/#files","text":"Type Name file LinkLoader.cpp file LinkLoader.h file Logger.cpp file Logger.h file MeshLoader.cpp file MeshLoader.h file NetworkLoader.h file OutputCsv.h file TaskLoader.h The documentation for this class was generated from the following file Models/CommImp/IO/","title":"Files"},{"location":"models/_link_loader_8cpp/","text":"File LinkLoader.cpp \u00b6 FileList > CommImp > IO > LinkLoader.cpp Go to the source code of this file #include \"LinkLoader.h\" #include \"Logger.h\" #include \"Utils/FilePathHelper.h\" #include \"Utils/Exception.h\" #include \"Utils/StringHelper.h\" #include \"Utils/MapHelper.h\" #include <set> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace IO The documentation for this class was generated from the following file Models/CommImp/IO/LinkLoader.cpp","title":"File LinkLoader.cpp"},{"location":"models/_link_loader_8cpp/#file-linkloadercpp","text":"FileList > CommImp > IO > LinkLoader.cpp Go to the source code of this file #include \"LinkLoader.h\" #include \"Logger.h\" #include \"Utils/FilePathHelper.h\" #include \"Utils/Exception.h\" #include \"Utils/StringHelper.h\" #include \"Utils/MapHelper.h\" #include <set>","title":"File LinkLoader.cpp"},{"location":"models/_link_loader_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace IO The documentation for this class was generated from the following file Models/CommImp/IO/LinkLoader.cpp","title":"Namespaces"},{"location":"models/_link_loader_8cpp_source/","text":"File LinkLoader.cpp \u00b6 File List > CommImp > IO > LinkLoader.cpp Go to the documentation of this file #include \"LinkLoader.h\" #include \"Logger.h\" #include \"Utils/FilePathHelper.h\" #include \"Utils/Exception.h\" #include \"Utils/StringHelper.h\" #include \"Utils/MapHelper.h\" #include <set> namespace OpenOasis :: CommImp :: IO { using namespace std ; using namespace Utils ; static shared_ptr < spdlog :: logger > logger = GetLogger (); void LinkLoader::Load () { logger -> info ( \"Loading links from [{}].\" , mLinkFile ); LoadComponents (); LoadLinks (); logger -> info ( \"Loading links completed.\" ); } void LinkLoader::LoadComponents () { auto compsJson = mLoader . GetJson ( mLoader . GetJson (), \"comps\" ). value (); auto compIds = mLoader . GetKeys ( compsJson ); for ( auto id : compIds ) { auto confs = mLoader . GetMap ( compsJson , id ); if ( confs . count ( \"type\" ) * confs . count ( \"task\" ) * confs . count ( \"dll\" ) < 1 ) { throw IllegalArgumentException ( StringHelper :: FormatSimple ( \"Component [{}] configuration is incomplete.\" , id )); } ComponentInfo infos = { confs [ \"type\" ], confs [ \"task\" ], confs [ \"dll\" ]}; mComps . emplace ( id , infos ); } } vector < string > LinkLoader :: GetComponentIds () const { return MapHelper :: GetKeys ( mComps ); } LinkLoader :: ComponentInfo LinkLoader :: GetComponentInfo ( const string & id ) const { return mComps . at ( id ); } void LinkLoader :: LoadLinks () { auto linksJson = mLoader . GetJson ( mLoader . GetJson (), \"links\" ). value (); auto linkIds = mLoader . GetKeys ( linksJson ); unordered_map < string , vector < string >> linkGroups ; unordered_map < string , string > linkModes ; unordered_map < string , unordered_map < string , string >> linkConfs ; for ( auto id : linkIds ) { auto linkJson = mLoader . GetJson ( linksJson , id ). value (); // Get the mode and parameters of the current link. auto mode = mLoader . GetValue < string > ( linkJson , \"mode\" ); string modeId = mode . has_value () ? mode . value () : \"PULL\" ; linkModes [ id ] = modeId ; auto parms = mLoader . GetMap ( linkJson , \"params\" ); linkConfs [ id ] = parms ; // Get data exchage pipelines of the current link. auto pipelinesJson = mLoader . GetJson ( linkJson , \"pipelines\" ). value (); int pipelineNum = mLoader . GetArraySize ( pipelinesJson ); for ( int i = 0 ; i < pipelineNum ; i ++ ) { LoadPipeline ( id , pipelinesJson , i , linkGroups ); } } // Collect the coupling groups. CollectIteratorGroups ( linkGroups , linkModes , linkConfs ); } vector < LinkLoader :: ElementInfo > LinkLoader :: GetComponentOutputs ( const string & compId ) const { if ( mOuts . count ( compId ) == 0 ) { return {}; } return mOuts . at ( compId ); } unordered_map < string , vector < LinkLoader :: ElementInfo >> LinkLoader :: GetOutputConsumers ( const string & compId , const ElementInfo & output ) const { string outputId = GenerateUniqueElementId ( compId , output ); auto consumers = mOutputConsumers . at ( outputId ); unordered_map < string , vector < ElementInfo >> res ; for ( const auto & consumerId : consumers ) { auto consumer = SplitUniqueElementId ( consumerId ); auto compId = consumer [ 0 ]; auto elemId = consumer [ 1 ]; auto elemType = consumer [ 2 ]; auto state = consumer [ 3 ]; auto tOptId = consumer [ 4 ]; auto sOptId = consumer [ 5 ]; ElementInfo elemInfo = { elemId , elemType , state , tOptId , sOptId }; if ( res . count ( compId ) == 0 ) { res [ compId ] = { elemInfo }; } else { res [ compId ]. emplace_back ( elemInfo ); } } return res ; } vector < LinkLoader :: ElementInfo > LinkLoader :: GetComponentInputs ( const string & compId ) const { if ( mInps . count ( compId ) == 0 ) { return {}; } return mInps . at ( compId ); } unordered_map < string , vector < LinkLoader :: ElementInfo >> LinkLoader :: GetInputProviders ( const string & compId , const ElementInfo & input ) const { string inputId = GenerateUniqueElementId ( compId , input ); auto providers = mInputProviders . at ( inputId ); unordered_map < string , vector < ElementInfo >> res ; for ( const auto & providerId : providers ) { auto provider = SplitUniqueElementId ( providerId ); auto compId = provider [ 0 ]; auto elemId = provider [ 1 ]; auto elemType = provider [ 2 ]; auto state = provider [ 3 ]; auto tOptId = provider [ 4 ]; auto sOptId = provider [ 5 ]; ElementInfo elemInfo = { elemId , elemType , state , tOptId , sOptId }; if ( res . count ( compId ) == 0 ) { res [ compId ] = { elemInfo }; } else { res [ compId ]. emplace_back ( elemInfo ); } } return res ; } unordered_map < string , vector < string >> LinkLoader :: GetIteratorGroups () const { return mIterGroups ; } multimap < string , string > LinkLoader :: GetIteratorConfigs ( const string & iterId ) const { if ( mIterConfigs . count ( iterId ) == 0 ) { return {}; } return mIterConfigs . at ( iterId ); } void LinkLoader :: CollectIteratorGroups ( const unordered_map < string , vector < string >> & linkGroups , const unordered_map < string , string > & linkModes , const unordered_map < string , unordered_map < string , string >> & linkConfs ) { int maxGroupSize = linkModes . size (); // Collect the loop coupling groups. vector < set < string >> groups ( maxGroupSize ), links ( maxGroupSize ); for ( auto & pair : linkGroups ) { string linkId = pair . first ; if ( StringHelper :: ToUpper ( linkModes . at ( linkId )) != \"LOOP\" ) { continue ; } // Check if the link has been added to a group. auto comps = pair . second ; for ( int i = 0 ; i < maxGroupSize ; i ++ ) { if ( groups [ i ]. count ( comps . front ())) { groups [ i ]. insert ( comps . back ()); links [ i ]. insert ( linkId ); break ; } if ( groups [ i ]. count ( comps . back ())) { groups [ i ]. insert ( comps . front ()); links [ i ]. insert ( linkId ); break ; } } } for ( int i = 0 ; i < maxGroupSize ; i ++ ) { if ( groups [ i ]. empty ()) { continue ; } string groupId = StringHelper :: FormatSimple ( \"LOOP_GROUP_{}\" , i ); mIterGroups [ groupId ] = vector < string > ( groups [ i ]. begin (), groups [ i ]. end ()); } // Collect loop coupling groups parameters. for ( int i = 0 ; i < maxGroupSize ; i ++ ) { if ( groups [ i ]. empty ()) { continue ; } string groupId = StringHelper :: FormatSimple ( \"LOOP_GROUP_{}\" , i ); multimap < string , string > params ; for ( const auto & linkId : links [ i ]) { auto confs = linkConfs . at ( linkId ); for ( auto & pair : confs ) { params . insert ( pair ); } } mIterConfigs [ groupId ] = params ; } } void LinkLoader :: LoadPipeline ( const string & linkId , const nlohmann :: json & json , int index , unordered_map < string , vector < string >> & linkGroups ) { auto pipelineJson = mLoader . GetJson ( json , index ). value (); // Get the source and target components, also the exchanged state. string srcCompId = mLoader . GetValue < string > ( pipelineJson , \"src_component\" ). value (); string srcState = mLoader . GetValue < string > ( pipelineJson , \"src_state\" ). value (); string tarCompId = mLoader . GetValue < string > ( pipelineJson , \"tar_component\" ). value (); // Get the temporal and spatial operators. auto tOperator = mLoader . GetValue < string > ( pipelineJson , \"temporal_operators\" ); string tOptId = tOperator . has_value () ? tOperator . value () : \"\" ; auto sOperator = mLoader . GetValue < string > ( pipelineJson , \"spatial_operators\" ); string sOptId = sOperator . has_value () ? sOperator . value () : \"\" ; // Get the target element. auto tarElement = mLoader . GetMap ( pipelineJson , \"tar_element\" ); string tarElemId = tarElement [ \"id\" ]; string tarElemType = tarElement [ \"type\" ]; // Collect the inputs of the target component. ElementInfo tarElemInfo = { tarElemId , tarElemType , srcState , \"\" , \"\" }; mInps [ tarCompId ]. emplace_back ( tarElemInfo ); // Get the source elements. auto elementsJson = mLoader . GetJson ( pipelineJson , \"src_elements\" ). value (); int elementNum = mLoader . GetArraySize ( elementsJson ); for ( int j = 0 ; j < elementNum ; j ++ ) { auto srcElements = mLoader . GetMap ( elementsJson , j ); string srcElemId = srcElements [ \"id\" ]; string srcElemType = srcElements [ \"type\" ]; // Collect the outputs of the source component. ElementInfo srcElemInfo = { srcElemId , srcElemType , srcState , tOptId , sOptId }; mOuts [ srcCompId ]. emplace_back ( srcElemInfo ); // Collect the exchange item map. CollectExchangeItemMap ( srcCompId , srcElemInfo , tarCompId , tarElemInfo ); } // Collect the coupling groups. linkGroups [ linkId ] = { srcCompId , tarCompId }; } void LinkLoader :: CollectExchangeItemMap ( const string & srcCompId , const ElementInfo & output , const string & tarCompId , const ElementInfo & input ) { string outputId = GenerateUniqueElementId ( srcCompId , output ); string inputId = GenerateUniqueElementId ( tarCompId , input ); auto setter = []( const string & key , const string & value , unordered_map < string , vector < string >> & map ) { if ( map . count ( key ) == 0 ) { map [ key ] = { value }; } else { map [ key ]. emplace_back ( value ); } }; setter ( outputId , inputId , mOutputConsumers ); setter ( inputId , outputId , mInputProviders ); } string LinkLoader :: GenerateUniqueElementId ( const string & compId , const ElementInfo & element ) const { return StringHelper :: FormatSimple ( \"{}_{}_{}_{}_{}_{}\" , compId , element [ 0 ], element [ 1 ], element [ 2 ], element [ 3 ], element [ 4 ]); } vector < string > LinkLoader :: SplitUniqueElementId ( const string & uniqueId ) const { auto parts = StringHelper :: Split ( uniqueId , '_' ); if ( parts . size () != 6 ) { throw IllegalArgumentException ( StringHelper :: FormatSimple ( \"Invalid unique element id [{}].\" , uniqueId )); } return parts ; } } // namespace OpenOasis::CommImp::IO","title":"File LinkLoader.cpp"},{"location":"models/_link_loader_8cpp_source/#file-linkloadercpp","text":"File List > CommImp > IO > LinkLoader.cpp Go to the documentation of this file #include \"LinkLoader.h\" #include \"Logger.h\" #include \"Utils/FilePathHelper.h\" #include \"Utils/Exception.h\" #include \"Utils/StringHelper.h\" #include \"Utils/MapHelper.h\" #include <set> namespace OpenOasis :: CommImp :: IO { using namespace std ; using namespace Utils ; static shared_ptr < spdlog :: logger > logger = GetLogger (); void LinkLoader::Load () { logger -> info ( \"Loading links from [{}].\" , mLinkFile ); LoadComponents (); LoadLinks (); logger -> info ( \"Loading links completed.\" ); } void LinkLoader::LoadComponents () { auto compsJson = mLoader . GetJson ( mLoader . GetJson (), \"comps\" ). value (); auto compIds = mLoader . GetKeys ( compsJson ); for ( auto id : compIds ) { auto confs = mLoader . GetMap ( compsJson , id ); if ( confs . count ( \"type\" ) * confs . count ( \"task\" ) * confs . count ( \"dll\" ) < 1 ) { throw IllegalArgumentException ( StringHelper :: FormatSimple ( \"Component [{}] configuration is incomplete.\" , id )); } ComponentInfo infos = { confs [ \"type\" ], confs [ \"task\" ], confs [ \"dll\" ]}; mComps . emplace ( id , infos ); } } vector < string > LinkLoader :: GetComponentIds () const { return MapHelper :: GetKeys ( mComps ); } LinkLoader :: ComponentInfo LinkLoader :: GetComponentInfo ( const string & id ) const { return mComps . at ( id ); } void LinkLoader :: LoadLinks () { auto linksJson = mLoader . GetJson ( mLoader . GetJson (), \"links\" ). value (); auto linkIds = mLoader . GetKeys ( linksJson ); unordered_map < string , vector < string >> linkGroups ; unordered_map < string , string > linkModes ; unordered_map < string , unordered_map < string , string >> linkConfs ; for ( auto id : linkIds ) { auto linkJson = mLoader . GetJson ( linksJson , id ). value (); // Get the mode and parameters of the current link. auto mode = mLoader . GetValue < string > ( linkJson , \"mode\" ); string modeId = mode . has_value () ? mode . value () : \"PULL\" ; linkModes [ id ] = modeId ; auto parms = mLoader . GetMap ( linkJson , \"params\" ); linkConfs [ id ] = parms ; // Get data exchage pipelines of the current link. auto pipelinesJson = mLoader . GetJson ( linkJson , \"pipelines\" ). value (); int pipelineNum = mLoader . GetArraySize ( pipelinesJson ); for ( int i = 0 ; i < pipelineNum ; i ++ ) { LoadPipeline ( id , pipelinesJson , i , linkGroups ); } } // Collect the coupling groups. CollectIteratorGroups ( linkGroups , linkModes , linkConfs ); } vector < LinkLoader :: ElementInfo > LinkLoader :: GetComponentOutputs ( const string & compId ) const { if ( mOuts . count ( compId ) == 0 ) { return {}; } return mOuts . at ( compId ); } unordered_map < string , vector < LinkLoader :: ElementInfo >> LinkLoader :: GetOutputConsumers ( const string & compId , const ElementInfo & output ) const { string outputId = GenerateUniqueElementId ( compId , output ); auto consumers = mOutputConsumers . at ( outputId ); unordered_map < string , vector < ElementInfo >> res ; for ( const auto & consumerId : consumers ) { auto consumer = SplitUniqueElementId ( consumerId ); auto compId = consumer [ 0 ]; auto elemId = consumer [ 1 ]; auto elemType = consumer [ 2 ]; auto state = consumer [ 3 ]; auto tOptId = consumer [ 4 ]; auto sOptId = consumer [ 5 ]; ElementInfo elemInfo = { elemId , elemType , state , tOptId , sOptId }; if ( res . count ( compId ) == 0 ) { res [ compId ] = { elemInfo }; } else { res [ compId ]. emplace_back ( elemInfo ); } } return res ; } vector < LinkLoader :: ElementInfo > LinkLoader :: GetComponentInputs ( const string & compId ) const { if ( mInps . count ( compId ) == 0 ) { return {}; } return mInps . at ( compId ); } unordered_map < string , vector < LinkLoader :: ElementInfo >> LinkLoader :: GetInputProviders ( const string & compId , const ElementInfo & input ) const { string inputId = GenerateUniqueElementId ( compId , input ); auto providers = mInputProviders . at ( inputId ); unordered_map < string , vector < ElementInfo >> res ; for ( const auto & providerId : providers ) { auto provider = SplitUniqueElementId ( providerId ); auto compId = provider [ 0 ]; auto elemId = provider [ 1 ]; auto elemType = provider [ 2 ]; auto state = provider [ 3 ]; auto tOptId = provider [ 4 ]; auto sOptId = provider [ 5 ]; ElementInfo elemInfo = { elemId , elemType , state , tOptId , sOptId }; if ( res . count ( compId ) == 0 ) { res [ compId ] = { elemInfo }; } else { res [ compId ]. emplace_back ( elemInfo ); } } return res ; } unordered_map < string , vector < string >> LinkLoader :: GetIteratorGroups () const { return mIterGroups ; } multimap < string , string > LinkLoader :: GetIteratorConfigs ( const string & iterId ) const { if ( mIterConfigs . count ( iterId ) == 0 ) { return {}; } return mIterConfigs . at ( iterId ); } void LinkLoader :: CollectIteratorGroups ( const unordered_map < string , vector < string >> & linkGroups , const unordered_map < string , string > & linkModes , const unordered_map < string , unordered_map < string , string >> & linkConfs ) { int maxGroupSize = linkModes . size (); // Collect the loop coupling groups. vector < set < string >> groups ( maxGroupSize ), links ( maxGroupSize ); for ( auto & pair : linkGroups ) { string linkId = pair . first ; if ( StringHelper :: ToUpper ( linkModes . at ( linkId )) != \"LOOP\" ) { continue ; } // Check if the link has been added to a group. auto comps = pair . second ; for ( int i = 0 ; i < maxGroupSize ; i ++ ) { if ( groups [ i ]. count ( comps . front ())) { groups [ i ]. insert ( comps . back ()); links [ i ]. insert ( linkId ); break ; } if ( groups [ i ]. count ( comps . back ())) { groups [ i ]. insert ( comps . front ()); links [ i ]. insert ( linkId ); break ; } } } for ( int i = 0 ; i < maxGroupSize ; i ++ ) { if ( groups [ i ]. empty ()) { continue ; } string groupId = StringHelper :: FormatSimple ( \"LOOP_GROUP_{}\" , i ); mIterGroups [ groupId ] = vector < string > ( groups [ i ]. begin (), groups [ i ]. end ()); } // Collect loop coupling groups parameters. for ( int i = 0 ; i < maxGroupSize ; i ++ ) { if ( groups [ i ]. empty ()) { continue ; } string groupId = StringHelper :: FormatSimple ( \"LOOP_GROUP_{}\" , i ); multimap < string , string > params ; for ( const auto & linkId : links [ i ]) { auto confs = linkConfs . at ( linkId ); for ( auto & pair : confs ) { params . insert ( pair ); } } mIterConfigs [ groupId ] = params ; } } void LinkLoader :: LoadPipeline ( const string & linkId , const nlohmann :: json & json , int index , unordered_map < string , vector < string >> & linkGroups ) { auto pipelineJson = mLoader . GetJson ( json , index ). value (); // Get the source and target components, also the exchanged state. string srcCompId = mLoader . GetValue < string > ( pipelineJson , \"src_component\" ). value (); string srcState = mLoader . GetValue < string > ( pipelineJson , \"src_state\" ). value (); string tarCompId = mLoader . GetValue < string > ( pipelineJson , \"tar_component\" ). value (); // Get the temporal and spatial operators. auto tOperator = mLoader . GetValue < string > ( pipelineJson , \"temporal_operators\" ); string tOptId = tOperator . has_value () ? tOperator . value () : \"\" ; auto sOperator = mLoader . GetValue < string > ( pipelineJson , \"spatial_operators\" ); string sOptId = sOperator . has_value () ? sOperator . value () : \"\" ; // Get the target element. auto tarElement = mLoader . GetMap ( pipelineJson , \"tar_element\" ); string tarElemId = tarElement [ \"id\" ]; string tarElemType = tarElement [ \"type\" ]; // Collect the inputs of the target component. ElementInfo tarElemInfo = { tarElemId , tarElemType , srcState , \"\" , \"\" }; mInps [ tarCompId ]. emplace_back ( tarElemInfo ); // Get the source elements. auto elementsJson = mLoader . GetJson ( pipelineJson , \"src_elements\" ). value (); int elementNum = mLoader . GetArraySize ( elementsJson ); for ( int j = 0 ; j < elementNum ; j ++ ) { auto srcElements = mLoader . GetMap ( elementsJson , j ); string srcElemId = srcElements [ \"id\" ]; string srcElemType = srcElements [ \"type\" ]; // Collect the outputs of the source component. ElementInfo srcElemInfo = { srcElemId , srcElemType , srcState , tOptId , sOptId }; mOuts [ srcCompId ]. emplace_back ( srcElemInfo ); // Collect the exchange item map. CollectExchangeItemMap ( srcCompId , srcElemInfo , tarCompId , tarElemInfo ); } // Collect the coupling groups. linkGroups [ linkId ] = { srcCompId , tarCompId }; } void LinkLoader :: CollectExchangeItemMap ( const string & srcCompId , const ElementInfo & output , const string & tarCompId , const ElementInfo & input ) { string outputId = GenerateUniqueElementId ( srcCompId , output ); string inputId = GenerateUniqueElementId ( tarCompId , input ); auto setter = []( const string & key , const string & value , unordered_map < string , vector < string >> & map ) { if ( map . count ( key ) == 0 ) { map [ key ] = { value }; } else { map [ key ]. emplace_back ( value ); } }; setter ( outputId , inputId , mOutputConsumers ); setter ( inputId , outputId , mInputProviders ); } string LinkLoader :: GenerateUniqueElementId ( const string & compId , const ElementInfo & element ) const { return StringHelper :: FormatSimple ( \"{}_{}_{}_{}_{}_{}\" , compId , element [ 0 ], element [ 1 ], element [ 2 ], element [ 3 ], element [ 4 ]); } vector < string > LinkLoader :: SplitUniqueElementId ( const string & uniqueId ) const { auto parts = StringHelper :: Split ( uniqueId , '_' ); if ( parts . size () != 6 ) { throw IllegalArgumentException ( StringHelper :: FormatSimple ( \"Invalid unique element id [{}].\" , uniqueId )); } return parts ; } } // namespace OpenOasis::CommImp::IO","title":"File LinkLoader.cpp"},{"location":"models/_link_loader_8h/","text":"File LinkLoader.h \u00b6 FileList > CommImp > IO > LinkLoader.h Go to the source code of this file #include \"Models/Utils/JsonHandler.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace IO Classes \u00b6 Type Name class LinkLoader Class forLoading components coupling configurations json file. The documentation for this class was generated from the following file Models/CommImp/IO/LinkLoader.h","title":"File LinkLoader.h"},{"location":"models/_link_loader_8h/#file-linkloaderh","text":"FileList > CommImp > IO > LinkLoader.h Go to the source code of this file #include \"Models/Utils/JsonHandler.h\"","title":"File LinkLoader.h"},{"location":"models/_link_loader_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace IO","title":"Namespaces"},{"location":"models/_link_loader_8h/#classes","text":"Type Name class LinkLoader Class forLoading components coupling configurations json file. The documentation for this class was generated from the following file Models/CommImp/IO/LinkLoader.h","title":"Classes"},{"location":"models/_link_loader_8h_source/","text":"File LinkLoader.h \u00b6 File List > CommImp > IO > LinkLoader.h Go to the documentation of this file #pragma once #include \"Models/Utils/JsonHandler.h\" namespace OpenOasis :: CommImp :: IO { using Utils :: JsonLoader ; class LinkLoader { public : // Component information, contains: // - type // - task file path // - dll path using ComponentInfo = std :: array < std :: string , 3 > ; // Element(input/output) information, contains: // - id in component // - object type // - state // - temporal operator // - spatial operator using ElementInfo = std :: array < std :: string , 5 > ; private : std :: string mLinkFile ; JsonLoader mLoader ; std :: unordered_map < std :: string , std :: vector < std :: string >> mOutputConsumers ; std :: unordered_map < std :: string , std :: vector < std :: string >> mInputProviders ; std :: unordered_map < std :: string , ComponentInfo > mComps ; std :: unordered_map < std :: string , std :: vector < ElementInfo >> mInps ; std :: unordered_map < std :: string , std :: vector < ElementInfo >> mOuts ; // Iterator groups, contains: // - iterator group id // - component ids std :: unordered_map < std :: string , std :: vector < std :: string >> mIterGroups ; // Iterator configurations, contains: // - iterator group id // - iterator configurations std :: unordered_map < std :: string , std :: multimap < std :: string , std :: string >> mIterConfigs ; public : LinkLoader ( const std :: string & json ) : mLinkFile ( json ), mLoader ( json ) {} void Load (); std :: vector < std :: string > GetComponentIds () const ; ComponentInfo GetComponentInfo ( const std :: string & compId ) const ; std :: vector < ElementInfo > GetComponentOutputs ( const std :: string & compId ) const ; std :: unordered_map < std :: string , std :: vector < ElementInfo >> GetOutputConsumers ( const std :: string & compId , const ElementInfo & output ) const ; std :: vector < ElementInfo > GetComponentInputs ( const std :: string & compId ) const ; std :: unordered_map < std :: string , std :: vector < ElementInfo >> GetInputProviders ( const std :: string & compId , const ElementInfo & input ) const ; std :: unordered_map < std :: string , std :: vector < std :: string >> GetIteratorGroups () const ; std :: multimap < std :: string , std :: string > GetIteratorConfigs ( const std :: string & iterId ) const ; private : void LoadComponents (); void LoadLinks (); void LoadPipeline ( const std :: string & linkId , const nlohmann :: json & json , int index , std :: unordered_map < std :: string , std :: vector < std :: string >> & linkGroups ); void CollectExchangeItemMap ( const std :: string & srcCompId , const ElementInfo & output , const std :: string & tarCompId , const ElementInfo & input ); void CollectIteratorGroups ( const std :: unordered_map < std :: string , std :: vector < std :: string >> & linkGroups , const std :: unordered_map < std :: string , std :: string > & linkModes , const std :: unordered_map < std :: string , std :: unordered_map < std :: string , std :: string >> & linkConfs ); std :: string GenerateUniqueElementId ( const std :: string & compId , const ElementInfo & element ) const ; std :: vector < std :: string > SplitUniqueElementId ( const std :: string & uniqueId ) const ; }; } // namespace OpenOasis::CommImp::IO","title":"File LinkLoader.h"},{"location":"models/_link_loader_8h_source/#file-linkloaderh","text":"File List > CommImp > IO > LinkLoader.h Go to the documentation of this file #pragma once #include \"Models/Utils/JsonHandler.h\" namespace OpenOasis :: CommImp :: IO { using Utils :: JsonLoader ; class LinkLoader { public : // Component information, contains: // - type // - task file path // - dll path using ComponentInfo = std :: array < std :: string , 3 > ; // Element(input/output) information, contains: // - id in component // - object type // - state // - temporal operator // - spatial operator using ElementInfo = std :: array < std :: string , 5 > ; private : std :: string mLinkFile ; JsonLoader mLoader ; std :: unordered_map < std :: string , std :: vector < std :: string >> mOutputConsumers ; std :: unordered_map < std :: string , std :: vector < std :: string >> mInputProviders ; std :: unordered_map < std :: string , ComponentInfo > mComps ; std :: unordered_map < std :: string , std :: vector < ElementInfo >> mInps ; std :: unordered_map < std :: string , std :: vector < ElementInfo >> mOuts ; // Iterator groups, contains: // - iterator group id // - component ids std :: unordered_map < std :: string , std :: vector < std :: string >> mIterGroups ; // Iterator configurations, contains: // - iterator group id // - iterator configurations std :: unordered_map < std :: string , std :: multimap < std :: string , std :: string >> mIterConfigs ; public : LinkLoader ( const std :: string & json ) : mLinkFile ( json ), mLoader ( json ) {} void Load (); std :: vector < std :: string > GetComponentIds () const ; ComponentInfo GetComponentInfo ( const std :: string & compId ) const ; std :: vector < ElementInfo > GetComponentOutputs ( const std :: string & compId ) const ; std :: unordered_map < std :: string , std :: vector < ElementInfo >> GetOutputConsumers ( const std :: string & compId , const ElementInfo & output ) const ; std :: vector < ElementInfo > GetComponentInputs ( const std :: string & compId ) const ; std :: unordered_map < std :: string , std :: vector < ElementInfo >> GetInputProviders ( const std :: string & compId , const ElementInfo & input ) const ; std :: unordered_map < std :: string , std :: vector < std :: string >> GetIteratorGroups () const ; std :: multimap < std :: string , std :: string > GetIteratorConfigs ( const std :: string & iterId ) const ; private : void LoadComponents (); void LoadLinks (); void LoadPipeline ( const std :: string & linkId , const nlohmann :: json & json , int index , std :: unordered_map < std :: string , std :: vector < std :: string >> & linkGroups ); void CollectExchangeItemMap ( const std :: string & srcCompId , const ElementInfo & output , const std :: string & tarCompId , const ElementInfo & input ); void CollectIteratorGroups ( const std :: unordered_map < std :: string , std :: vector < std :: string >> & linkGroups , const std :: unordered_map < std :: string , std :: string > & linkModes , const std :: unordered_map < std :: string , std :: unordered_map < std :: string , std :: string >> & linkConfs ); std :: string GenerateUniqueElementId ( const std :: string & compId , const ElementInfo & element ) const ; std :: vector < std :: string > SplitUniqueElementId ( const std :: string & uniqueId ) const ; }; } // namespace OpenOasis::CommImp::IO","title":"File LinkLoader.h"},{"location":"models/_logger_8cpp/","text":"File Logger.cpp \u00b6 FileList > CommImp > IO > Logger.cpp Go to the source code of this file #include \"Logger.h\" #include <unordered_map> #include <mutex> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace IO The documentation for this class was generated from the following file Models/CommImp/IO/Logger.cpp","title":"File Logger.cpp"},{"location":"models/_logger_8cpp/#file-loggercpp","text":"FileList > CommImp > IO > Logger.cpp Go to the source code of this file #include \"Logger.h\" #include <unordered_map> #include <mutex>","title":"File Logger.cpp"},{"location":"models/_logger_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace IO The documentation for this class was generated from the following file Models/CommImp/IO/Logger.cpp","title":"Namespaces"},{"location":"models/_logger_8cpp_source/","text":"File Logger.cpp \u00b6 File List > CommImp > IO > Logger.cpp Go to the documentation of this file #include \"Logger.h\" #include <unordered_map> #include <mutex> namespace OpenOasis :: CommImp :: IO { using namespace std ; static const string DEFAULT_LOGGER_ID = \"OasisLog\" ; static int DEFAULT_LOGGER_SIZE = 1024 * 1024 * 5 ; static int DEFAULT_FILE_NUM = 9 ; static unordered_map < string , shared_ptr < spdlog :: logger >> OasisLoggers = { { DEFAULT_LOGGER_ID , spdlog :: rotating_logger_mt ( DEFAULT_LOGGER_ID , DEFAULT_LOGGER_ID , DEFAULT_LOGGER_SIZE , DEFAULT_FILE_NUM )}}; static mutex mtx ; shared_ptr < spdlog :: logger > GetLogger ( const string & loggerId ) { unique_lock < mutex > guard ( mtx ); if ( OasisLoggers . find ( loggerId ) != OasisLoggers . end ()) { OasisLoggers [ loggerId ] -> set_level ( spdlog :: level :: warn ); return OasisLoggers [ loggerId ]; } else { auto logger = spdlog :: rotating_logger_mt ( loggerId , loggerId , DEFAULT_LOGGER_SIZE , DEFAULT_FILE_NUM ); logger -> set_level ( spdlog :: level :: warn ); OasisLoggers . insert ( make_pair ( loggerId , logger )); return logger ; } } } // namespace OpenOasis::CommImp::IO","title":"File Logger.cpp"},{"location":"models/_logger_8cpp_source/#file-loggercpp","text":"File List > CommImp > IO > Logger.cpp Go to the documentation of this file #include \"Logger.h\" #include <unordered_map> #include <mutex> namespace OpenOasis :: CommImp :: IO { using namespace std ; static const string DEFAULT_LOGGER_ID = \"OasisLog\" ; static int DEFAULT_LOGGER_SIZE = 1024 * 1024 * 5 ; static int DEFAULT_FILE_NUM = 9 ; static unordered_map < string , shared_ptr < spdlog :: logger >> OasisLoggers = { { DEFAULT_LOGGER_ID , spdlog :: rotating_logger_mt ( DEFAULT_LOGGER_ID , DEFAULT_LOGGER_ID , DEFAULT_LOGGER_SIZE , DEFAULT_FILE_NUM )}}; static mutex mtx ; shared_ptr < spdlog :: logger > GetLogger ( const string & loggerId ) { unique_lock < mutex > guard ( mtx ); if ( OasisLoggers . find ( loggerId ) != OasisLoggers . end ()) { OasisLoggers [ loggerId ] -> set_level ( spdlog :: level :: warn ); return OasisLoggers [ loggerId ]; } else { auto logger = spdlog :: rotating_logger_mt ( loggerId , loggerId , DEFAULT_LOGGER_SIZE , DEFAULT_FILE_NUM ); logger -> set_level ( spdlog :: level :: warn ); OasisLoggers . insert ( make_pair ( loggerId , logger )); return logger ; } } } // namespace OpenOasis::CommImp::IO","title":"File Logger.cpp"},{"location":"models/_logger_8h/","text":"File Logger.h \u00b6 FileList > CommImp > IO > Logger.h Go to the source code of this file #include \"ThirdPart/spdlog/spdlog.h\" #include \"ThirdPart/spdlog/sinks/rotating_file_sink.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace IO The documentation for this class was generated from the following file Models/CommImp/IO/Logger.h","title":"File Logger.h"},{"location":"models/_logger_8h/#file-loggerh","text":"FileList > CommImp > IO > Logger.h Go to the source code of this file #include \"ThirdPart/spdlog/spdlog.h\" #include \"ThirdPart/spdlog/sinks/rotating_file_sink.h\"","title":"File Logger.h"},{"location":"models/_logger_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace IO The documentation for this class was generated from the following file Models/CommImp/IO/Logger.h","title":"Namespaces"},{"location":"models/_logger_8h_source/","text":"File Logger.h \u00b6 File List > CommImp > IO > Logger.h Go to the documentation of this file #pragma once #include \"ThirdPart/spdlog/spdlog.h\" #include \"ThirdPart/spdlog/sinks/rotating_file_sink.h\" namespace OpenOasis { namespace CommImp { namespace IO { std :: shared_ptr < spdlog :: logger > GetLogger ( const std :: string & loggerId = \"OasisLog\" ); } // namespace IO } // namespace CommImp } // namespace OpenOasis","title":"File Logger.h"},{"location":"models/_logger_8h_source/#file-loggerh","text":"File List > CommImp > IO > Logger.h Go to the documentation of this file #pragma once #include \"ThirdPart/spdlog/spdlog.h\" #include \"ThirdPart/spdlog/sinks/rotating_file_sink.h\" namespace OpenOasis { namespace CommImp { namespace IO { std :: shared_ptr < spdlog :: logger > GetLogger ( const std :: string & loggerId = \"OasisLog\" ); } // namespace IO } // namespace CommImp } // namespace OpenOasis","title":"File Logger.h"},{"location":"models/_mesh_loader_8cpp/","text":"File MeshLoader.cpp \u00b6 FileList > CommImp > IO > MeshLoader.cpp Go to the source code of this file #include \"MeshLoader.h\" #include \"Models/Utils/Exception.h\" #include \"Models/Utils/FilePathHelper.h\" #include \"Models/Utils/StringHelper.h\" #include \"Models/Utils/CsvHandler.h\" #include <set> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace IO The documentation for this class was generated from the following file Models/CommImp/IO/MeshLoader.cpp","title":"File MeshLoader.cpp"},{"location":"models/_mesh_loader_8cpp/#file-meshloadercpp","text":"FileList > CommImp > IO > MeshLoader.cpp Go to the source code of this file #include \"MeshLoader.h\" #include \"Models/Utils/Exception.h\" #include \"Models/Utils/FilePathHelper.h\" #include \"Models/Utils/StringHelper.h\" #include \"Models/Utils/CsvHandler.h\" #include <set>","title":"File MeshLoader.cpp"},{"location":"models/_mesh_loader_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace IO The documentation for this class was generated from the following file Models/CommImp/IO/MeshLoader.cpp","title":"Namespaces"},{"location":"models/_mesh_loader_8cpp_source/","text":"File MeshLoader.cpp \u00b6 File List > CommImp > IO > MeshLoader.cpp Go to the documentation of this file #include \"MeshLoader.h\" #include \"Models/Utils/Exception.h\" #include \"Models/Utils/FilePathHelper.h\" #include \"Models/Utils/StringHelper.h\" #include \"Models/Utils/CsvHandler.h\" #include <set> namespace OpenOasis :: CommImp :: IO { using namespace std ; using namespace Utils ; MeshLoader :: MeshLoader ( const string & meshDir ) { if ( ! FilePathHelper :: DirectoryExists ( meshDir )) { throw IllegalArgumentException ( StringHelper :: FormatSimple ( \"Mesh directory [{}] does not exist.\" , meshDir )); } mMeshDir = meshDir ; } void MeshLoader :: Load () { #pragma omp parallel sections { #pragma omp section { LoadNodes (); } #pragma omp section { LoadFaces (); } #pragma omp section { LoadCells (); } #pragma omp section { LoadPatches (); } #pragma omp section { LoadZones (); } } GenerateFaceCoordinates (); GenerateCellCoordinates (); } unordered_map < string , vector < int >> & MeshLoader :: GetPatches () { return mPatchFaces ; } unordered_map < string , vector < int >> & MeshLoader :: GetZones () { return mZoneFaces ; } unordered_map < int , Coordinate > & MeshLoader :: GetNodeCoordinates () { return mNodeCoords ; } unordered_map < int , Coordinate > & MeshLoader :: GetFaceCoordinates () { return mFaceCoords ; } unordered_map < int , Coordinate > & MeshLoader :: GetCellCoordinates () { return mCellCoords ; } unordered_map < int , vector < int >> & MeshLoader :: GetFaceNodes () { return mFaceNodes ; } unordered_map < int , vector < int >> & MeshLoader :: GetCellFaces () { return mCellFaces ; } void MeshLoader :: LoadNodes ( const string & nodeFile ) { const auto & file = FilePathHelper :: Combine ( mMeshDir , nodeFile ); if ( ! FilePathHelper :: FileExists ( file )) return ; CsvLoader loader ( file , true , true ); if ( loader . GetColumnCount () < 3 ) { throw InvalidDataException ( \"Invalid Node data, to few columns.\" ); } auto ids = loader . GetRowLabels (). value (); CheckIds ( ids , \"Node\" ); for ( std :: size_t i = 0 ; i < ids . size (); ++ i ) { auto coor = loader . GetRow < real > ( i ). value (); mNodeCoords [ i ] = { coor [ 0 ], coor [ 1 ], coor [ 2 ]}; } } void MeshLoader :: LoadFaces ( const string & faceFile ) { const auto & file = FilePathHelper :: Combine ( mMeshDir , faceFile ); if ( ! FilePathHelper :: FileExists ( file )) return ; CsvLoader loader ( file , true , true ); if ( loader . GetColumnCount () < 2 ) { throw InvalidDataException ( \"Invalid Face data, to few columns.\" ); } auto ids = loader . GetRowLabels (). value (); CheckIds ( ids , \"Face\" ); for ( std :: size_t i = 0 ; i < ids . size (); ++ i ) { mFaceNodes [ i ] = loader . GetRow < int > ( i ). value (); } } void MeshLoader :: LoadCells ( const string & cellFile ) { const auto & file = FilePathHelper :: Combine ( mMeshDir , cellFile ); if ( ! FilePathHelper :: FileExists ( file )) return ; CsvLoader loader ( file , true , true ); if ( loader . GetColumnCount () < 3 ) { throw InvalidDataException ( \"Invalid Cell data, to few columns.\" ); } auto ids = loader . GetRowLabels (). value (); CheckIds ( ids , \"Cell\" ); for ( std :: size_t i = 0 ; i < ids . size (); ++ i ) { mCellFaces [ i ] = loader . GetRow < int > ( i ). value (); } } void MeshLoader :: LoadPatches ( const string & patchFile ) { const auto & file = FilePathHelper :: Combine ( mMeshDir , patchFile ); if ( ! FilePathHelper :: FileExists ( file )) return ; CsvLoader loader ( file , false , true ); if ( loader . GetColumnCount () < 1 ) { throw InvalidDataException ( \"Invalid Patch data, to few columns.\" ); } auto ids = loader . GetRowLabels (). value (); for ( const auto & id : ids ) { mPatchFaces [ id ] = loader . GetRow < int > ( id ). value (); } } void MeshLoader :: LoadZones ( const string & zoneFile ) { const auto & file = FilePathHelper :: Combine ( mMeshDir , zoneFile ); if ( ! FilePathHelper :: FileExists ( file )) return ; CsvLoader loader ( file , false , true ); if ( loader . GetColumnCount () < 3 ) { throw InvalidDataException ( \"Invalid Zone data, to few columns.\" ); } auto ids = loader . GetRowLabels (). value (); for ( const auto & id : ids ) { mZoneFaces [ id ] = loader . GetRow < int > ( id ). value (); } } void MeshLoader :: CheckIds ( const vector < string > & ids , const string & meta ) { vector < int > ids_int ( ids . size ()); transform ( begin ( ids ), end ( ids ), begin ( ids_int ), []( const auto & id ) { return stoi ( id ); }); if ( ids_int . front () != 0 ) { throw InvalidDataException ( StringHelper :: FormatSimple ( \"Invalid [{}] data, ids don't start from 0.\" , meta )); } if ( ids_int . back () != int ( ids_int . size ()) - 1 ) { throw InvalidDataException ( StringHelper :: FormatSimple ( \"Invalid [{}] data, non-incremental ids.\" , meta )); } } void MeshLoader :: GenerateFaceCoordinates () { for ( const auto & face : mFaceNodes ) { int id = face . first ; real x = 0 , y = 0 , z = 0 ; for ( int nId : face . second ) { x += mNodeCoords [ nId ]. x ; y += mNodeCoords [ nId ]. y ; z += mNodeCoords [ nId ]. z ; } int size = ( int ) face . second . size (); x /= size ; y /= size ; z /= size ; mFaceCoords [ id ] = { x , y , z }; } } void MeshLoader :: GenerateCellCoordinates () { for ( const auto & cell : mCellFaces ) { int id = cell . first ; real x = 0 , y = 0 , z = 0 ; for ( int fId : cell . second ) { x += mFaceCoords [ fId ]. x ; y += mFaceCoords [ fId ]. y ; z += mFaceCoords [ fId ]. z ; } int size = ( int ) cell . second . size (); x /= size ; y /= size ; z /= size ; mCellCoords [ id ] = { x , y , z }; } } } // namespace OpenOasis::CommImp::IO","title":"File MeshLoader.cpp"},{"location":"models/_mesh_loader_8cpp_source/#file-meshloadercpp","text":"File List > CommImp > IO > MeshLoader.cpp Go to the documentation of this file #include \"MeshLoader.h\" #include \"Models/Utils/Exception.h\" #include \"Models/Utils/FilePathHelper.h\" #include \"Models/Utils/StringHelper.h\" #include \"Models/Utils/CsvHandler.h\" #include <set> namespace OpenOasis :: CommImp :: IO { using namespace std ; using namespace Utils ; MeshLoader :: MeshLoader ( const string & meshDir ) { if ( ! FilePathHelper :: DirectoryExists ( meshDir )) { throw IllegalArgumentException ( StringHelper :: FormatSimple ( \"Mesh directory [{}] does not exist.\" , meshDir )); } mMeshDir = meshDir ; } void MeshLoader :: Load () { #pragma omp parallel sections { #pragma omp section { LoadNodes (); } #pragma omp section { LoadFaces (); } #pragma omp section { LoadCells (); } #pragma omp section { LoadPatches (); } #pragma omp section { LoadZones (); } } GenerateFaceCoordinates (); GenerateCellCoordinates (); } unordered_map < string , vector < int >> & MeshLoader :: GetPatches () { return mPatchFaces ; } unordered_map < string , vector < int >> & MeshLoader :: GetZones () { return mZoneFaces ; } unordered_map < int , Coordinate > & MeshLoader :: GetNodeCoordinates () { return mNodeCoords ; } unordered_map < int , Coordinate > & MeshLoader :: GetFaceCoordinates () { return mFaceCoords ; } unordered_map < int , Coordinate > & MeshLoader :: GetCellCoordinates () { return mCellCoords ; } unordered_map < int , vector < int >> & MeshLoader :: GetFaceNodes () { return mFaceNodes ; } unordered_map < int , vector < int >> & MeshLoader :: GetCellFaces () { return mCellFaces ; } void MeshLoader :: LoadNodes ( const string & nodeFile ) { const auto & file = FilePathHelper :: Combine ( mMeshDir , nodeFile ); if ( ! FilePathHelper :: FileExists ( file )) return ; CsvLoader loader ( file , true , true ); if ( loader . GetColumnCount () < 3 ) { throw InvalidDataException ( \"Invalid Node data, to few columns.\" ); } auto ids = loader . GetRowLabels (). value (); CheckIds ( ids , \"Node\" ); for ( std :: size_t i = 0 ; i < ids . size (); ++ i ) { auto coor = loader . GetRow < real > ( i ). value (); mNodeCoords [ i ] = { coor [ 0 ], coor [ 1 ], coor [ 2 ]}; } } void MeshLoader :: LoadFaces ( const string & faceFile ) { const auto & file = FilePathHelper :: Combine ( mMeshDir , faceFile ); if ( ! FilePathHelper :: FileExists ( file )) return ; CsvLoader loader ( file , true , true ); if ( loader . GetColumnCount () < 2 ) { throw InvalidDataException ( \"Invalid Face data, to few columns.\" ); } auto ids = loader . GetRowLabels (). value (); CheckIds ( ids , \"Face\" ); for ( std :: size_t i = 0 ; i < ids . size (); ++ i ) { mFaceNodes [ i ] = loader . GetRow < int > ( i ). value (); } } void MeshLoader :: LoadCells ( const string & cellFile ) { const auto & file = FilePathHelper :: Combine ( mMeshDir , cellFile ); if ( ! FilePathHelper :: FileExists ( file )) return ; CsvLoader loader ( file , true , true ); if ( loader . GetColumnCount () < 3 ) { throw InvalidDataException ( \"Invalid Cell data, to few columns.\" ); } auto ids = loader . GetRowLabels (). value (); CheckIds ( ids , \"Cell\" ); for ( std :: size_t i = 0 ; i < ids . size (); ++ i ) { mCellFaces [ i ] = loader . GetRow < int > ( i ). value (); } } void MeshLoader :: LoadPatches ( const string & patchFile ) { const auto & file = FilePathHelper :: Combine ( mMeshDir , patchFile ); if ( ! FilePathHelper :: FileExists ( file )) return ; CsvLoader loader ( file , false , true ); if ( loader . GetColumnCount () < 1 ) { throw InvalidDataException ( \"Invalid Patch data, to few columns.\" ); } auto ids = loader . GetRowLabels (). value (); for ( const auto & id : ids ) { mPatchFaces [ id ] = loader . GetRow < int > ( id ). value (); } } void MeshLoader :: LoadZones ( const string & zoneFile ) { const auto & file = FilePathHelper :: Combine ( mMeshDir , zoneFile ); if ( ! FilePathHelper :: FileExists ( file )) return ; CsvLoader loader ( file , false , true ); if ( loader . GetColumnCount () < 3 ) { throw InvalidDataException ( \"Invalid Zone data, to few columns.\" ); } auto ids = loader . GetRowLabels (). value (); for ( const auto & id : ids ) { mZoneFaces [ id ] = loader . GetRow < int > ( id ). value (); } } void MeshLoader :: CheckIds ( const vector < string > & ids , const string & meta ) { vector < int > ids_int ( ids . size ()); transform ( begin ( ids ), end ( ids ), begin ( ids_int ), []( const auto & id ) { return stoi ( id ); }); if ( ids_int . front () != 0 ) { throw InvalidDataException ( StringHelper :: FormatSimple ( \"Invalid [{}] data, ids don't start from 0.\" , meta )); } if ( ids_int . back () != int ( ids_int . size ()) - 1 ) { throw InvalidDataException ( StringHelper :: FormatSimple ( \"Invalid [{}] data, non-incremental ids.\" , meta )); } } void MeshLoader :: GenerateFaceCoordinates () { for ( const auto & face : mFaceNodes ) { int id = face . first ; real x = 0 , y = 0 , z = 0 ; for ( int nId : face . second ) { x += mNodeCoords [ nId ]. x ; y += mNodeCoords [ nId ]. y ; z += mNodeCoords [ nId ]. z ; } int size = ( int ) face . second . size (); x /= size ; y /= size ; z /= size ; mFaceCoords [ id ] = { x , y , z }; } } void MeshLoader :: GenerateCellCoordinates () { for ( const auto & cell : mCellFaces ) { int id = cell . first ; real x = 0 , y = 0 , z = 0 ; for ( int fId : cell . second ) { x += mFaceCoords [ fId ]. x ; y += mFaceCoords [ fId ]. y ; z += mFaceCoords [ fId ]. z ; } int size = ( int ) cell . second . size (); x /= size ; y /= size ; z /= size ; mCellCoords [ id ] = { x , y , z }; } } } // namespace OpenOasis::CommImp::IO","title":"File MeshLoader.cpp"},{"location":"models/_mesh_loader_8h/","text":"File MeshLoader.h \u00b6 FileList > CommImp > IO > MeshLoader.h Go to the source code of this file #include \"Models/CommImp/Spatial/Coordinate.h\" #include <string> #include <vector> #include <unordered_map> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace IO Classes \u00b6 Type Name class MeshLoader Default Mesh data loader. The documentation for this class was generated from the following file Models/CommImp/IO/MeshLoader.h","title":"File MeshLoader.h"},{"location":"models/_mesh_loader_8h/#file-meshloaderh","text":"FileList > CommImp > IO > MeshLoader.h Go to the source code of this file #include \"Models/CommImp/Spatial/Coordinate.h\" #include <string> #include <vector> #include <unordered_map>","title":"File MeshLoader.h"},{"location":"models/_mesh_loader_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace IO","title":"Namespaces"},{"location":"models/_mesh_loader_8h/#classes","text":"Type Name class MeshLoader Default Mesh data loader. The documentation for this class was generated from the following file Models/CommImp/IO/MeshLoader.h","title":"Classes"},{"location":"models/_mesh_loader_8h_source/","text":"File MeshLoader.h \u00b6 File List > CommImp > IO > MeshLoader.h Go to the documentation of this file #pragma once #include \"Models/CommImp/Spatial/Coordinate.h\" #include <string> #include <vector> #include <unordered_map> namespace OpenOasis :: CommImp :: IO { using Spatial :: Coordinate ; class MeshLoader { private : std :: string mMeshDir ; std :: unordered_map < std :: string , std :: vector < int >> mPatchFaces ; std :: unordered_map < std :: string , std :: vector < int >> mZoneFaces ; std :: unordered_map < int , Coordinate > mNodeCoords ; std :: unordered_map < int , Coordinate > mFaceCoords ; std :: unordered_map < int , Coordinate > mCellCoords ; std :: unordered_map < int , std :: vector < int >> mFaceNodes ; std :: unordered_map < int , std :: vector < int >> mCellFaces ; public : MeshLoader ( const std :: string & meshDir ); ~ MeshLoader () {} virtual void Load (); virtual std :: unordered_map < std :: string , std :: vector < int >> & GetPatches (); virtual std :: unordered_map < std :: string , std :: vector < int >> & GetZones (); virtual std :: unordered_map < int , Coordinate > & GetNodeCoordinates (); virtual std :: unordered_map < int , Coordinate > & GetFaceCoordinates (); virtual std :: unordered_map < int , Coordinate > & GetCellCoordinates (); virtual std :: unordered_map < int , std :: vector < int >> & GetFaceNodes (); virtual std :: unordered_map < int , std :: vector < int >> & GetCellFaces (); protected : void LoadNodes ( const std :: string & file = \"nodes.csv\" ); void LoadFaces ( const std :: string & file = \"faces.csv\" ); void LoadCells ( const std :: string & file = \"cells.csv\" ); void LoadZones ( const std :: string & file = \"zones.csv\" ); void LoadPatches ( const std :: string & file = \"patches.csv\" ); void CheckIds ( const std :: vector < std :: string > & ids , const std :: string & meta ); void GenerateFaceCoordinates (); void GenerateCellCoordinates (); }; } // namespace OpenOasis::CommImp::IO","title":"File MeshLoader.h"},{"location":"models/_mesh_loader_8h_source/#file-meshloaderh","text":"File List > CommImp > IO > MeshLoader.h Go to the documentation of this file #pragma once #include \"Models/CommImp/Spatial/Coordinate.h\" #include <string> #include <vector> #include <unordered_map> namespace OpenOasis :: CommImp :: IO { using Spatial :: Coordinate ; class MeshLoader { private : std :: string mMeshDir ; std :: unordered_map < std :: string , std :: vector < int >> mPatchFaces ; std :: unordered_map < std :: string , std :: vector < int >> mZoneFaces ; std :: unordered_map < int , Coordinate > mNodeCoords ; std :: unordered_map < int , Coordinate > mFaceCoords ; std :: unordered_map < int , Coordinate > mCellCoords ; std :: unordered_map < int , std :: vector < int >> mFaceNodes ; std :: unordered_map < int , std :: vector < int >> mCellFaces ; public : MeshLoader ( const std :: string & meshDir ); ~ MeshLoader () {} virtual void Load (); virtual std :: unordered_map < std :: string , std :: vector < int >> & GetPatches (); virtual std :: unordered_map < std :: string , std :: vector < int >> & GetZones (); virtual std :: unordered_map < int , Coordinate > & GetNodeCoordinates (); virtual std :: unordered_map < int , Coordinate > & GetFaceCoordinates (); virtual std :: unordered_map < int , Coordinate > & GetCellCoordinates (); virtual std :: unordered_map < int , std :: vector < int >> & GetFaceNodes (); virtual std :: unordered_map < int , std :: vector < int >> & GetCellFaces (); protected : void LoadNodes ( const std :: string & file = \"nodes.csv\" ); void LoadFaces ( const std :: string & file = \"faces.csv\" ); void LoadCells ( const std :: string & file = \"cells.csv\" ); void LoadZones ( const std :: string & file = \"zones.csv\" ); void LoadPatches ( const std :: string & file = \"patches.csv\" ); void CheckIds ( const std :: vector < std :: string > & ids , const std :: string & meta ); void GenerateFaceCoordinates (); void GenerateCellCoordinates (); }; } // namespace OpenOasis::CommImp::IO","title":"File MeshLoader.h"},{"location":"models/_network_loader_8h/","text":"File NetworkLoader.h \u00b6 FileList > CommImp > IO > NetworkLoader.h Go to the source code of this file Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace IO The documentation for this class was generated from the following file Models/CommImp/IO/NetworkLoader.h","title":"File NetworkLoader.h"},{"location":"models/_network_loader_8h/#file-networkloaderh","text":"FileList > CommImp > IO > NetworkLoader.h Go to the source code of this file","title":"File NetworkLoader.h"},{"location":"models/_network_loader_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace IO The documentation for this class was generated from the following file Models/CommImp/IO/NetworkLoader.h","title":"Namespaces"},{"location":"models/_network_loader_8h_source/","text":"File NetworkLoader.h \u00b6 File List > CommImp > IO > NetworkLoader.h Go to the documentation of this file #pragma once namespace OpenOasis :: CommImp :: IO {}","title":"File NetworkLoader.h"},{"location":"models/_network_loader_8h_source/#file-networkloaderh","text":"File List > CommImp > IO > NetworkLoader.h Go to the documentation of this file #pragma once namespace OpenOasis :: CommImp :: IO {}","title":"File NetworkLoader.h"},{"location":"models/_output_csv_8h/","text":"File OutputCsv.h \u00b6 FileList > CommImp > IO > OutputCsv.h Go to the source code of this file #include \"Models/Utils/CsvHandler.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace IO The documentation for this class was generated from the following file Models/CommImp/IO/OutputCsv.h","title":"File OutputCsv.h"},{"location":"models/_output_csv_8h/#file-outputcsvh","text":"FileList > CommImp > IO > OutputCsv.h Go to the source code of this file #include \"Models/Utils/CsvHandler.h\"","title":"File OutputCsv.h"},{"location":"models/_output_csv_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace IO The documentation for this class was generated from the following file Models/CommImp/IO/OutputCsv.h","title":"Namespaces"},{"location":"models/_output_csv_8h_source/","text":"File OutputCsv.h \u00b6 File List > CommImp > IO > OutputCsv.h Go to the documentation of this file #pragma once #include \"Models/Utils/CsvHandler.h\" namespace OpenOasis :: CommImp :: IO { using Utils :: CsvWriter ; } // namespace OpenOasis::CommImp::IO","title":"File OutputCsv.h"},{"location":"models/_output_csv_8h_source/#file-outputcsvh","text":"File List > CommImp > IO > OutputCsv.h Go to the documentation of this file #pragma once #include \"Models/Utils/CsvHandler.h\" namespace OpenOasis :: CommImp :: IO { using Utils :: CsvWriter ; } // namespace OpenOasis::CommImp::IO","title":"File OutputCsv.h"},{"location":"models/_task_loader_8h/","text":"File TaskLoader.h \u00b6 FileList > CommImp > IO > TaskLoader.h Go to the source code of this file #include \"Models/Utils/YamlHandler.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace IO Classes \u00b6 Type Name class TaskLoader Loading components task configurations yaml file. The documentation for this class was generated from the following file Models/CommImp/IO/TaskLoader.h","title":"File TaskLoader.h"},{"location":"models/_task_loader_8h/#file-taskloaderh","text":"FileList > CommImp > IO > TaskLoader.h Go to the source code of this file #include \"Models/Utils/YamlHandler.h\"","title":"File TaskLoader.h"},{"location":"models/_task_loader_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace IO","title":"Namespaces"},{"location":"models/_task_loader_8h/#classes","text":"Type Name class TaskLoader Loading components task configurations yaml file. The documentation for this class was generated from the following file Models/CommImp/IO/TaskLoader.h","title":"Classes"},{"location":"models/_task_loader_8h_source/","text":"File TaskLoader.h \u00b6 File List > CommImp > IO > TaskLoader.h Go to the documentation of this file #pragma once #include \"Models/Utils/YamlHandler.h\" namespace OpenOasis :: CommImp :: IO { using Utils :: YamlLoader ; class TaskLoader {}; } // namespace OpenOasis::CommImp::IO","title":"File TaskLoader.h"},{"location":"models/_task_loader_8h_source/#file-taskloaderh","text":"File List > CommImp > IO > TaskLoader.h Go to the documentation of this file #pragma once #include \"Models/Utils/YamlHandler.h\" namespace OpenOasis :: CommImp :: IO { using Utils :: YamlLoader ; class TaskLoader {}; } // namespace OpenOasis::CommImp::IO","title":"File TaskLoader.h"},{"location":"models/dir_a0ece07902893bffce0f747cc8ee06c8/","text":"Dir Models/CommImp/Numeric \u00b6 FileList > CommImp > Numeric Files \u00b6 Type Name file Boundary.h file CurlOperator.h file DdtOperator.h file DirichletBoundary.cpp file DirichletBoundary.h file DivOperator.h file Field.h file GradOperator.h file Interps.cpp file Interps.h file LaplacianOperator.cpp file LaplacianOperator.h file Matrix.cpp file Matrix.h file NeumannBoundary.h file NumericMethods.h file Operator.h file RobinBoundary.h file ScalarField.h file Solver.h file Source.h file Tensor.h file TensorField.h file Vector.h file VectorField.h Directories \u00b6 Type Name dir FVM The documentation for this class was generated from the following file Models/CommImp/Numeric/","title":"Dir Models/CommImp/Numeric"},{"location":"models/dir_a0ece07902893bffce0f747cc8ee06c8/#dir-modelscommimpnumeric","text":"FileList > CommImp > Numeric","title":"Dir Models/CommImp/Numeric"},{"location":"models/dir_a0ece07902893bffce0f747cc8ee06c8/#files","text":"Type Name file Boundary.h file CurlOperator.h file DdtOperator.h file DirichletBoundary.cpp file DirichletBoundary.h file DivOperator.h file Field.h file GradOperator.h file Interps.cpp file Interps.h file LaplacianOperator.cpp file LaplacianOperator.h file Matrix.cpp file Matrix.h file NeumannBoundary.h file NumericMethods.h file Operator.h file RobinBoundary.h file ScalarField.h file Solver.h file Source.h file Tensor.h file TensorField.h file Vector.h file VectorField.h","title":"Files"},{"location":"models/dir_a0ece07902893bffce0f747cc8ee06c8/#directories","text":"Type Name dir FVM The documentation for this class was generated from the following file Models/CommImp/Numeric/","title":"Directories"},{"location":"models/_boundary_8h/","text":"File Boundary.h \u00b6 FileList > CommImp > Numeric > Boundary.h Go to the source code of this file #include \"Models/Utils/CommConstants.h\" #include <string> #include <cmath> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric Classes \u00b6 Type Name class Boundary Abstract boundary class. struct BoundaryCondition Boundary condition struct. The documentation for this class was generated from the following file Models/CommImp/Numeric/Boundary.h","title":"File Boundary.h"},{"location":"models/_boundary_8h/#file-boundaryh","text":"FileList > CommImp > Numeric > Boundary.h Go to the source code of this file #include \"Models/Utils/CommConstants.h\" #include <string> #include <cmath>","title":"File Boundary.h"},{"location":"models/_boundary_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric","title":"Namespaces"},{"location":"models/_boundary_8h/#classes","text":"Type Name class Boundary Abstract boundary class. struct BoundaryCondition Boundary condition struct. The documentation for this class was generated from the following file Models/CommImp/Numeric/Boundary.h","title":"Classes"},{"location":"models/_boundary_8h_source/","text":"File Boundary.h \u00b6 File List > CommImp > Numeric > Boundary.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommConstants.h\" #include <string> #include <cmath> namespace OpenOasis :: CommImp :: Numeric { using Utils :: real ; struct BoundaryCondition { std :: string type ; real value = NAN ; real flux = NAN ; }; class Boundary { public : virtual void SetBoundaryValue ( real value ) = 0 ; virtual void SetBoundaryFlux ( real flux ) = 0 ; virtual std :: string GetType () const = 0 ; virtual BoundaryCondition GetBoundaryCondition () = 0 ; }; } // namespace OpenOasis::CommImp::Numeric","title":"File Boundary.h"},{"location":"models/_boundary_8h_source/#file-boundaryh","text":"File List > CommImp > Numeric > Boundary.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommConstants.h\" #include <string> #include <cmath> namespace OpenOasis :: CommImp :: Numeric { using Utils :: real ; struct BoundaryCondition { std :: string type ; real value = NAN ; real flux = NAN ; }; class Boundary { public : virtual void SetBoundaryValue ( real value ) = 0 ; virtual void SetBoundaryFlux ( real flux ) = 0 ; virtual std :: string GetType () const = 0 ; virtual BoundaryCondition GetBoundaryCondition () = 0 ; }; } // namespace OpenOasis::CommImp::Numeric","title":"File Boundary.h"},{"location":"models/_curl_operator_8h/","text":"File CurlOperator.h \u00b6 FileList > CommImp > Numeric > CurlOperator.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/CurlOperator.h","title":"File CurlOperator.h"},{"location":"models/_curl_operator_8h/#file-curloperatorh","text":"FileList > CommImp > Numeric > CurlOperator.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/CurlOperator.h","title":"File CurlOperator.h"},{"location":"models/_curl_operator_8h_source/","text":"File CurlOperator.h \u00b6 File List > CommImp > Numeric > CurlOperator.h Go to the documentation of this file","title":"File CurlOperator.h"},{"location":"models/_curl_operator_8h_source/#file-curloperatorh","text":"File List > CommImp > Numeric > CurlOperator.h Go to the documentation of this file","title":"File CurlOperator.h"},{"location":"models/_ddt_operator_8h/","text":"File DdtOperator.h \u00b6 FileList > CommImp > Numeric > DdtOperator.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/DdtOperator.h","title":"File DdtOperator.h"},{"location":"models/_ddt_operator_8h/#file-ddtoperatorh","text":"FileList > CommImp > Numeric > DdtOperator.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/DdtOperator.h","title":"File DdtOperator.h"},{"location":"models/_ddt_operator_8h_source/","text":"File DdtOperator.h \u00b6 File List > CommImp > Numeric > DdtOperator.h Go to the documentation of this file","title":"File DdtOperator.h"},{"location":"models/_ddt_operator_8h_source/#file-ddtoperatorh","text":"File List > CommImp > Numeric > DdtOperator.h Go to the documentation of this file","title":"File DdtOperator.h"},{"location":"models/_dirichlet_boundary_8cpp/","text":"File DirichletBoundary.cpp \u00b6 FileList > CommImp > Numeric > DirichletBoundary.cpp Go to the source code of this file #include \"DirichletBoundary.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric The documentation for this class was generated from the following file Models/CommImp/Numeric/DirichletBoundary.cpp","title":"File DirichletBoundary.cpp"},{"location":"models/_dirichlet_boundary_8cpp/#file-dirichletboundarycpp","text":"FileList > CommImp > Numeric > DirichletBoundary.cpp Go to the source code of this file #include \"DirichletBoundary.h\"","title":"File DirichletBoundary.cpp"},{"location":"models/_dirichlet_boundary_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric The documentation for this class was generated from the following file Models/CommImp/Numeric/DirichletBoundary.cpp","title":"Namespaces"},{"location":"models/_dirichlet_boundary_8cpp_source/","text":"File DirichletBoundary.cpp \u00b6 File List > CommImp > Numeric > DirichletBoundary.cpp Go to the documentation of this file #include \"DirichletBoundary.h\" namespace OpenOasis :: CommImp :: Numeric { using namespace std ; using namespace Utils ; DirichletBoundary :: DirichletBoundary () { mData . type = \"DIRICHLET\" ; } DirichletBoundary :: DirichletBoundary ( real value ) { mData = { \"DIRICHLET\" , value }; } DirichletBoundary :: DirichletBoundary ( const DirichletBoundary & other ) { mData = other . mData ; } void DirichletBoundary :: SetBoundaryValue ( real value ) { mData . value = value ; } void DirichletBoundary :: SetBoundaryFlux ( real flux ) { mData . flux = flux ; } string DirichletBoundary :: GetType () const { return \"Dirichlet\" ; } BoundaryCondition DirichletBoundary :: GetBoundaryCondition () { return mData ; } } // namespace OpenOasis::CommImp::Numeric","title":"File DirichletBoundary.cpp"},{"location":"models/_dirichlet_boundary_8cpp_source/#file-dirichletboundarycpp","text":"File List > CommImp > Numeric > DirichletBoundary.cpp Go to the documentation of this file #include \"DirichletBoundary.h\" namespace OpenOasis :: CommImp :: Numeric { using namespace std ; using namespace Utils ; DirichletBoundary :: DirichletBoundary () { mData . type = \"DIRICHLET\" ; } DirichletBoundary :: DirichletBoundary ( real value ) { mData = { \"DIRICHLET\" , value }; } DirichletBoundary :: DirichletBoundary ( const DirichletBoundary & other ) { mData = other . mData ; } void DirichletBoundary :: SetBoundaryValue ( real value ) { mData . value = value ; } void DirichletBoundary :: SetBoundaryFlux ( real flux ) { mData . flux = flux ; } string DirichletBoundary :: GetType () const { return \"Dirichlet\" ; } BoundaryCondition DirichletBoundary :: GetBoundaryCondition () { return mData ; } } // namespace OpenOasis::CommImp::Numeric","title":"File DirichletBoundary.cpp"},{"location":"models/_dirichlet_boundary_8h/","text":"File DirichletBoundary.h \u00b6 FileList > CommImp > Numeric > DirichletBoundary.h Go to the source code of this file #include \"Boundary.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric Classes \u00b6 Type Name class DirichletBoundary Dirichlet boundary. The documentation for this class was generated from the following file Models/CommImp/Numeric/DirichletBoundary.h","title":"File DirichletBoundary.h"},{"location":"models/_dirichlet_boundary_8h/#file-dirichletboundaryh","text":"FileList > CommImp > Numeric > DirichletBoundary.h Go to the source code of this file #include \"Boundary.h\"","title":"File DirichletBoundary.h"},{"location":"models/_dirichlet_boundary_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric","title":"Namespaces"},{"location":"models/_dirichlet_boundary_8h/#classes","text":"Type Name class DirichletBoundary Dirichlet boundary. The documentation for this class was generated from the following file Models/CommImp/Numeric/DirichletBoundary.h","title":"Classes"},{"location":"models/_dirichlet_boundary_8h_source/","text":"File DirichletBoundary.h \u00b6 File List > CommImp > Numeric > DirichletBoundary.h Go to the documentation of this file #pragma once #include \"Boundary.h\" namespace OpenOasis :: CommImp :: Numeric { using Utils :: real ; class DirichletBoundary : public Boundary { private : BoundaryCondition mData ; public : DirichletBoundary (); DirichletBoundary ( real value ); DirichletBoundary ( const DirichletBoundary & other ); void SetBoundaryValue ( real value ) override ; void SetBoundaryFlux ( real flux ) override ; std :: string GetType () const override ; BoundaryCondition GetBoundaryCondition () override ; }; } // namespace OpenOasis::CommImp::Numeric","title":"File DirichletBoundary.h"},{"location":"models/_dirichlet_boundary_8h_source/#file-dirichletboundaryh","text":"File List > CommImp > Numeric > DirichletBoundary.h Go to the documentation of this file #pragma once #include \"Boundary.h\" namespace OpenOasis :: CommImp :: Numeric { using Utils :: real ; class DirichletBoundary : public Boundary { private : BoundaryCondition mData ; public : DirichletBoundary (); DirichletBoundary ( real value ); DirichletBoundary ( const DirichletBoundary & other ); void SetBoundaryValue ( real value ) override ; void SetBoundaryFlux ( real flux ) override ; std :: string GetType () const override ; BoundaryCondition GetBoundaryCondition () override ; }; } // namespace OpenOasis::CommImp::Numeric","title":"File DirichletBoundary.h"},{"location":"models/_div_operator_8h/","text":"File DivOperator.h \u00b6 FileList > CommImp > Numeric > DivOperator.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/DivOperator.h","title":"File DivOperator.h"},{"location":"models/_div_operator_8h/#file-divoperatorh","text":"FileList > CommImp > Numeric > DivOperator.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/DivOperator.h","title":"File DivOperator.h"},{"location":"models/_div_operator_8h_source/","text":"File DivOperator.h \u00b6 File List > CommImp > Numeric > DivOperator.h Go to the documentation of this file","title":"File DivOperator.h"},{"location":"models/_div_operator_8h_source/#file-divoperatorh","text":"File List > CommImp > Numeric > DivOperator.h Go to the documentation of this file","title":"File DivOperator.h"},{"location":"models/_field_8h/","text":"File Field.h \u00b6 FileList > CommImp > Numeric > Field.h Go to the source code of this file #include \"Models/Utils/CommMacros.h\" #include <vector> #include <algorithm> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric Classes \u00b6 Type Name class Field <typename T> The abstract field class used to represent numeric field, such as scalar, vector or tensor data. The documentation for this class was generated from the following file Models/CommImp/Numeric/Field.h","title":"File Field.h"},{"location":"models/_field_8h/#file-fieldh","text":"FileList > CommImp > Numeric > Field.h Go to the source code of this file #include \"Models/Utils/CommMacros.h\" #include <vector> #include <algorithm>","title":"File Field.h"},{"location":"models/_field_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric","title":"Namespaces"},{"location":"models/_field_8h/#classes","text":"Type Name class Field <typename T> The abstract field class used to represent numeric field, such as scalar, vector or tensor data. The documentation for this class was generated from the following file Models/CommImp/Numeric/Field.h","title":"Classes"},{"location":"models/_field_8h_source/","text":"File Field.h \u00b6 File List > CommImp > Numeric > Field.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommMacros.h\" #include <vector> #include <algorithm> namespace OpenOasis :: CommImp :: Numeric { enum class FieldType { NONE , SCALAR , VECTOR , TENSOR }; enum class FieldDomain { NONE , NODE , FACE , CELL }; template < typename T > class Field { protected : FieldDomain mDomain = FieldDomain :: NONE ; FieldType mType = FieldType :: NONE ; std :: vector < T > mData ; T mDefault ; protected : virtual ~ Field () = default ; Field () = default ; Field ( std :: size_t size , T value ) : mData ( size , value ){}; public : // Methods for field manipulation. // void Initialize ( T value ) { std :: fill ( mData . begin (), mData . end (), value ); } void Resize ( std :: size_t size ) { mData . resize ( size ); mData . shrink_to_fit (); } void Clean () { std :: fill ( mData . begin (), mData . end (), mDefault ); } void Clear () { mData . clear (); } template < typename Callback > void ForEach ( Callback func ) { for ( auto & elem : mData ) { func ( elem ); } } std :: size_t Size () const { return mData . size (); } void SetAt ( std :: size_t i , T value ) { mData . at ( i ) = value ; } void SetAt ( std :: size_t startIndex , std :: size_t endIndex , const Field < T > & other , std :: size_t offset = 0 ) { std :: size_t j = offset ; for ( std :: size_t i = startIndex ; i < endIndex ; ++ i ) mData . at ( i ) = other ( j ++ ); } const std :: vector < T > & Data () const { return mData ; } FieldType Type () const { return mType ; } FieldDomain Range () const { return mDomain ; } // Operators overrided for field manipulation. // const T & operator ()( int i ) const { return mData . at ( i ); } T & operator ()( int i ) { return mData . at ( i ); } void operator = ( const Field < T > & other ) { mData = other . mData ; } void operator = ( const T & value ) { Initialize ( value ); } Field < T > operator + ( const Field < T > & other ) const { OO_ASSERT ( other . Size () == Size ()); auto datas = mData ; for ( int i = 0 ; i < Size (); ++ i ) { datas [ i ] += other ( i ); } return datas ; } void operator += ( const Field < T > & other ) { OO_ASSERT ( other . Size () == Size ()); for ( int i = 0 ; i < Size (); ++ i ) mData [ i ] += other ( i ); } Field < T > operator - ( const Field < T > & other ) const { OO_ASSERT ( other . Size () == Size ()); auto datas = mData ; for ( int i = 0 ; i < Size (); ++ i ) { datas [ i ] -= other ( i ); } return datas ; } void operator -= ( const Field < T > & other ) { OO_ASSERT ( other . Size () == Size ()); for ( int i = 0 ; i < Size (); ++ i ) mData [ i ] -= other ( i ); } Field < T > operator * ( double k ) const { auto datas = mData ; std :: for_each ( datas . begin (), datas . end (), [ & k ]( auto & d ) { d *= k ; }); return datas ; } void operator *= ( double k ) { std :: for_each ( mData . begin (), mData . end (), [ & k ]( auto & d ) { d *= k ; }); } }; } // namespace OpenOasis::CommImp::Numeric","title":"File Field.h"},{"location":"models/_field_8h_source/#file-fieldh","text":"File List > CommImp > Numeric > Field.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommMacros.h\" #include <vector> #include <algorithm> namespace OpenOasis :: CommImp :: Numeric { enum class FieldType { NONE , SCALAR , VECTOR , TENSOR }; enum class FieldDomain { NONE , NODE , FACE , CELL }; template < typename T > class Field { protected : FieldDomain mDomain = FieldDomain :: NONE ; FieldType mType = FieldType :: NONE ; std :: vector < T > mData ; T mDefault ; protected : virtual ~ Field () = default ; Field () = default ; Field ( std :: size_t size , T value ) : mData ( size , value ){}; public : // Methods for field manipulation. // void Initialize ( T value ) { std :: fill ( mData . begin (), mData . end (), value ); } void Resize ( std :: size_t size ) { mData . resize ( size ); mData . shrink_to_fit (); } void Clean () { std :: fill ( mData . begin (), mData . end (), mDefault ); } void Clear () { mData . clear (); } template < typename Callback > void ForEach ( Callback func ) { for ( auto & elem : mData ) { func ( elem ); } } std :: size_t Size () const { return mData . size (); } void SetAt ( std :: size_t i , T value ) { mData . at ( i ) = value ; } void SetAt ( std :: size_t startIndex , std :: size_t endIndex , const Field < T > & other , std :: size_t offset = 0 ) { std :: size_t j = offset ; for ( std :: size_t i = startIndex ; i < endIndex ; ++ i ) mData . at ( i ) = other ( j ++ ); } const std :: vector < T > & Data () const { return mData ; } FieldType Type () const { return mType ; } FieldDomain Range () const { return mDomain ; } // Operators overrided for field manipulation. // const T & operator ()( int i ) const { return mData . at ( i ); } T & operator ()( int i ) { return mData . at ( i ); } void operator = ( const Field < T > & other ) { mData = other . mData ; } void operator = ( const T & value ) { Initialize ( value ); } Field < T > operator + ( const Field < T > & other ) const { OO_ASSERT ( other . Size () == Size ()); auto datas = mData ; for ( int i = 0 ; i < Size (); ++ i ) { datas [ i ] += other ( i ); } return datas ; } void operator += ( const Field < T > & other ) { OO_ASSERT ( other . Size () == Size ()); for ( int i = 0 ; i < Size (); ++ i ) mData [ i ] += other ( i ); } Field < T > operator - ( const Field < T > & other ) const { OO_ASSERT ( other . Size () == Size ()); auto datas = mData ; for ( int i = 0 ; i < Size (); ++ i ) { datas [ i ] -= other ( i ); } return datas ; } void operator -= ( const Field < T > & other ) { OO_ASSERT ( other . Size () == Size ()); for ( int i = 0 ; i < Size (); ++ i ) mData [ i ] -= other ( i ); } Field < T > operator * ( double k ) const { auto datas = mData ; std :: for_each ( datas . begin (), datas . end (), [ & k ]( auto & d ) { d *= k ; }); return datas ; } void operator *= ( double k ) { std :: for_each ( mData . begin (), mData . end (), [ & k ]( auto & d ) { d *= k ; }); } }; } // namespace OpenOasis::CommImp::Numeric","title":"File Field.h"},{"location":"models/_grad_operator_8h/","text":"File GradOperator.h \u00b6 FileList > CommImp > Numeric > GradOperator.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/GradOperator.h","title":"File GradOperator.h"},{"location":"models/_grad_operator_8h/#file-gradoperatorh","text":"FileList > CommImp > Numeric > GradOperator.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/GradOperator.h","title":"File GradOperator.h"},{"location":"models/_grad_operator_8h_source/","text":"File GradOperator.h \u00b6 File List > CommImp > Numeric > GradOperator.h Go to the documentation of this file","title":"File GradOperator.h"},{"location":"models/_grad_operator_8h_source/#file-gradoperatorh","text":"File List > CommImp > Numeric > GradOperator.h Go to the documentation of this file","title":"File GradOperator.h"},{"location":"models/_interps_8cpp/","text":"File Interps.cpp \u00b6 FileList > CommImp > Numeric > Interps.cpp Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/Interps.cpp","title":"File Interps.cpp"},{"location":"models/_interps_8cpp/#file-interpscpp","text":"FileList > CommImp > Numeric > Interps.cpp Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/Interps.cpp","title":"File Interps.cpp"},{"location":"models/_interps_8cpp_source/","text":"File Interps.cpp \u00b6 File List > CommImp > Numeric > Interps.cpp Go to the documentation of this file","title":"File Interps.cpp"},{"location":"models/_interps_8cpp_source/#file-interpscpp","text":"File List > CommImp > Numeric > Interps.cpp Go to the documentation of this file","title":"File Interps.cpp"},{"location":"models/_interps_8h/","text":"File Interps.h \u00b6 FileList > CommImp > Numeric > Interps.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/Interps.h","title":"File Interps.h"},{"location":"models/_interps_8h/#file-interpsh","text":"FileList > CommImp > Numeric > Interps.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/Interps.h","title":"File Interps.h"},{"location":"models/_interps_8h_source/","text":"File Interps.h \u00b6 File List > CommImp > Numeric > Interps.h Go to the documentation of this file","title":"File Interps.h"},{"location":"models/_interps_8h_source/#file-interpsh","text":"File List > CommImp > Numeric > Interps.h Go to the documentation of this file","title":"File Interps.h"},{"location":"models/_laplacian_operator_8cpp/","text":"File LaplacianOperator.cpp \u00b6 FileList > CommImp > Numeric > LaplacianOperator.cpp Go to the source code of this file #include \"LaplacianOperator.h\" #include \"Models/Utils/Exception.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric The documentation for this class was generated from the following file Models/CommImp/Numeric/LaplacianOperator.cpp","title":"File LaplacianOperator.cpp"},{"location":"models/_laplacian_operator_8cpp/#file-laplacianoperatorcpp","text":"FileList > CommImp > Numeric > LaplacianOperator.cpp Go to the source code of this file #include \"LaplacianOperator.h\" #include \"Models/Utils/Exception.h\"","title":"File LaplacianOperator.cpp"},{"location":"models/_laplacian_operator_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric The documentation for this class was generated from the following file Models/CommImp/Numeric/LaplacianOperator.cpp","title":"Namespaces"},{"location":"models/_laplacian_operator_8cpp_source/","text":"File LaplacianOperator.cpp \u00b6 File List > CommImp > Numeric > LaplacianOperator.cpp Go to the documentation of this file #include \"LaplacianOperator.h\" #include \"Models/Utils/Exception.h\" namespace OpenOasis :: CommImp :: Numeric { using namespace std ; using namespace Utils ; LinearEqs Laplacian::Discretize ( const ScalarField < real > & phiCellField , const ScalarField < real > & phiFaceField ) { int nCells = mGrid -> GetNumCells (); int nFaces = mGrid -> GetNumFaces (); OO_ASSERT ( nCells == phiCellField . Size ()); Matrix < real > coeffs ( nCells ); vector < real > rhs ( nCells ); for ( int i = 0 ; i < mGrid -> GetNumCells (); ++ i ) { const auto & cell = mGrid -> GetCell ( i ); real coeff = 0 ; if ( mCoefficient ) { coeff = get < 0 > ( mCoefficient . value ()); } else if ( mScalarCoeffs ) { coeff = mScalarCoeffs . value ()( i ); } else { throw InvalidDataException ( \"Invalid test coefficients\" ); } for ( int j : cell . faceIndexes ) { const auto & face = mGrid -> GetFace ( j ); if ( face . cellIndexes . size () != 2 ) { if ( mboundaries . count ( j ) == 0 || mboundaries [ j ]. type != \"DIRICHLET\" ) { throw invalid_argument ( \"Invalid boundary face.\" ); } real boundValue = mboundaries [ j ]. value ; real distC2b = mGrid -> GetBoundaryCenterDistance ( i , j ); real areaEb = face . area ; real matCoeff = - coeff * areaEb / distC2b ; real src1 = - matCoeff * boundValue ; real src2 = 0 ; coeffs . Add ( i , i , matCoeff ); rhs [ i ] += src2 - src1 ; } else { int cIdx = ( face . cellIndexes [ 0 ] == i ) ? face . cellIndexes [ 1 ] : face . cellIndexes [ 0 ]; real distC2F = mGrid -> GetCellCenterDistance ( i , cIdx ); real areaEb = face . area ; real matCoeff = - coeff * areaEb / distC2F ; coeffs . Add ( i , i , matCoeff ); coeffs . Add ( i , cIdx , - matCoeff ); real src1 = 0 ; real src2 = 0 ; rhs [ i ] += src1 + src2 ; } } } return LinearEqs ( coeffs , rhs ); } } // namespace OpenOasis::CommImp::Numeric","title":"File LaplacianOperator.cpp"},{"location":"models/_laplacian_operator_8cpp_source/#file-laplacianoperatorcpp","text":"File List > CommImp > Numeric > LaplacianOperator.cpp Go to the documentation of this file #include \"LaplacianOperator.h\" #include \"Models/Utils/Exception.h\" namespace OpenOasis :: CommImp :: Numeric { using namespace std ; using namespace Utils ; LinearEqs Laplacian::Discretize ( const ScalarField < real > & phiCellField , const ScalarField < real > & phiFaceField ) { int nCells = mGrid -> GetNumCells (); int nFaces = mGrid -> GetNumFaces (); OO_ASSERT ( nCells == phiCellField . Size ()); Matrix < real > coeffs ( nCells ); vector < real > rhs ( nCells ); for ( int i = 0 ; i < mGrid -> GetNumCells (); ++ i ) { const auto & cell = mGrid -> GetCell ( i ); real coeff = 0 ; if ( mCoefficient ) { coeff = get < 0 > ( mCoefficient . value ()); } else if ( mScalarCoeffs ) { coeff = mScalarCoeffs . value ()( i ); } else { throw InvalidDataException ( \"Invalid test coefficients\" ); } for ( int j : cell . faceIndexes ) { const auto & face = mGrid -> GetFace ( j ); if ( face . cellIndexes . size () != 2 ) { if ( mboundaries . count ( j ) == 0 || mboundaries [ j ]. type != \"DIRICHLET\" ) { throw invalid_argument ( \"Invalid boundary face.\" ); } real boundValue = mboundaries [ j ]. value ; real distC2b = mGrid -> GetBoundaryCenterDistance ( i , j ); real areaEb = face . area ; real matCoeff = - coeff * areaEb / distC2b ; real src1 = - matCoeff * boundValue ; real src2 = 0 ; coeffs . Add ( i , i , matCoeff ); rhs [ i ] += src2 - src1 ; } else { int cIdx = ( face . cellIndexes [ 0 ] == i ) ? face . cellIndexes [ 1 ] : face . cellIndexes [ 0 ]; real distC2F = mGrid -> GetCellCenterDistance ( i , cIdx ); real areaEb = face . area ; real matCoeff = - coeff * areaEb / distC2F ; coeffs . Add ( i , i , matCoeff ); coeffs . Add ( i , cIdx , - matCoeff ); real src1 = 0 ; real src2 = 0 ; rhs [ i ] += src1 + src2 ; } } } return LinearEqs ( coeffs , rhs ); } } // namespace OpenOasis::CommImp::Numeric","title":"File LaplacianOperator.cpp"},{"location":"models/_laplacian_operator_8h/","text":"File LaplacianOperator.h \u00b6 FileList > CommImp > Numeric > LaplacianOperator.h Go to the source code of this file #include \"Models/CommImp/Spatial/Grid.h\" #include \"Operator.h\" #include <functional> #include <memory> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric Classes \u00b6 Type Name class Laplacian Laplacian operator for the divergence of the gradient of a scalar field. The documentation for this class was generated from the following file Models/CommImp/Numeric/LaplacianOperator.h","title":"File LaplacianOperator.h"},{"location":"models/_laplacian_operator_8h/#file-laplacianoperatorh","text":"FileList > CommImp > Numeric > LaplacianOperator.h Go to the source code of this file #include \"Models/CommImp/Spatial/Grid.h\" #include \"Operator.h\" #include <functional> #include <memory>","title":"File LaplacianOperator.h"},{"location":"models/_laplacian_operator_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric","title":"Namespaces"},{"location":"models/_laplacian_operator_8h/#classes","text":"Type Name class Laplacian Laplacian operator for the divergence of the gradient of a scalar field. The documentation for this class was generated from the following file Models/CommImp/Numeric/LaplacianOperator.h","title":"Classes"},{"location":"models/_laplacian_operator_8h_source/","text":"File LaplacianOperator.h \u00b6 File List > CommImp > Numeric > LaplacianOperator.h Go to the documentation of this file #pragma once #include \"Models/CommImp/Spatial/Grid.h\" #include \"Operator.h\" #include <functional> #include <memory> namespace OpenOasis :: CommImp :: Numeric { using Spatial :: Grid ; using Utils :: real ; class Laplacian : public Operator { private : std :: shared_ptr < Grid > mGrid ; public : virtual ~ Laplacian () = default ; Laplacian ( const std :: shared_ptr < Grid > & grid ) : mGrid ( grid ) {} // Laplacian( // const std::shared_ptr<Grid> &grid, // const std::function<void(void)> &innerFluxFunc, // const std::function<void(void)> &boundFluxFunc); LinearEqs Discretize ( const ScalarField < real > & phiCellField , const ScalarField < real > & phiFaceField ) override ; }; } // namespace OpenOasis::CommImp::Numeric","title":"File LaplacianOperator.h"},{"location":"models/_laplacian_operator_8h_source/#file-laplacianoperatorh","text":"File List > CommImp > Numeric > LaplacianOperator.h Go to the documentation of this file #pragma once #include \"Models/CommImp/Spatial/Grid.h\" #include \"Operator.h\" #include <functional> #include <memory> namespace OpenOasis :: CommImp :: Numeric { using Spatial :: Grid ; using Utils :: real ; class Laplacian : public Operator { private : std :: shared_ptr < Grid > mGrid ; public : virtual ~ Laplacian () = default ; Laplacian ( const std :: shared_ptr < Grid > & grid ) : mGrid ( grid ) {} // Laplacian( // const std::shared_ptr<Grid> &grid, // const std::function<void(void)> &innerFluxFunc, // const std::function<void(void)> &boundFluxFunc); LinearEqs Discretize ( const ScalarField < real > & phiCellField , const ScalarField < real > & phiFaceField ) override ; }; } // namespace OpenOasis::CommImp::Numeric","title":"File LaplacianOperator.h"},{"location":"models/_matrix_8cpp/","text":"File Matrix.cpp \u00b6 FileList > CommImp > Numeric > Matrix.cpp Go to the source code of this file #include \"Matrix.h\" #include <stdexcept> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric The documentation for this class was generated from the following file Models/CommImp/Numeric/Matrix.cpp","title":"File Matrix.cpp"},{"location":"models/_matrix_8cpp/#file-matrixcpp","text":"FileList > CommImp > Numeric > Matrix.cpp Go to the source code of this file #include \"Matrix.h\" #include <stdexcept>","title":"File Matrix.cpp"},{"location":"models/_matrix_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric The documentation for this class was generated from the following file Models/CommImp/Numeric/Matrix.cpp","title":"Namespaces"},{"location":"models/_matrix_8cpp_source/","text":"File Matrix.cpp \u00b6 File List > CommImp > Numeric > Matrix.cpp Go to the documentation of this file #include \"Matrix.h\" #include <stdexcept> namespace OpenOasis :: CommImp :: Numeric { using namespace std ; DoubleSparseMatrix :: Index :: Index ( int row , int column ) { mRow = row ; mCol = column ; } size_t DoubleSparseMatrix :: HashFunc :: operator ()( const Index & key ) const { using std :: hash ; using std :: size_t ; return (( hash < int > ()( key . mRow ) ^ ( hash < int > ()( key . mCol ) << 1 )) >> 1 ); } bool DoubleSparseMatrix :: EqualFunc :: operator ()( const Index & lhs , const Index & rhs ) const { return lhs . mRow == rhs . mRow && lhs . mCol == rhs . mCol ; } DoubleSparseMatrix :: DoubleSparseMatrix ( int rowCount , int columnCount ) { SetRowCount ( rowCount ); SetColumnCount ( columnCount ); } int DoubleSparseMatrix :: GetRowCount () const { return mRowCount ; } void DoubleSparseMatrix :: SetRowCount ( int value ) { mRowCount = value ; } int DoubleSparseMatrix :: GetColumnCount () const { return mColumnCount ; } void DoubleSparseMatrix :: SetColumnCount ( int value ) { mColumnCount = value ; } bool DoubleSparseMatrix :: IsCellEmpty ( int row , int column ) { auto index = Index ( row , column ); return mValues . find ( index ) == mValues . end (); } Utils :: real DoubleSparseMatrix :: operator ()( int row , int column ) { auto index = Index ( row , column ); const auto & iterator = mValues . find ( index ); if ( iterator == mValues . end ()) throw runtime_error ( \"Matrxi index out of range\" ); return iterator -> second ; } Utils :: real DoubleSparseMatrix :: At ( int row , int column ) { auto index = Index ( row , column ); const auto & iterator = mValues . find ( index ); if ( iterator == mValues . end ()) throw runtime_error ( \"Matrxi index out of range\" ); return iterator -> second ; } void DoubleSparseMatrix :: SetValue ( int row , int column , Utils :: real value ) { auto index = Index ( row , column ); mValues [ index ] = value ; } vector < Utils :: real > DoubleSparseMatrix :: Product ( const vector < Utils :: real > & vector2 ) { auto outputValues = vector < Utils :: real > ( mRowCount ); Product ( outputValues , vector2 ); return outputValues ; } void DoubleSparseMatrix :: Product ( vector < Utils :: real > & res , const vector < Utils :: real > & vector2 ) { if ( vector2 . empty ()) return ; for ( auto & entry : mValues ) { res [ entry . first . mRow ] += entry . second * vector2 [ entry . first . mCol ]; } } } // namespace OpenOasis::CommImp::Numeric","title":"File Matrix.cpp"},{"location":"models/_matrix_8cpp_source/#file-matrixcpp","text":"File List > CommImp > Numeric > Matrix.cpp Go to the documentation of this file #include \"Matrix.h\" #include <stdexcept> namespace OpenOasis :: CommImp :: Numeric { using namespace std ; DoubleSparseMatrix :: Index :: Index ( int row , int column ) { mRow = row ; mCol = column ; } size_t DoubleSparseMatrix :: HashFunc :: operator ()( const Index & key ) const { using std :: hash ; using std :: size_t ; return (( hash < int > ()( key . mRow ) ^ ( hash < int > ()( key . mCol ) << 1 )) >> 1 ); } bool DoubleSparseMatrix :: EqualFunc :: operator ()( const Index & lhs , const Index & rhs ) const { return lhs . mRow == rhs . mRow && lhs . mCol == rhs . mCol ; } DoubleSparseMatrix :: DoubleSparseMatrix ( int rowCount , int columnCount ) { SetRowCount ( rowCount ); SetColumnCount ( columnCount ); } int DoubleSparseMatrix :: GetRowCount () const { return mRowCount ; } void DoubleSparseMatrix :: SetRowCount ( int value ) { mRowCount = value ; } int DoubleSparseMatrix :: GetColumnCount () const { return mColumnCount ; } void DoubleSparseMatrix :: SetColumnCount ( int value ) { mColumnCount = value ; } bool DoubleSparseMatrix :: IsCellEmpty ( int row , int column ) { auto index = Index ( row , column ); return mValues . find ( index ) == mValues . end (); } Utils :: real DoubleSparseMatrix :: operator ()( int row , int column ) { auto index = Index ( row , column ); const auto & iterator = mValues . find ( index ); if ( iterator == mValues . end ()) throw runtime_error ( \"Matrxi index out of range\" ); return iterator -> second ; } Utils :: real DoubleSparseMatrix :: At ( int row , int column ) { auto index = Index ( row , column ); const auto & iterator = mValues . find ( index ); if ( iterator == mValues . end ()) throw runtime_error ( \"Matrxi index out of range\" ); return iterator -> second ; } void DoubleSparseMatrix :: SetValue ( int row , int column , Utils :: real value ) { auto index = Index ( row , column ); mValues [ index ] = value ; } vector < Utils :: real > DoubleSparseMatrix :: Product ( const vector < Utils :: real > & vector2 ) { auto outputValues = vector < Utils :: real > ( mRowCount ); Product ( outputValues , vector2 ); return outputValues ; } void DoubleSparseMatrix :: Product ( vector < Utils :: real > & res , const vector < Utils :: real > & vector2 ) { if ( vector2 . empty ()) return ; for ( auto & entry : mValues ) { res [ entry . first . mRow ] += entry . second * vector2 [ entry . first . mCol ]; } } } // namespace OpenOasis::CommImp::Numeric","title":"File Matrix.cpp"},{"location":"models/_matrix_8h/","text":"File Matrix.h \u00b6 FileList > CommImp > Numeric > Matrix.h Go to the source code of this file #include \"ThirdPart/Eigen/Sparse\" #include \"Vector.h\" #include <vector> #include <unordered_map> #include \"Models/Utils/CommConstants.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric Classes \u00b6 Type Name class DoubleSparseMatrix Sparse matrix having double elements. struct EqualFunc struct HashFunc class Index class Matrix <typename T> The documentation for this class was generated from the following file Models/CommImp/Numeric/Matrix.h","title":"File Matrix.h"},{"location":"models/_matrix_8h/#file-matrixh","text":"FileList > CommImp > Numeric > Matrix.h Go to the source code of this file #include \"ThirdPart/Eigen/Sparse\" #include \"Vector.h\" #include <vector> #include <unordered_map> #include \"Models/Utils/CommConstants.h\"","title":"File Matrix.h"},{"location":"models/_matrix_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric","title":"Namespaces"},{"location":"models/_matrix_8h/#classes","text":"Type Name class DoubleSparseMatrix Sparse matrix having double elements. struct EqualFunc struct HashFunc class Index class Matrix <typename T> The documentation for this class was generated from the following file Models/CommImp/Numeric/Matrix.h","title":"Classes"},{"location":"models/_matrix_8h_source/","text":"File Matrix.h \u00b6 File List > CommImp > Numeric > Matrix.h Go to the documentation of this file #pragma once #include \"ThirdPart/Eigen/Sparse\" #include \"Vector.h\" #include <vector> #include <unordered_map> #include \"Models/Utils/CommConstants.h\" namespace OpenOasis :: CommImp :: Numeric { template < typename T > class Matrix { private : int mRows ; int mCols ; Eigen :: SparseMatrix < T > mData ; public : Matrix ( int rows , int cols ) : mRows ( rows ), mCols ( cols ), mData ( rows , cols ){}; Matrix ( int size ) : mRows ( size ), mCols ( size ), mData ( size , size ){}; Matrix ( const Matrix & other ) { Set ( other ); } Matrix ( const std :: initializer_list < std :: initializer_list < T >> & lst ) { Set ( lst ); } Matrix ( const Eigen :: SparseMatrix < T > & mat ) { mData = mat ; mRows = mat . rows (); mCols = mat . cols (); } // Static methods for matrix creation. // static Matrix Zero ( int rows , int cols ) { return Matrix ( rows , cols ); } static Matrix Unit ( int rows , int cols ) { Matrix mat ( rows , cols ); mat . SetUnit (); return mat ; } // Methods for matrix data setting. // void Set ( const Matrix & other ) { mData = other . mData ; mRows = other . mRows ; mCols = other . mCols ; } void Set ( const std :: initializer_list < std :: initializer_list < T >> & lst ) { size_t rows = lst . size (); size_t cols = ( rows > 0 ) ? lst . begin () -> size () : 0 ; OO_ASSERT (( rows == mRows ) && ( cols == mCols )); std :: vector < Eigen :: Triplet < T >> triplets ; auto rowIter = lst . begin (); for ( size_t i = 0 ; i < rows ; ++ i , ++ rowIter ) { OO_ASSERT ( cols == rowIter -> size ()); auto colIter = rowIter -> begin (); for ( size_t j = 0 ; j < cols ; ++ j , ++ colIter ) triplets . emplace_back ({ i , j , * colIter }); } mData . setZero (); mData . setFromTriplets ( triplets . begin (), triplets . end ()); } void SetAt ( size_t i , size_t j , const T & val ) { mData . coeffRef ( i , j ) = val ; } void SetDiagonal ( const T & s ) { for ( size_t i = 0 ; i < mRows ; i ++ ) { SetAt ( i , i , s ); } } template < size_t N > void SetRow ( size_t i , const Vector < T , N > & vec ) { OO_ASSERT ( i < mRows ); OO_ASSERT ( N == mCols ); for ( size_t j = 0 ; j < mCols ; ++ j ) { SetAt ( i , j , vec ( j )); } } template < size_t N > void SetCol ( size_t j , const Vector < T , N > & vec ) { OO_ASSERT ( j < mCols ); OO_ASSERT ( N == mRows ); for ( size_t i = 0 ; i < mRows ; ++ i ) { SetAt ( i , j , vec ( i )); } } void SetZero () { mData . setZero (); } void SetUnit () { mData . setIdentity (); } // Methods for matrix attributes query. // T Trace () const { OO_ASSERT ( mRows == mCols ); T res = 0 ; for ( size_t i = 0 ; i < mRows ; ++ i ) res += mData . coeffRef ( i , i ); return res ; } T Determinant () const { T res = 1 ; for ( size_t i = 0 ; i < mRows ; ++ i ) res *= mData . coeffRef ( i , i ); return res ; } template < std :: size_t N > Vector < T , N > Diagonal () const { OO_ASSERT ( N == mRows ); std :: array < T , N > diags ; for ( std :: size_t i = 0 ; i < N ; ++ i ) diags [ i ] = mData . coeffRef ( i , i ); return diags ; } Eigen :: SparseMatrix < T > & Data () { return mData ; } const Eigen :: SparseMatrix < T > & Data () const { return mData ; } T Max () const { return mData . maxCoeff (); } T Min () const { return mData . minCoeff (); } size_t Rows () const { return mRows ; } size_t Cols () const { return mCols ; } T Sum () const { return mData . sum (); } // Methods for matrix operations. // void Add ( std :: size_t i , std :: size_t j , const T & s ) { OO_ASSERT (( i < mRows ) && ( j < mCols )); mData . coeffRef ( i , j ) += s ; } void Add ( const Matrix & m ) { OO_ASSERT (( mRows == m . mRows ) && ( mCols == m . mCols )); mData += m . mData ; } void Sub ( std :: size_t i , std :: size_t j , const T & s ) { OO_ASSERT (( i < mRows ) && ( j < mCols )); mData . coeffRef ( i , j ) -= s ; } void Sub ( const Matrix & m ) { OO_ASSERT (( mRows == m . mRows ) && ( mCols == m . mCols )); mData -= m . mData ; } void Mul ( const T & s ) { mData *= s ; } Matrix Mul ( const Matrix & m ) const { OO_ASSERT ( mCols == m . mRows ); return mData * m . mData ; } Matrix Transpose () const { return mData . transpose (); } Matrix Invert () const { return mData . inverse (); } Matrix Adjoint () const { return mData . adjoint (); } // Override operators for matrix. // T & operator ()( size_t i , size_t j ) { return mData . coeffRef ( i , j ); } const T & operator ()( size_t i , size_t j ) const { return mData . coeffRef ( i , j ); } Matrix operator + ( const Matrix & m ) const { Matrix res = * this ; res . Add ( m ); return res ; } Matrix operator - ( const Matrix & m ) const { Matrix res = * this ; res . Sub ( m ); return res ; } Matrix operator * ( const Matrix & m ) const { Matrix res = * this ; res . Mul ( m ); return res ; } Matrix operator * ( const T & s ) const { Matrix res = * this ; res . Mul ( s ); return res ; } Matrix & operator = ( const Matrix & other ) { Set ( other ); return * this ; } Matrix & operator += ( const Matrix & m ) { Add ( m ); return * this ; } Matrix & operator -= ( const Matrix & m ) { Sub ( m ); return * this ; } Matrix & operator *= ( const T & s ) { Mul ( s ); return * this ; } Matrix & operator *= ( const Matrix & m ) { Mul ( m ); return * this ; } }; // Legacy code below. // class DoubleSparseMatrix { private : int mRowCount = 0 ; int mColumnCount = 0 ; public : class Index { public : Index ( int row , int column ); Index () = default ; int mRow = 0 ; int mCol = 0 ; }; struct EqualFunc { bool operator ()( const Index & lhs , const Index & rhs ) const ; }; struct HashFunc { size_t operator ()( const Index & key ) const ; }; std :: unordered_map < Index , Utils :: real , HashFunc , EqualFunc > mValues ; public : DoubleSparseMatrix ( int rowCount , int columnCount ); int GetRowCount () const ; void SetRowCount ( int value ); int GetColumnCount () const ; void SetColumnCount ( int value ); std :: vector < Utils :: real > Product ( const std :: vector < Utils :: real > & vector2 ); void Product ( std :: vector < Utils :: real > & res , const std :: vector < Utils :: real > & vector2 ); // Local methods. // bool IsCellEmpty ( int row , int column ); Utils :: real operator ()( int row , int column ); Utils :: real At ( int row , int column ); void SetValue ( int row , int column , Utils :: real value ); }; } // namespace OpenOasis::CommImp::Numeric","title":"File Matrix.h"},{"location":"models/_matrix_8h_source/#file-matrixh","text":"File List > CommImp > Numeric > Matrix.h Go to the documentation of this file #pragma once #include \"ThirdPart/Eigen/Sparse\" #include \"Vector.h\" #include <vector> #include <unordered_map> #include \"Models/Utils/CommConstants.h\" namespace OpenOasis :: CommImp :: Numeric { template < typename T > class Matrix { private : int mRows ; int mCols ; Eigen :: SparseMatrix < T > mData ; public : Matrix ( int rows , int cols ) : mRows ( rows ), mCols ( cols ), mData ( rows , cols ){}; Matrix ( int size ) : mRows ( size ), mCols ( size ), mData ( size , size ){}; Matrix ( const Matrix & other ) { Set ( other ); } Matrix ( const std :: initializer_list < std :: initializer_list < T >> & lst ) { Set ( lst ); } Matrix ( const Eigen :: SparseMatrix < T > & mat ) { mData = mat ; mRows = mat . rows (); mCols = mat . cols (); } // Static methods for matrix creation. // static Matrix Zero ( int rows , int cols ) { return Matrix ( rows , cols ); } static Matrix Unit ( int rows , int cols ) { Matrix mat ( rows , cols ); mat . SetUnit (); return mat ; } // Methods for matrix data setting. // void Set ( const Matrix & other ) { mData = other . mData ; mRows = other . mRows ; mCols = other . mCols ; } void Set ( const std :: initializer_list < std :: initializer_list < T >> & lst ) { size_t rows = lst . size (); size_t cols = ( rows > 0 ) ? lst . begin () -> size () : 0 ; OO_ASSERT (( rows == mRows ) && ( cols == mCols )); std :: vector < Eigen :: Triplet < T >> triplets ; auto rowIter = lst . begin (); for ( size_t i = 0 ; i < rows ; ++ i , ++ rowIter ) { OO_ASSERT ( cols == rowIter -> size ()); auto colIter = rowIter -> begin (); for ( size_t j = 0 ; j < cols ; ++ j , ++ colIter ) triplets . emplace_back ({ i , j , * colIter }); } mData . setZero (); mData . setFromTriplets ( triplets . begin (), triplets . end ()); } void SetAt ( size_t i , size_t j , const T & val ) { mData . coeffRef ( i , j ) = val ; } void SetDiagonal ( const T & s ) { for ( size_t i = 0 ; i < mRows ; i ++ ) { SetAt ( i , i , s ); } } template < size_t N > void SetRow ( size_t i , const Vector < T , N > & vec ) { OO_ASSERT ( i < mRows ); OO_ASSERT ( N == mCols ); for ( size_t j = 0 ; j < mCols ; ++ j ) { SetAt ( i , j , vec ( j )); } } template < size_t N > void SetCol ( size_t j , const Vector < T , N > & vec ) { OO_ASSERT ( j < mCols ); OO_ASSERT ( N == mRows ); for ( size_t i = 0 ; i < mRows ; ++ i ) { SetAt ( i , j , vec ( i )); } } void SetZero () { mData . setZero (); } void SetUnit () { mData . setIdentity (); } // Methods for matrix attributes query. // T Trace () const { OO_ASSERT ( mRows == mCols ); T res = 0 ; for ( size_t i = 0 ; i < mRows ; ++ i ) res += mData . coeffRef ( i , i ); return res ; } T Determinant () const { T res = 1 ; for ( size_t i = 0 ; i < mRows ; ++ i ) res *= mData . coeffRef ( i , i ); return res ; } template < std :: size_t N > Vector < T , N > Diagonal () const { OO_ASSERT ( N == mRows ); std :: array < T , N > diags ; for ( std :: size_t i = 0 ; i < N ; ++ i ) diags [ i ] = mData . coeffRef ( i , i ); return diags ; } Eigen :: SparseMatrix < T > & Data () { return mData ; } const Eigen :: SparseMatrix < T > & Data () const { return mData ; } T Max () const { return mData . maxCoeff (); } T Min () const { return mData . minCoeff (); } size_t Rows () const { return mRows ; } size_t Cols () const { return mCols ; } T Sum () const { return mData . sum (); } // Methods for matrix operations. // void Add ( std :: size_t i , std :: size_t j , const T & s ) { OO_ASSERT (( i < mRows ) && ( j < mCols )); mData . coeffRef ( i , j ) += s ; } void Add ( const Matrix & m ) { OO_ASSERT (( mRows == m . mRows ) && ( mCols == m . mCols )); mData += m . mData ; } void Sub ( std :: size_t i , std :: size_t j , const T & s ) { OO_ASSERT (( i < mRows ) && ( j < mCols )); mData . coeffRef ( i , j ) -= s ; } void Sub ( const Matrix & m ) { OO_ASSERT (( mRows == m . mRows ) && ( mCols == m . mCols )); mData -= m . mData ; } void Mul ( const T & s ) { mData *= s ; } Matrix Mul ( const Matrix & m ) const { OO_ASSERT ( mCols == m . mRows ); return mData * m . mData ; } Matrix Transpose () const { return mData . transpose (); } Matrix Invert () const { return mData . inverse (); } Matrix Adjoint () const { return mData . adjoint (); } // Override operators for matrix. // T & operator ()( size_t i , size_t j ) { return mData . coeffRef ( i , j ); } const T & operator ()( size_t i , size_t j ) const { return mData . coeffRef ( i , j ); } Matrix operator + ( const Matrix & m ) const { Matrix res = * this ; res . Add ( m ); return res ; } Matrix operator - ( const Matrix & m ) const { Matrix res = * this ; res . Sub ( m ); return res ; } Matrix operator * ( const Matrix & m ) const { Matrix res = * this ; res . Mul ( m ); return res ; } Matrix operator * ( const T & s ) const { Matrix res = * this ; res . Mul ( s ); return res ; } Matrix & operator = ( const Matrix & other ) { Set ( other ); return * this ; } Matrix & operator += ( const Matrix & m ) { Add ( m ); return * this ; } Matrix & operator -= ( const Matrix & m ) { Sub ( m ); return * this ; } Matrix & operator *= ( const T & s ) { Mul ( s ); return * this ; } Matrix & operator *= ( const Matrix & m ) { Mul ( m ); return * this ; } }; // Legacy code below. // class DoubleSparseMatrix { private : int mRowCount = 0 ; int mColumnCount = 0 ; public : class Index { public : Index ( int row , int column ); Index () = default ; int mRow = 0 ; int mCol = 0 ; }; struct EqualFunc { bool operator ()( const Index & lhs , const Index & rhs ) const ; }; struct HashFunc { size_t operator ()( const Index & key ) const ; }; std :: unordered_map < Index , Utils :: real , HashFunc , EqualFunc > mValues ; public : DoubleSparseMatrix ( int rowCount , int columnCount ); int GetRowCount () const ; void SetRowCount ( int value ); int GetColumnCount () const ; void SetColumnCount ( int value ); std :: vector < Utils :: real > Product ( const std :: vector < Utils :: real > & vector2 ); void Product ( std :: vector < Utils :: real > & res , const std :: vector < Utils :: real > & vector2 ); // Local methods. // bool IsCellEmpty ( int row , int column ); Utils :: real operator ()( int row , int column ); Utils :: real At ( int row , int column ); void SetValue ( int row , int column , Utils :: real value ); }; } // namespace OpenOasis::CommImp::Numeric","title":"File Matrix.h"},{"location":"models/dir_ce9212301f8d93e5246dd812df0f37fe/","text":"Dir Models/CommImp/Numeric/FVM \u00b6 FileList > CommImp > Numeric > FVM Files \u00b6 Type Name file FvmSolver.cpp file FvmSolver.h The documentation for this class was generated from the following file Models/CommImp/Numeric/FVM/","title":"Dir Models/CommImp/Numeric/FVM"},{"location":"models/dir_ce9212301f8d93e5246dd812df0f37fe/#dir-modelscommimpnumericfvm","text":"FileList > CommImp > Numeric > FVM","title":"Dir Models/CommImp/Numeric/FVM"},{"location":"models/dir_ce9212301f8d93e5246dd812df0f37fe/#files","text":"Type Name file FvmSolver.cpp file FvmSolver.h The documentation for this class was generated from the following file Models/CommImp/Numeric/FVM/","title":"Files"},{"location":"models/_fvm_solver_8cpp/","text":"File FvmSolver.cpp \u00b6 FileList > CommImp > Numeric > FVM > FvmSolver.cpp Go to the source code of this file #include \"FvmSolver.h\" #include \"Models/CommImp/Numeric/LaplacianOperator.h\" #include \"Models/Utils/Exception.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric namespace FVM The documentation for this class was generated from the following file Models/CommImp/Numeric/FVM/FvmSolver.cpp","title":"File FvmSolver.cpp"},{"location":"models/_fvm_solver_8cpp/#file-fvmsolvercpp","text":"FileList > CommImp > Numeric > FVM > FvmSolver.cpp Go to the source code of this file #include \"FvmSolver.h\" #include \"Models/CommImp/Numeric/LaplacianOperator.h\" #include \"Models/Utils/Exception.h\"","title":"File FvmSolver.cpp"},{"location":"models/_fvm_solver_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric namespace FVM The documentation for this class was generated from the following file Models/CommImp/Numeric/FVM/FvmSolver.cpp","title":"Namespaces"},{"location":"models/_fvm_solver_8cpp_source/","text":"File FvmSolver.cpp \u00b6 File List > CommImp > Numeric > FVM > FvmSolver.cpp Go to the documentation of this file #include \"FvmSolver.h\" #include \"Models/CommImp/Numeric/LaplacianOperator.h\" #include \"Models/Utils/Exception.h\" namespace OpenOasis :: CommImp :: Numeric :: FVM { using namespace std ; using namespace Utils ; FvmSolver :: FvmSolver ( const shared_ptr < Grid > & grid ) : mGrid ( grid ), mCoeffMat ( grid -> GetNumCells ()), mRhs ( grid -> GetNumCells ()) {} void FvmSolver :: SetBoundary ( int faceIndex , const shared_ptr < Boundary > & bound ) { mBoundaries [ faceIndex ] = bound ; } void FvmSolver :: SetInitialValue ( const string & var , const variant < real , Vector < real > , Tensor < real >> & value ) { if ( var != \"temp\" ) { throw invalid_argument ( \"only steady heat-diffusion\" ); } mInitValue = get < real > ( value ); } void FvmSolver :: SetCoefficient ( const string & var , const variant < real , Vector < real > , Tensor < real >> & coeff ) { if ( var != \"temp\" ) { throw invalid_argument ( \"only steady heat-diffusion\" ); } mCoeffHeat = get < real > ( coeff ); } void FvmSolver :: ParseDiffusionTerm () { Laplacian lap ( mGrid ); lap . SetCoefficient ( variant < real , Vector < real > , Tensor < real >> ( mCoeffHeat )); for ( const auto & b : mBoundaries ) { lap . SetBoundaryCondition ( b . first , b . second -> GetBoundaryCondition ()); } ScalarField tempField ( mGrid -> GetNumCells (), mInitValue ); const auto & eqs = lap . Discretize ( tempField , {}); mCoeffMat += get < 0 > ( eqs ); const auto & rhs = get < 1 > ( eqs ); for ( int i = 0 ; i < mGrid -> GetNumCells (); ++ i ) { mRhs [ i ] += rhs [ i ]; } } void FvmSolver :: Solve () { Eigen :: Map < Eigen :: Matrix < real , Eigen :: Dynamic , 1 >> b ( mRhs . data (), ( int ) mRhs . size ()); Eigen :: ConjugateGradient < Eigen :: SparseMatrix < real >> solver ; solver . compute ( mCoeffMat . Data ()); if ( solver . info () != Eigen :: Success ) { throw runtime_error ( \"Solve compute failed.\" ); } Eigen :: Matrix < real , Eigen :: Dynamic , 1 > x = solver . solve ( b ); if ( solver . info () != Eigen :: Success ) { throw runtime_error ( \"Solve failed.\" ); } mTemps . Resize ( mGrid -> GetNumCells ()); for ( int i = 0 ; i < x . cols () * x . rows (); ++ i ) { mTemps ( i ) = x [ i ]; } } optional < ScalarFieldFp > FvmSolver :: GetScalarSolutions ( const string & var ) const { return mTemps ; } } // namespace OpenOasis::CommImp::Numeric::FVM","title":"File FvmSolver.cpp"},{"location":"models/_fvm_solver_8cpp_source/#file-fvmsolvercpp","text":"File List > CommImp > Numeric > FVM > FvmSolver.cpp Go to the documentation of this file #include \"FvmSolver.h\" #include \"Models/CommImp/Numeric/LaplacianOperator.h\" #include \"Models/Utils/Exception.h\" namespace OpenOasis :: CommImp :: Numeric :: FVM { using namespace std ; using namespace Utils ; FvmSolver :: FvmSolver ( const shared_ptr < Grid > & grid ) : mGrid ( grid ), mCoeffMat ( grid -> GetNumCells ()), mRhs ( grid -> GetNumCells ()) {} void FvmSolver :: SetBoundary ( int faceIndex , const shared_ptr < Boundary > & bound ) { mBoundaries [ faceIndex ] = bound ; } void FvmSolver :: SetInitialValue ( const string & var , const variant < real , Vector < real > , Tensor < real >> & value ) { if ( var != \"temp\" ) { throw invalid_argument ( \"only steady heat-diffusion\" ); } mInitValue = get < real > ( value ); } void FvmSolver :: SetCoefficient ( const string & var , const variant < real , Vector < real > , Tensor < real >> & coeff ) { if ( var != \"temp\" ) { throw invalid_argument ( \"only steady heat-diffusion\" ); } mCoeffHeat = get < real > ( coeff ); } void FvmSolver :: ParseDiffusionTerm () { Laplacian lap ( mGrid ); lap . SetCoefficient ( variant < real , Vector < real > , Tensor < real >> ( mCoeffHeat )); for ( const auto & b : mBoundaries ) { lap . SetBoundaryCondition ( b . first , b . second -> GetBoundaryCondition ()); } ScalarField tempField ( mGrid -> GetNumCells (), mInitValue ); const auto & eqs = lap . Discretize ( tempField , {}); mCoeffMat += get < 0 > ( eqs ); const auto & rhs = get < 1 > ( eqs ); for ( int i = 0 ; i < mGrid -> GetNumCells (); ++ i ) { mRhs [ i ] += rhs [ i ]; } } void FvmSolver :: Solve () { Eigen :: Map < Eigen :: Matrix < real , Eigen :: Dynamic , 1 >> b ( mRhs . data (), ( int ) mRhs . size ()); Eigen :: ConjugateGradient < Eigen :: SparseMatrix < real >> solver ; solver . compute ( mCoeffMat . Data ()); if ( solver . info () != Eigen :: Success ) { throw runtime_error ( \"Solve compute failed.\" ); } Eigen :: Matrix < real , Eigen :: Dynamic , 1 > x = solver . solve ( b ); if ( solver . info () != Eigen :: Success ) { throw runtime_error ( \"Solve failed.\" ); } mTemps . Resize ( mGrid -> GetNumCells ()); for ( int i = 0 ; i < x . cols () * x . rows (); ++ i ) { mTemps ( i ) = x [ i ]; } } optional < ScalarFieldFp > FvmSolver :: GetScalarSolutions ( const string & var ) const { return mTemps ; } } // namespace OpenOasis::CommImp::Numeric::FVM","title":"File FvmSolver.cpp"},{"location":"models/_fvm_solver_8h/","text":"File FvmSolver.h \u00b6 FileList > CommImp > Numeric > FVM > FvmSolver.h Go to the source code of this file #include \"Models/CommImp/Numeric/Solver.h\" #include \"Models/CommImp/Numeric/Matrix.h\" #include \"Models/CommImp/Spatial/Grid.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric namespace FVM Classes \u00b6 Type Name class FvmSolver The documentation for this class was generated from the following file Models/CommImp/Numeric/FVM/FvmSolver.h","title":"File FvmSolver.h"},{"location":"models/_fvm_solver_8h/#file-fvmsolverh","text":"FileList > CommImp > Numeric > FVM > FvmSolver.h Go to the source code of this file #include \"Models/CommImp/Numeric/Solver.h\" #include \"Models/CommImp/Numeric/Matrix.h\" #include \"Models/CommImp/Spatial/Grid.h\"","title":"File FvmSolver.h"},{"location":"models/_fvm_solver_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric namespace FVM","title":"Namespaces"},{"location":"models/_fvm_solver_8h/#classes","text":"Type Name class FvmSolver The documentation for this class was generated from the following file Models/CommImp/Numeric/FVM/FvmSolver.h","title":"Classes"},{"location":"models/_fvm_solver_8h_source/","text":"File FvmSolver.h \u00b6 File List > CommImp > Numeric > FVM > FvmSolver.h Go to the documentation of this file #pragma once #include \"Models/CommImp/Numeric/Solver.h\" #include \"Models/CommImp/Numeric/Matrix.h\" #include \"Models/CommImp/Spatial/Grid.h\" namespace OpenOasis :: CommImp :: Numeric :: FVM { using Spatial :: Grid ; using Utils :: real ; class FvmSolver : public Solver { private : std :: shared_ptr < Grid > mGrid ; Matrix < real > mCoeffMat ; std :: vector < real > mRhs ; std :: unordered_map < int , std :: shared_ptr < Boundary >> mBoundaries ; real mCoeffHeat ; real mInitValue ; ScalarFieldFp mTemps ; public : ~ FvmSolver () = default ; FvmSolver ( const std :: shared_ptr < Grid > & grid ); void SetBoundary ( int faceIndex , const std :: shared_ptr < Boundary > & bound ) override ; void SetInitialValue ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real >> & value ) override ; void SetCoefficient ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real >> & coeff ) override ; void ParseDiffusionTerm () override ; void Solve () override ; std :: optional < ScalarFieldFp > GetScalarSolutions ( const std :: string & var ) const override ; }; } // namespace OpenOasis::CommImp::Numeric::FVM","title":"File FvmSolver.h"},{"location":"models/_fvm_solver_8h_source/#file-fvmsolverh","text":"File List > CommImp > Numeric > FVM > FvmSolver.h Go to the documentation of this file #pragma once #include \"Models/CommImp/Numeric/Solver.h\" #include \"Models/CommImp/Numeric/Matrix.h\" #include \"Models/CommImp/Spatial/Grid.h\" namespace OpenOasis :: CommImp :: Numeric :: FVM { using Spatial :: Grid ; using Utils :: real ; class FvmSolver : public Solver { private : std :: shared_ptr < Grid > mGrid ; Matrix < real > mCoeffMat ; std :: vector < real > mRhs ; std :: unordered_map < int , std :: shared_ptr < Boundary >> mBoundaries ; real mCoeffHeat ; real mInitValue ; ScalarFieldFp mTemps ; public : ~ FvmSolver () = default ; FvmSolver ( const std :: shared_ptr < Grid > & grid ); void SetBoundary ( int faceIndex , const std :: shared_ptr < Boundary > & bound ) override ; void SetInitialValue ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real >> & value ) override ; void SetCoefficient ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real >> & coeff ) override ; void ParseDiffusionTerm () override ; void Solve () override ; std :: optional < ScalarFieldFp > GetScalarSolutions ( const std :: string & var ) const override ; }; } // namespace OpenOasis::CommImp::Numeric::FVM","title":"File FvmSolver.h"},{"location":"models/_neumann_boundary_8h/","text":"File NeumannBoundary.h \u00b6 FileList > CommImp > Numeric > NeumannBoundary.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/NeumannBoundary.h","title":"File NeumannBoundary.h"},{"location":"models/_neumann_boundary_8h/#file-neumannboundaryh","text":"FileList > CommImp > Numeric > NeumannBoundary.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/NeumannBoundary.h","title":"File NeumannBoundary.h"},{"location":"models/_neumann_boundary_8h_source/","text":"File NeumannBoundary.h \u00b6 File List > CommImp > Numeric > NeumannBoundary.h Go to the documentation of this file","title":"File NeumannBoundary.h"},{"location":"models/_neumann_boundary_8h_source/#file-neumannboundaryh","text":"File List > CommImp > Numeric > NeumannBoundary.h Go to the documentation of this file","title":"File NeumannBoundary.h"},{"location":"models/_numeric_methods_8h/","text":"File NumericMethods.h \u00b6 FileList > CommImp > Numeric > NumericMethods.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/NumericMethods.h","title":"File NumericMethods.h"},{"location":"models/_numeric_methods_8h/#file-numericmethodsh","text":"FileList > CommImp > Numeric > NumericMethods.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/NumericMethods.h","title":"File NumericMethods.h"},{"location":"models/_numeric_methods_8h_source/","text":"File NumericMethods.h \u00b6 File List > CommImp > Numeric > NumericMethods.h Go to the documentation of this file","title":"File NumericMethods.h"},{"location":"models/_numeric_methods_8h_source/#file-numericmethodsh","text":"File List > CommImp > Numeric > NumericMethods.h Go to the documentation of this file","title":"File NumericMethods.h"},{"location":"models/_operator_8h/","text":"File Operator.h \u00b6 FileList > CommImp > Numeric > Operator.h Go to the source code of this file #include \"Models/Utils/CommConstants.h\" #include \"Models/Utils/Exception.h\" #include \"ScalarField.h\" #include \"VectorField.h\" #include \"TensorField.h\" #include \"Boundary.h\" #include \"Matrix.h\" #include <variant> #include <tuple> #include <optional> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric Classes \u00b6 Type Name class Operator Abstract operator class. The documentation for this class was generated from the following file Models/CommImp/Numeric/Operator.h","title":"File Operator.h"},{"location":"models/_operator_8h/#file-operatorh","text":"FileList > CommImp > Numeric > Operator.h Go to the source code of this file #include \"Models/Utils/CommConstants.h\" #include \"Models/Utils/Exception.h\" #include \"ScalarField.h\" #include \"VectorField.h\" #include \"TensorField.h\" #include \"Boundary.h\" #include \"Matrix.h\" #include <variant> #include <tuple> #include <optional>","title":"File Operator.h"},{"location":"models/_operator_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric","title":"Namespaces"},{"location":"models/_operator_8h/#classes","text":"Type Name class Operator Abstract operator class. The documentation for this class was generated from the following file Models/CommImp/Numeric/Operator.h","title":"Classes"},{"location":"models/_operator_8h_source/","text":"File Operator.h \u00b6 File List > CommImp > Numeric > Operator.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommConstants.h\" #include \"Models/Utils/Exception.h\" #include \"ScalarField.h\" #include \"VectorField.h\" #include \"TensorField.h\" #include \"Boundary.h\" #include \"Matrix.h\" #include <variant> #include <tuple> #include <optional> namespace OpenOasis :: CommImp :: Numeric { using Utils :: real ; using LinearEqs = std :: tuple < Matrix < real > , std :: vector < real >> ; class Operator { protected : std :: optional < std :: variant < real , Vector < real > , Tensor < real >>> mCoefficient ; std :: optional < ScalarField < real >> mScalarCoeffs ; std :: optional < VectorField < real >> mVectorCoeffs ; std :: optional < TensorField < real >> mTensorCoeffs ; std :: unordered_map < int , BoundaryCondition > mboundaries ; public : virtual ~ Operator () = default ; // Methods for setting face coefficients. // virtual void SetCoefficient ( const std :: variant < real , Vector < real > , Tensor < real >> & coeff ) { mCoefficient = coeff ; } virtual void SetCoefficient ( const ScalarField < real > & coefficients ) { mScalarCoeffs = coefficients ; } virtual void SetCoefficient ( const VectorField < real > & coefficients ) { mVectorCoeffs = coefficients ; } virtual void SetCoefficient ( const TensorField < real > & coefficients ) { mTensorCoeffs = coefficients ; } // Methods for setting boundary conditions. // virtual void SetBoundaryCondition ( int faceIndex , const BoundaryCondition & boundary ) { mboundaries [ faceIndex ] = boundary ; } // Methods for discretizing field. // virtual LinearEqs Discretize ( const ScalarField < real > & phiCellField , const ScalarField < real > & phiFaceField ) { throw Utils :: NotImplementedException (); } virtual LinearEqs Discretize ( const VectorField < real > & phiCellField , const VectorField < real > & phiFaceField ) { throw Utils :: NotImplementedException (); } virtual LinearEqs Discretize ( const TensorField < real > & phiCellField , const TensorField < real > & phiFaceField ) { throw Utils :: NotImplementedException (); } }; } // namespace OpenOasis::CommImp::Numeric","title":"File Operator.h"},{"location":"models/_operator_8h_source/#file-operatorh","text":"File List > CommImp > Numeric > Operator.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommConstants.h\" #include \"Models/Utils/Exception.h\" #include \"ScalarField.h\" #include \"VectorField.h\" #include \"TensorField.h\" #include \"Boundary.h\" #include \"Matrix.h\" #include <variant> #include <tuple> #include <optional> namespace OpenOasis :: CommImp :: Numeric { using Utils :: real ; using LinearEqs = std :: tuple < Matrix < real > , std :: vector < real >> ; class Operator { protected : std :: optional < std :: variant < real , Vector < real > , Tensor < real >>> mCoefficient ; std :: optional < ScalarField < real >> mScalarCoeffs ; std :: optional < VectorField < real >> mVectorCoeffs ; std :: optional < TensorField < real >> mTensorCoeffs ; std :: unordered_map < int , BoundaryCondition > mboundaries ; public : virtual ~ Operator () = default ; // Methods for setting face coefficients. // virtual void SetCoefficient ( const std :: variant < real , Vector < real > , Tensor < real >> & coeff ) { mCoefficient = coeff ; } virtual void SetCoefficient ( const ScalarField < real > & coefficients ) { mScalarCoeffs = coefficients ; } virtual void SetCoefficient ( const VectorField < real > & coefficients ) { mVectorCoeffs = coefficients ; } virtual void SetCoefficient ( const TensorField < real > & coefficients ) { mTensorCoeffs = coefficients ; } // Methods for setting boundary conditions. // virtual void SetBoundaryCondition ( int faceIndex , const BoundaryCondition & boundary ) { mboundaries [ faceIndex ] = boundary ; } // Methods for discretizing field. // virtual LinearEqs Discretize ( const ScalarField < real > & phiCellField , const ScalarField < real > & phiFaceField ) { throw Utils :: NotImplementedException (); } virtual LinearEqs Discretize ( const VectorField < real > & phiCellField , const VectorField < real > & phiFaceField ) { throw Utils :: NotImplementedException (); } virtual LinearEqs Discretize ( const TensorField < real > & phiCellField , const TensorField < real > & phiFaceField ) { throw Utils :: NotImplementedException (); } }; } // namespace OpenOasis::CommImp::Numeric","title":"File Operator.h"},{"location":"models/_robin_boundary_8h/","text":"File RobinBoundary.h \u00b6 FileList > CommImp > Numeric > RobinBoundary.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/RobinBoundary.h","title":"File RobinBoundary.h"},{"location":"models/_robin_boundary_8h/#file-robinboundaryh","text":"FileList > CommImp > Numeric > RobinBoundary.h Go to the source code of this file The documentation for this class was generated from the following file Models/CommImp/Numeric/RobinBoundary.h","title":"File RobinBoundary.h"},{"location":"models/_robin_boundary_8h_source/","text":"File RobinBoundary.h \u00b6 File List > CommImp > Numeric > RobinBoundary.h Go to the documentation of this file","title":"File RobinBoundary.h"},{"location":"models/_robin_boundary_8h_source/#file-robinboundaryh","text":"File List > CommImp > Numeric > RobinBoundary.h Go to the documentation of this file","title":"File RobinBoundary.h"},{"location":"models/_scalar_field_8h/","text":"File ScalarField.h \u00b6 FileList > CommImp > Numeric > ScalarField.h Go to the source code of this file #include \"Models/Utils/CommConstants.h\" #include \"Field.h\" #include <type_traits> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric Classes \u00b6 Type Name class ScalarField <typename T> Scaler field. The documentation for this class was generated from the following file Models/CommImp/Numeric/ScalarField.h","title":"File ScalarField.h"},{"location":"models/_scalar_field_8h/#file-scalarfieldh","text":"FileList > CommImp > Numeric > ScalarField.h Go to the source code of this file #include \"Models/Utils/CommConstants.h\" #include \"Field.h\" #include <type_traits>","title":"File ScalarField.h"},{"location":"models/_scalar_field_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric","title":"Namespaces"},{"location":"models/_scalar_field_8h/#classes","text":"Type Name class ScalarField <typename T> Scaler field. The documentation for this class was generated from the following file Models/CommImp/Numeric/ScalarField.h","title":"Classes"},{"location":"models/_scalar_field_8h_source/","text":"File ScalarField.h \u00b6 File List > CommImp > Numeric > ScalarField.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommConstants.h\" #include \"Field.h\" #include <type_traits> namespace OpenOasis :: CommImp :: Numeric { template < typename T > class ScalarField : public Field < T > { public : static_assert ( std :: is_arithmetic < T >:: value , \"ScalarField only can be instantiated with arithmetic types\" ); virtual ~ ScalarField () = default ; ScalarField ( std :: size_t size , T val = 0 , FieldDomain domain = FieldDomain :: CELL ) : Field < T > ( size , val ) { this -> mDomain = domain ; this -> mType = FieldType :: SCALAR ; } ScalarField ( FieldDomain domain = FieldDomain :: CELL ) { this -> mDomain = domain ; this -> mType = FieldType :: SCALAR ; } }; using ScalarFieldDbl = ScalarField < double > ; using ScalarFieldInt = ScalarField < int > ; using ScalarFieldFp = ScalarField < Utils :: real > ; } // namespace OpenOasis::CommImp::Numeric","title":"File ScalarField.h"},{"location":"models/_scalar_field_8h_source/#file-scalarfieldh","text":"File List > CommImp > Numeric > ScalarField.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommConstants.h\" #include \"Field.h\" #include <type_traits> namespace OpenOasis :: CommImp :: Numeric { template < typename T > class ScalarField : public Field < T > { public : static_assert ( std :: is_arithmetic < T >:: value , \"ScalarField only can be instantiated with arithmetic types\" ); virtual ~ ScalarField () = default ; ScalarField ( std :: size_t size , T val = 0 , FieldDomain domain = FieldDomain :: CELL ) : Field < T > ( size , val ) { this -> mDomain = domain ; this -> mType = FieldType :: SCALAR ; } ScalarField ( FieldDomain domain = FieldDomain :: CELL ) { this -> mDomain = domain ; this -> mType = FieldType :: SCALAR ; } }; using ScalarFieldDbl = ScalarField < double > ; using ScalarFieldInt = ScalarField < int > ; using ScalarFieldFp = ScalarField < Utils :: real > ; } // namespace OpenOasis::CommImp::Numeric","title":"File ScalarField.h"},{"location":"models/_solver_8h/","text":"File Solver.h \u00b6 FileList > CommImp > Numeric > Solver.h Go to the source code of this file #include \"Boundary.h\" #include \"Source.h\" #include \"Operator.h\" #include \"Matrix.h\" #include <optional> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric Classes \u00b6 Type Name class Solver Abstract solver class. The documentation for this class was generated from the following file Models/CommImp/Numeric/Solver.h","title":"File Solver.h"},{"location":"models/_solver_8h/#file-solverh","text":"FileList > CommImp > Numeric > Solver.h Go to the source code of this file #include \"Boundary.h\" #include \"Source.h\" #include \"Operator.h\" #include \"Matrix.h\" #include <optional>","title":"File Solver.h"},{"location":"models/_solver_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric","title":"Namespaces"},{"location":"models/_solver_8h/#classes","text":"Type Name class Solver Abstract solver class. The documentation for this class was generated from the following file Models/CommImp/Numeric/Solver.h","title":"Classes"},{"location":"models/_solver_8h_source/","text":"File Solver.h \u00b6 File List > CommImp > Numeric > Solver.h Go to the documentation of this file #pragma once #include \"Boundary.h\" #include \"Source.h\" #include \"Operator.h\" #include \"Matrix.h\" #include <optional> namespace OpenOasis :: CommImp :: Numeric { using Utils :: real ; enum class SolverStatus { Created , Initialized , Parsed , Discretized , Updated , Solved , Failed }; class Solver { public : // Configuration and initialization. // virtual void SetBoundary ( int faceIndex , const std :: shared_ptr < Boundary > & bound ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetInitialValue ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real >> & value ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetInitialValue ( const std :: string & var , const ScalarFieldFp & values ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetInitialValue ( const std :: string & var , const VectorFieldFp & values ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetInitialValue ( const std :: string & var , const TensorFieldFp & values ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetCoefficient ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real >> & coeff ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetCoefficient ( const std :: string & var , const ScalarFieldFp & coeffs ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetCoefficient ( const std :: string & var , const VectorFieldFp & coeffs ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetCoefficient ( const std :: string & var , const TensorFieldFp & coeffs ) { throw std :: runtime_error ( \"Not implemented.\" ); } // Equation parsing and discretizing. // virtual void ParseTimeDerivativeTerm () { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void ParseConvectionTerm () { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void ParseDiffusionTerm () { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void ParseSourceTerm () { throw std :: runtime_error ( \"Not implemented.\" ); } // Step advancing. // virtual void BeforeScheme () { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void Scheme () { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void AfterScheme () { throw std :: runtime_error ( \"Not implemented.\" ); } // Matrix solving. // virtual void BeforeSolve () { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void Solve () { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void AfterSolve () { throw std :: runtime_error ( \"Not implemented.\" ); } // Solution access. // std :: optional < LinearEqs > GetLinearEqs () const { throw std :: runtime_error ( \"Not implemented.\" ); } virtual std :: optional < ScalarFieldFp > GetScalarSolutions ( const std :: string & var ) const { throw std :: runtime_error ( \"Not implemented.\" ); } virtual std :: optional < VectorFieldFp > GetVectorSolutions ( const std :: string & var ) const { throw std :: runtime_error ( \"Not implemented.\" ); } virtual std :: optional < TensorFieldFp > GetTensorSolutions ( const std :: string & var ) const { throw std :: runtime_error ( \"Not implemented.\" ); } }; } // namespace OpenOasis::CommImp::Numeric","title":"File Solver.h"},{"location":"models/_solver_8h_source/#file-solverh","text":"File List > CommImp > Numeric > Solver.h Go to the documentation of this file #pragma once #include \"Boundary.h\" #include \"Source.h\" #include \"Operator.h\" #include \"Matrix.h\" #include <optional> namespace OpenOasis :: CommImp :: Numeric { using Utils :: real ; enum class SolverStatus { Created , Initialized , Parsed , Discretized , Updated , Solved , Failed }; class Solver { public : // Configuration and initialization. // virtual void SetBoundary ( int faceIndex , const std :: shared_ptr < Boundary > & bound ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetInitialValue ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real >> & value ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetInitialValue ( const std :: string & var , const ScalarFieldFp & values ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetInitialValue ( const std :: string & var , const VectorFieldFp & values ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetInitialValue ( const std :: string & var , const TensorFieldFp & values ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetCoefficient ( const std :: string & var , const std :: variant < real , Vector < real > , Tensor < real >> & coeff ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetCoefficient ( const std :: string & var , const ScalarFieldFp & coeffs ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetCoefficient ( const std :: string & var , const VectorFieldFp & coeffs ) { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void SetCoefficient ( const std :: string & var , const TensorFieldFp & coeffs ) { throw std :: runtime_error ( \"Not implemented.\" ); } // Equation parsing and discretizing. // virtual void ParseTimeDerivativeTerm () { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void ParseConvectionTerm () { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void ParseDiffusionTerm () { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void ParseSourceTerm () { throw std :: runtime_error ( \"Not implemented.\" ); } // Step advancing. // virtual void BeforeScheme () { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void Scheme () { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void AfterScheme () { throw std :: runtime_error ( \"Not implemented.\" ); } // Matrix solving. // virtual void BeforeSolve () { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void Solve () { throw std :: runtime_error ( \"Not implemented.\" ); } virtual void AfterSolve () { throw std :: runtime_error ( \"Not implemented.\" ); } // Solution access. // std :: optional < LinearEqs > GetLinearEqs () const { throw std :: runtime_error ( \"Not implemented.\" ); } virtual std :: optional < ScalarFieldFp > GetScalarSolutions ( const std :: string & var ) const { throw std :: runtime_error ( \"Not implemented.\" ); } virtual std :: optional < VectorFieldFp > GetVectorSolutions ( const std :: string & var ) const { throw std :: runtime_error ( \"Not implemented.\" ); } virtual std :: optional < TensorFieldFp > GetTensorSolutions ( const std :: string & var ) const { throw std :: runtime_error ( \"Not implemented.\" ); } }; } // namespace OpenOasis::CommImp::Numeric","title":"File Solver.h"},{"location":"models/_source_8h/","text":"File Source.h \u00b6 FileList > CommImp > Numeric > Source.h Go to the source code of this file #include <vector> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric Classes \u00b6 Type Name class Source The documentation for this class was generated from the following file Models/CommImp/Numeric/Source.h","title":"File Source.h"},{"location":"models/_source_8h/#file-sourceh","text":"FileList > CommImp > Numeric > Source.h Go to the source code of this file #include <vector>","title":"File Source.h"},{"location":"models/_source_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric","title":"Namespaces"},{"location":"models/_source_8h/#classes","text":"Type Name class Source The documentation for this class was generated from the following file Models/CommImp/Numeric/Source.h","title":"Classes"},{"location":"models/_source_8h_source/","text":"File Source.h \u00b6 File List > CommImp > Numeric > Source.h Go to the documentation of this file #pragma once #include <vector> namespace OpenOasis :: CommImp :: Numeric { class Source { public : virtual std :: vector < double > GetSource () = 0 ; }; } // namespace OpenOasis::CommImp::Numeric","title":"File Source.h"},{"location":"models/_source_8h_source/#file-sourceh","text":"File List > CommImp > Numeric > Source.h Go to the documentation of this file #pragma once #include <vector> namespace OpenOasis :: CommImp :: Numeric { class Source { public : virtual std :: vector < double > GetSource () = 0 ; }; } // namespace OpenOasis::CommImp::Numeric","title":"File Source.h"},{"location":"models/_tensor_8h/","text":"File Tensor.h \u00b6 FileList > CommImp > Numeric > Tensor.h Go to the source code of this file #include \"Models/Utils/CommMacros.h\" #include <array> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric Classes \u00b6 Type Name class Tensor <typename T> The documentation for this class was generated from the following file Models/CommImp/Numeric/Tensor.h","title":"File Tensor.h"},{"location":"models/_tensor_8h/#file-tensorh","text":"FileList > CommImp > Numeric > Tensor.h Go to the source code of this file #include \"Models/Utils/CommMacros.h\" #include <array>","title":"File Tensor.h"},{"location":"models/_tensor_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric","title":"Namespaces"},{"location":"models/_tensor_8h/#classes","text":"Type Name class Tensor <typename T> The documentation for this class was generated from the following file Models/CommImp/Numeric/Tensor.h","title":"Classes"},{"location":"models/_tensor_8h_source/","text":"File Tensor.h \u00b6 File List > CommImp > Numeric > Tensor.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommMacros.h\" #include <array> namespace OpenOasis { namespace CommImp { namespace Numeric { template < typename T , std :: size_t N > class Vector ; template < typename T > class Tensor { private : std :: array < T , 9 > mElement ; public : static_assert ( std :: is_arithmetic < T >:: value , \"Tensor requires arithmetic types\" ); Tensor () { mElement . fill ( static_cast < T > ( 0 )); } Tensor ( const Tensor & other ) { mElement = other . mElement ; } template < typename ... Args > Tensor ( Args ... args ) { static_assert ( sizeof ...( args ) == 9 , \"Invalid number of parameters.\" ); SetAt ( 0 , args ...); } template < typename U > Tensor ( const std :: initializer_list < U > & lst ) { Set ( lst ); } // Methods for tensor data setting. // void Set ( const Tensor & other ) { for ( std :: size_t i = 0 ; i < 9 ; ++ i ) { std :: size_t j = i % 3 ; mElement [ i ] = other ( i / 3 , j ); } } template < typename ... Args > void SetAt ( std :: size_t i , T v , Args ... args ) { mElement . at ( i ) = v ; SetAt ( i + 1 , args ...); } void SetAt ( std :: size_t i , T v ) { mElement . at ( i ) = v ; } void SetAt ( std :: size_t i , std :: size_t j , T v ) { mElement . at ( i * 3 + j ) = v ; } void SetAt ( std :: size_t i , const Vector < T , 3 > & vec ) { for ( std :: size_t j = 0 ; j < 3 ; ++ j ) mElement . at ( i * 3 + j ) = vec ( j ); } template < typename U > void Set ( const std :: initializer_list < U > & lst ) { OO_ASSERT ( lst . size () >= 9 ); std :: size_t i = 0 ; for ( const auto & v : lst ) mElement . at ( i ++ ) = static_cast < T > ( v ); } constexpr std :: size_t Size () const { return 3 ; } T & operator ()( std :: size_t i , std :: size_t j ) { return mElement . at ( i * 3 + j ); } const T & operator ()( std :: size_t i , std :: size_t j ) const { return mElement . at ( i * 3 + j ); } // Methods for tensor attributes query. // T Sum () const { T ret = 0 ; for ( T val : mElement ) ret += val ; return ret ; } T Avg () const { return Sum () / static_cast < T > ( 9 ); } T Min () const { T ret = mElement . front (); for ( T val : mElement ) ret = std :: min ( ret , val ); return ret ; } T AbsMin () const { T ret = mElement . front (); for ( T val : mElement ) ret = ( ret * ret < val * val ) ? ret : val ; return ret ; } T Max () const { T ret = mElement . front (); for ( T val : mElement ) ret = std :: max ( ret , val ); return ret ; } T AbsMax () const { T ret = mElement . front (); for ( T val : mElement ) ret = ( ret * ret > val * val ) ? ret : val ; return ret ; } T Length () const { return std :: sqrt ( DDot ( * this )); } bool IsEqual ( const Tensor & other ) const { for ( std :: size_t i = 0 ; i < 9 ; ++ i ) { if ( abs ( mElement [ i ] - other ( i / 3 , i % 3 )) > T ( 1e-10 )) return false ; } return true ; } // Methods for tensor operations. // void Normalize () { T len = Length (); if ( len <= T ( 0 )) return ; Div ( len ); } void Add ( T v ) { for ( T & val : mElement ) val += v ; } void Add ( const Tensor & other ) { for ( std :: size_t i = 0 ; i < 9 ; ++ i ) mElement [ i ] += other ( i / 3 , i % 3 ); } void Sub ( T v ) { for ( T & val : mElement ) val -= v ; } void Sub ( const Tensor & other ) { for ( std :: size_t i = 0 ; i < 9 ; ++ i ) mElement [ i ] -= other ( i / 3 , i % 3 ); } void Mul ( T v ) { for ( T & val : mElement ) val *= v ; } void Div ( T v ) { OO_ASSERT ( v != T ( 0 )); for ( T & val : mElement ) val /= v ; } Vector < T , 3 > Dot ( const Vector < T , 3 > & other ) const { Vector < T , 3 > ret ; for ( std :: size_t i = 0 ; i < 3 ; ++ i ) { ret ( i ) = mElement [ i * 3 ] * other ( 0 ) + mElement [ i * 3 + 1 ] * other ( 1 ) + mElement [ i * 3 + 2 ] * other ( 2 ); } return ret ; } T DDot ( const Tensor & other ) const { T ret = 0 ; for ( std :: size_t i = 0 ; i < 3 ; ++ i ) { for ( std :: size_t j = 0 ; j < 3 ; ++ j ) { ret += mElement [ i * 3 + j ] * other ( j , i ); } } return ret ; } // Override operators for tensor. // void operator = ( const Tensor & other ) { mElement = other . mElement ; } Tensor operator + ( const Tensor & other ) const { Tensor ret ( * this ); ret . Add ( other ); return ret ; } Tensor operator + ( T v ) const { Tensor ret ( * this ); ret . Add ( v ); return ret ; } Tensor & operator += ( const Tensor & other ) { Add ( other ); return * this ; } Tensor & operator += ( T v ) { Add ( v ); return * this ; } Tensor operator - ( const Tensor & other ) const { Tensor ret ( * this ); ret . Sub ( other ); return ret ; } Tensor operator - ( T v ) const { Tensor ret ( * this ); ret . Sub ( v ); return ret ; } Tensor & operator -= ( const Tensor & other ) { Sub ( other ); return * this ; } Tensor & operator -= ( T v ) { Sub ( v ); return * this ; } Vector < T , 3 > operator * ( const Vector < T , 3 > & other ) const { return Dot ( other ); } T operator * ( const Tensor & other ) const { return DDot ( other ); } }; } // namespace Numeric } // namespace CommImp } // namespace OpenOasis","title":"File Tensor.h"},{"location":"models/_tensor_8h_source/#file-tensorh","text":"File List > CommImp > Numeric > Tensor.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommMacros.h\" #include <array> namespace OpenOasis { namespace CommImp { namespace Numeric { template < typename T , std :: size_t N > class Vector ; template < typename T > class Tensor { private : std :: array < T , 9 > mElement ; public : static_assert ( std :: is_arithmetic < T >:: value , \"Tensor requires arithmetic types\" ); Tensor () { mElement . fill ( static_cast < T > ( 0 )); } Tensor ( const Tensor & other ) { mElement = other . mElement ; } template < typename ... Args > Tensor ( Args ... args ) { static_assert ( sizeof ...( args ) == 9 , \"Invalid number of parameters.\" ); SetAt ( 0 , args ...); } template < typename U > Tensor ( const std :: initializer_list < U > & lst ) { Set ( lst ); } // Methods for tensor data setting. // void Set ( const Tensor & other ) { for ( std :: size_t i = 0 ; i < 9 ; ++ i ) { std :: size_t j = i % 3 ; mElement [ i ] = other ( i / 3 , j ); } } template < typename ... Args > void SetAt ( std :: size_t i , T v , Args ... args ) { mElement . at ( i ) = v ; SetAt ( i + 1 , args ...); } void SetAt ( std :: size_t i , T v ) { mElement . at ( i ) = v ; } void SetAt ( std :: size_t i , std :: size_t j , T v ) { mElement . at ( i * 3 + j ) = v ; } void SetAt ( std :: size_t i , const Vector < T , 3 > & vec ) { for ( std :: size_t j = 0 ; j < 3 ; ++ j ) mElement . at ( i * 3 + j ) = vec ( j ); } template < typename U > void Set ( const std :: initializer_list < U > & lst ) { OO_ASSERT ( lst . size () >= 9 ); std :: size_t i = 0 ; for ( const auto & v : lst ) mElement . at ( i ++ ) = static_cast < T > ( v ); } constexpr std :: size_t Size () const { return 3 ; } T & operator ()( std :: size_t i , std :: size_t j ) { return mElement . at ( i * 3 + j ); } const T & operator ()( std :: size_t i , std :: size_t j ) const { return mElement . at ( i * 3 + j ); } // Methods for tensor attributes query. // T Sum () const { T ret = 0 ; for ( T val : mElement ) ret += val ; return ret ; } T Avg () const { return Sum () / static_cast < T > ( 9 ); } T Min () const { T ret = mElement . front (); for ( T val : mElement ) ret = std :: min ( ret , val ); return ret ; } T AbsMin () const { T ret = mElement . front (); for ( T val : mElement ) ret = ( ret * ret < val * val ) ? ret : val ; return ret ; } T Max () const { T ret = mElement . front (); for ( T val : mElement ) ret = std :: max ( ret , val ); return ret ; } T AbsMax () const { T ret = mElement . front (); for ( T val : mElement ) ret = ( ret * ret > val * val ) ? ret : val ; return ret ; } T Length () const { return std :: sqrt ( DDot ( * this )); } bool IsEqual ( const Tensor & other ) const { for ( std :: size_t i = 0 ; i < 9 ; ++ i ) { if ( abs ( mElement [ i ] - other ( i / 3 , i % 3 )) > T ( 1e-10 )) return false ; } return true ; } // Methods for tensor operations. // void Normalize () { T len = Length (); if ( len <= T ( 0 )) return ; Div ( len ); } void Add ( T v ) { for ( T & val : mElement ) val += v ; } void Add ( const Tensor & other ) { for ( std :: size_t i = 0 ; i < 9 ; ++ i ) mElement [ i ] += other ( i / 3 , i % 3 ); } void Sub ( T v ) { for ( T & val : mElement ) val -= v ; } void Sub ( const Tensor & other ) { for ( std :: size_t i = 0 ; i < 9 ; ++ i ) mElement [ i ] -= other ( i / 3 , i % 3 ); } void Mul ( T v ) { for ( T & val : mElement ) val *= v ; } void Div ( T v ) { OO_ASSERT ( v != T ( 0 )); for ( T & val : mElement ) val /= v ; } Vector < T , 3 > Dot ( const Vector < T , 3 > & other ) const { Vector < T , 3 > ret ; for ( std :: size_t i = 0 ; i < 3 ; ++ i ) { ret ( i ) = mElement [ i * 3 ] * other ( 0 ) + mElement [ i * 3 + 1 ] * other ( 1 ) + mElement [ i * 3 + 2 ] * other ( 2 ); } return ret ; } T DDot ( const Tensor & other ) const { T ret = 0 ; for ( std :: size_t i = 0 ; i < 3 ; ++ i ) { for ( std :: size_t j = 0 ; j < 3 ; ++ j ) { ret += mElement [ i * 3 + j ] * other ( j , i ); } } return ret ; } // Override operators for tensor. // void operator = ( const Tensor & other ) { mElement = other . mElement ; } Tensor operator + ( const Tensor & other ) const { Tensor ret ( * this ); ret . Add ( other ); return ret ; } Tensor operator + ( T v ) const { Tensor ret ( * this ); ret . Add ( v ); return ret ; } Tensor & operator += ( const Tensor & other ) { Add ( other ); return * this ; } Tensor & operator += ( T v ) { Add ( v ); return * this ; } Tensor operator - ( const Tensor & other ) const { Tensor ret ( * this ); ret . Sub ( other ); return ret ; } Tensor operator - ( T v ) const { Tensor ret ( * this ); ret . Sub ( v ); return ret ; } Tensor & operator -= ( const Tensor & other ) { Sub ( other ); return * this ; } Tensor & operator -= ( T v ) { Sub ( v ); return * this ; } Vector < T , 3 > operator * ( const Vector < T , 3 > & other ) const { return Dot ( other ); } T operator * ( const Tensor & other ) const { return DDot ( other ); } }; } // namespace Numeric } // namespace CommImp } // namespace OpenOasis","title":"File Tensor.h"},{"location":"models/_tensor_field_8h/","text":"File TensorField.h \u00b6 FileList > CommImp > Numeric > TensorField.h Go to the source code of this file #include \"Models/Utils/CommConstants.h\" #include \"Field.h\" #include \"Tensor.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric Classes \u00b6 Type Name class TensorField <typename T> Tensor field. The documentation for this class was generated from the following file Models/CommImp/Numeric/TensorField.h","title":"File TensorField.h"},{"location":"models/_tensor_field_8h/#file-tensorfieldh","text":"FileList > CommImp > Numeric > TensorField.h Go to the source code of this file #include \"Models/Utils/CommConstants.h\" #include \"Field.h\" #include \"Tensor.h\"","title":"File TensorField.h"},{"location":"models/_tensor_field_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric","title":"Namespaces"},{"location":"models/_tensor_field_8h/#classes","text":"Type Name class TensorField <typename T> Tensor field. The documentation for this class was generated from the following file Models/CommImp/Numeric/TensorField.h","title":"Classes"},{"location":"models/_tensor_field_8h_source/","text":"File TensorField.h \u00b6 File List > CommImp > Numeric > TensorField.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommConstants.h\" #include \"Field.h\" #include \"Tensor.h\" namespace OpenOasis :: CommImp :: Numeric { template < typename T > class TensorField : public Field < Tensor < T >> { public : virtual ~ TensorField () = default ; TensorField ( FieldDomain domain = FieldDomain :: CELL ) { this -> mDomain = domain ; this -> mType = FieldType :: TENSOR ; } TensorField ( std :: size_t size , const Tensor < T > & val = {}, FieldDomain domain = FieldDomain :: CELL ) : Field < Tensor < T >> ( size , val ) { this -> mDomain = domain ; this -> mType = FieldType :: TENSOR ; } }; using TensorFieldDbl = TensorField < double > ; using TensorFieldInt = TensorField < int > ; using TensorFieldFp = TensorField < Utils :: real > ; } // namespace OpenOasis::CommImp::Numeric","title":"File TensorField.h"},{"location":"models/_tensor_field_8h_source/#file-tensorfieldh","text":"File List > CommImp > Numeric > TensorField.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommConstants.h\" #include \"Field.h\" #include \"Tensor.h\" namespace OpenOasis :: CommImp :: Numeric { template < typename T > class TensorField : public Field < Tensor < T >> { public : virtual ~ TensorField () = default ; TensorField ( FieldDomain domain = FieldDomain :: CELL ) { this -> mDomain = domain ; this -> mType = FieldType :: TENSOR ; } TensorField ( std :: size_t size , const Tensor < T > & val = {}, FieldDomain domain = FieldDomain :: CELL ) : Field < Tensor < T >> ( size , val ) { this -> mDomain = domain ; this -> mType = FieldType :: TENSOR ; } }; using TensorFieldDbl = TensorField < double > ; using TensorFieldInt = TensorField < int > ; using TensorFieldFp = TensorField < Utils :: real > ; } // namespace OpenOasis::CommImp::Numeric","title":"File TensorField.h"},{"location":"models/_vector_8h/","text":"File Vector.h \u00b6 FileList > CommImp > Numeric > Vector.h Go to the source code of this file #include \"Models/Utils/CommMacros.h\" #include \"Tensor.h\" #include <array> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric Classes \u00b6 Type Name class Vector <typename T, N> The documentation for this class was generated from the following file Models/CommImp/Numeric/Vector.h","title":"File Vector.h"},{"location":"models/_vector_8h/#file-vectorh","text":"FileList > CommImp > Numeric > Vector.h Go to the source code of this file #include \"Models/Utils/CommMacros.h\" #include \"Tensor.h\" #include <array>","title":"File Vector.h"},{"location":"models/_vector_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric","title":"Namespaces"},{"location":"models/_vector_8h/#classes","text":"Type Name class Vector <typename T, N> The documentation for this class was generated from the following file Models/CommImp/Numeric/Vector.h","title":"Classes"},{"location":"models/_vector_8h_source/","text":"File Vector.h \u00b6 File List > CommImp > Numeric > Vector.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommMacros.h\" #include \"Tensor.h\" #include <array> namespace OpenOasis { namespace CommImp { namespace Numeric { template < typename T , size_t N = 3 > class Vector { public : static_assert ( N > 0 , \"Size of static-sized vector should be greater than zero.\" ); static_assert ( std :: is_arithmetic < T >:: value , \"Vector only can be instantiated with arithmetic types\" ); private : std :: array < T , N > mElement ; public : virtual ~ Vector () = default ; Vector () { mElement . fill ( static_cast < T > ( 0 )); } Vector ( const Vector & other ) { mElement = other . mElement ; } Vector ( const std :: array < T , N > & other ) { mElement = other ; } template < typename ... Args > Vector ( Args ... args ) { static_assert ( sizeof ...( args ) == N , \"Invalid number of parameters.\" ); SetAt ( 0 , args ...); } template < typename U > Vector ( const std :: initializer_list < U > & lst ) { Set ( lst ); } // Methods for vector data setting. // template < typename U > void Set ( const std :: initializer_list < U > & lst ) { OO_ASSERT ( lst . size () >= N ); size_t i = 0 ; for ( const auto & val : lst ) mElement . at ( i ++ ) = static_cast < T > ( val ); } void Set ( const Vector & other ) { for ( size_t i = 0 ; i < N ; ++ i ) { mElement [ i ] = other ( i ); } } template < typename ... Args > void SetAt ( size_t i , T v , Args ... args ) { mElement . at ( i ) = v ; SetAt ( i + 1 , args ...); } void SetAt ( size_t i , T v ) { mElement . at ( i ) = v ; } constexpr size_t Size () const { return N ; } T & operator ()( size_t i ) { return mElement . at ( i ); } const T & operator ()( size_t i ) const { return mElement . at ( i ); } // Methods for vector attributes query. // T Sum () const { T ret = 0 ; for ( T val : mElement ) ret += val ; return ret ; } T Avg () const { return Sum () / static_cast < T > ( N ); } T Min () const { T ret = mElement . front (); for ( T val : mElement ) ret = std :: min ( ret , val ); return ret ; } T AbsMin () const { T ret = mElement . front (); for ( T val : mElement ) ret = ( ret * ret < val * val ) ? ret : val ; return ret ; } T Max () const { T ret = mElement . front (); for ( T val : mElement ) ret = std :: max ( ret , val ); return ret ; } T AbsMax () const { T ret = mElement . front (); for ( T val : mElement ) ret = ( ret * ret > val * val ) ? ret : val ; return ret ; } T Length () const { return std :: sqrt ( Dot ( * this )); } bool IsEqual ( const Vector & other ) const { if ( Size () != other . Size ()) return false ; for ( size_t i = 0 ; i < N ; ++ i ) { if ( abs ( mElement [ i ] - other ( i )) > T ( 1e-10 )) return false ; } return true ; } // Methods for vector operations. // void Normalize () { T len = Length (); if ( len <= T ( 0 )) return ; Div ( len ); } void Add ( T v ) { for ( T & val : mElement ) val += v ; } void Add ( const Vector & other ) { OO_ASSERT ( other . Size () == N ); for ( size_t i = 0 ; i < N ; ++ i ) mElement [ i ] += other ( i ); } void Sub ( T v ) { for ( T & val : mElement ) val -= v ; } void Sub ( const Vector & other ) { OO_ASSERT ( other . Size () == N ); for ( size_t i = 0 ; i < N ; ++ i ) mElement [ i ] -= other ( i ); } void Mul ( T v ) { for ( T & val : mElement ) val *= v ; } void Div ( T v ) { OO_ASSERT ( v != T ( 0 )); for ( T & val : mElement ) val /= v ; } T Dot ( const Vector & other ) const { OO_ASSERT ( other . Size () == N ); T ret = 0 ; for ( size_t i = 0 ; i < N ; ++ i ) ret += mElement [ i ] * other ( i ); return ret ; } Vector Cross ( const Vector & other ) const { OO_ASSERT ( other . Size () == 3 ); OO_ASSERT ( N == 3 ); Vector ret ; ret ( 0 ) = mElement [ 1 ] * other ( 2 ) - mElement [ 2 ] * other ( 1 ); ret ( 1 ) = mElement [ 2 ] * other ( 0 ) - mElement [ 0 ] * other ( 2 ); ret ( 2 ) = mElement [ 0 ] * other ( 1 ) - mElement [ 1 ] * other ( 0 ); return ret ; } Tensor < T > Dyadic ( const Vector & other ) const { OO_ASSERT ( other . Size () == 3 ); OO_ASSERT ( N == 3 ); Tensor < T > ret ; ret . SetAt ( 0 , other * mElement [ 0 ]); ret . SetAt ( 1 , other * mElement [ 1 ]); ret . SetAt ( 2 , other * mElement [ 2 ]); return ret ; } // Override operators for vector. // void operator = ( const Vector & other ) { mElement = other . mElement ; } Vector operator + ( const Vector & other ) const { Vector ret ( * this ); ret . Add ( other ); return ret ; } Vector operator + ( T v ) const { Vector ret ( * this ); ret . Add ( v ); return ret ; } Vector & operator += ( const Vector & other ) { Add ( other ); return * this ; } Vector & operator += ( T v ) { Add ( v ); return * this ; } Vector operator - ( const Vector & other ) const { Vector ret ( * this ); ret . Sub ( other ); return ret ; } Vector operator - ( T v ) const { Vector ret ( * this ); ret . Sub ( v ); return ret ; } Vector & operator -= ( const Vector & other ) { Sub ( other ); return * this ; } Vector & operator -= ( T v ) { Sub ( v ); return * this ; } Vector operator * ( T v ) const { Vector ret ( * this ); ret . Mul ( v ); return ret ; } T operator * ( const Vector & other ) const { return Dot ( other ); } Vector & operator *= ( T v ) { Mul ( v ); return * this ; } Vector operator & ( const Vector & other ) const { return Cross ( other ); } Vector & operator &= ( const Vector & other ) { Set ( Cross ( other )); return * this ; } Tensor < T > operator ^ ( const Vector & other ) const { return Dyadic ( other ); } bool operator == ( const Vector & other ) const { return IsEqual ( other ); } bool operator != ( const Vector & other ) const { return ! IsEqual ( other ); } }; } // namespace Numeric } // namespace CommImp } // namespace OpenOasis","title":"File Vector.h"},{"location":"models/_vector_8h_source/#file-vectorh","text":"File List > CommImp > Numeric > Vector.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommMacros.h\" #include \"Tensor.h\" #include <array> namespace OpenOasis { namespace CommImp { namespace Numeric { template < typename T , size_t N = 3 > class Vector { public : static_assert ( N > 0 , \"Size of static-sized vector should be greater than zero.\" ); static_assert ( std :: is_arithmetic < T >:: value , \"Vector only can be instantiated with arithmetic types\" ); private : std :: array < T , N > mElement ; public : virtual ~ Vector () = default ; Vector () { mElement . fill ( static_cast < T > ( 0 )); } Vector ( const Vector & other ) { mElement = other . mElement ; } Vector ( const std :: array < T , N > & other ) { mElement = other ; } template < typename ... Args > Vector ( Args ... args ) { static_assert ( sizeof ...( args ) == N , \"Invalid number of parameters.\" ); SetAt ( 0 , args ...); } template < typename U > Vector ( const std :: initializer_list < U > & lst ) { Set ( lst ); } // Methods for vector data setting. // template < typename U > void Set ( const std :: initializer_list < U > & lst ) { OO_ASSERT ( lst . size () >= N ); size_t i = 0 ; for ( const auto & val : lst ) mElement . at ( i ++ ) = static_cast < T > ( val ); } void Set ( const Vector & other ) { for ( size_t i = 0 ; i < N ; ++ i ) { mElement [ i ] = other ( i ); } } template < typename ... Args > void SetAt ( size_t i , T v , Args ... args ) { mElement . at ( i ) = v ; SetAt ( i + 1 , args ...); } void SetAt ( size_t i , T v ) { mElement . at ( i ) = v ; } constexpr size_t Size () const { return N ; } T & operator ()( size_t i ) { return mElement . at ( i ); } const T & operator ()( size_t i ) const { return mElement . at ( i ); } // Methods for vector attributes query. // T Sum () const { T ret = 0 ; for ( T val : mElement ) ret += val ; return ret ; } T Avg () const { return Sum () / static_cast < T > ( N ); } T Min () const { T ret = mElement . front (); for ( T val : mElement ) ret = std :: min ( ret , val ); return ret ; } T AbsMin () const { T ret = mElement . front (); for ( T val : mElement ) ret = ( ret * ret < val * val ) ? ret : val ; return ret ; } T Max () const { T ret = mElement . front (); for ( T val : mElement ) ret = std :: max ( ret , val ); return ret ; } T AbsMax () const { T ret = mElement . front (); for ( T val : mElement ) ret = ( ret * ret > val * val ) ? ret : val ; return ret ; } T Length () const { return std :: sqrt ( Dot ( * this )); } bool IsEqual ( const Vector & other ) const { if ( Size () != other . Size ()) return false ; for ( size_t i = 0 ; i < N ; ++ i ) { if ( abs ( mElement [ i ] - other ( i )) > T ( 1e-10 )) return false ; } return true ; } // Methods for vector operations. // void Normalize () { T len = Length (); if ( len <= T ( 0 )) return ; Div ( len ); } void Add ( T v ) { for ( T & val : mElement ) val += v ; } void Add ( const Vector & other ) { OO_ASSERT ( other . Size () == N ); for ( size_t i = 0 ; i < N ; ++ i ) mElement [ i ] += other ( i ); } void Sub ( T v ) { for ( T & val : mElement ) val -= v ; } void Sub ( const Vector & other ) { OO_ASSERT ( other . Size () == N ); for ( size_t i = 0 ; i < N ; ++ i ) mElement [ i ] -= other ( i ); } void Mul ( T v ) { for ( T & val : mElement ) val *= v ; } void Div ( T v ) { OO_ASSERT ( v != T ( 0 )); for ( T & val : mElement ) val /= v ; } T Dot ( const Vector & other ) const { OO_ASSERT ( other . Size () == N ); T ret = 0 ; for ( size_t i = 0 ; i < N ; ++ i ) ret += mElement [ i ] * other ( i ); return ret ; } Vector Cross ( const Vector & other ) const { OO_ASSERT ( other . Size () == 3 ); OO_ASSERT ( N == 3 ); Vector ret ; ret ( 0 ) = mElement [ 1 ] * other ( 2 ) - mElement [ 2 ] * other ( 1 ); ret ( 1 ) = mElement [ 2 ] * other ( 0 ) - mElement [ 0 ] * other ( 2 ); ret ( 2 ) = mElement [ 0 ] * other ( 1 ) - mElement [ 1 ] * other ( 0 ); return ret ; } Tensor < T > Dyadic ( const Vector & other ) const { OO_ASSERT ( other . Size () == 3 ); OO_ASSERT ( N == 3 ); Tensor < T > ret ; ret . SetAt ( 0 , other * mElement [ 0 ]); ret . SetAt ( 1 , other * mElement [ 1 ]); ret . SetAt ( 2 , other * mElement [ 2 ]); return ret ; } // Override operators for vector. // void operator = ( const Vector & other ) { mElement = other . mElement ; } Vector operator + ( const Vector & other ) const { Vector ret ( * this ); ret . Add ( other ); return ret ; } Vector operator + ( T v ) const { Vector ret ( * this ); ret . Add ( v ); return ret ; } Vector & operator += ( const Vector & other ) { Add ( other ); return * this ; } Vector & operator += ( T v ) { Add ( v ); return * this ; } Vector operator - ( const Vector & other ) const { Vector ret ( * this ); ret . Sub ( other ); return ret ; } Vector operator - ( T v ) const { Vector ret ( * this ); ret . Sub ( v ); return ret ; } Vector & operator -= ( const Vector & other ) { Sub ( other ); return * this ; } Vector & operator -= ( T v ) { Sub ( v ); return * this ; } Vector operator * ( T v ) const { Vector ret ( * this ); ret . Mul ( v ); return ret ; } T operator * ( const Vector & other ) const { return Dot ( other ); } Vector & operator *= ( T v ) { Mul ( v ); return * this ; } Vector operator & ( const Vector & other ) const { return Cross ( other ); } Vector & operator &= ( const Vector & other ) { Set ( Cross ( other )); return * this ; } Tensor < T > operator ^ ( const Vector & other ) const { return Dyadic ( other ); } bool operator == ( const Vector & other ) const { return IsEqual ( other ); } bool operator != ( const Vector & other ) const { return ! IsEqual ( other ); } }; } // namespace Numeric } // namespace CommImp } // namespace OpenOasis","title":"File Vector.h"},{"location":"models/_vector_field_8h/","text":"File VectorField.h \u00b6 FileList > CommImp > Numeric > VectorField.h Go to the source code of this file #include \"Models/Utils/CommConstants.h\" #include \"Field.h\" #include \"Vector.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Numeric Classes \u00b6 Type Name class VectorField <typename T, N> Vector field with default zero vector in 2D or 3D space. The documentation for this class was generated from the following file Models/CommImp/Numeric/VectorField.h","title":"File VectorField.h"},{"location":"models/_vector_field_8h/#file-vectorfieldh","text":"FileList > CommImp > Numeric > VectorField.h Go to the source code of this file #include \"Models/Utils/CommConstants.h\" #include \"Field.h\" #include \"Vector.h\"","title":"File VectorField.h"},{"location":"models/_vector_field_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Numeric","title":"Namespaces"},{"location":"models/_vector_field_8h/#classes","text":"Type Name class VectorField <typename T, N> Vector field with default zero vector in 2D or 3D space. The documentation for this class was generated from the following file Models/CommImp/Numeric/VectorField.h","title":"Classes"},{"location":"models/_vector_field_8h_source/","text":"File VectorField.h \u00b6 File List > CommImp > Numeric > VectorField.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommConstants.h\" #include \"Field.h\" #include \"Vector.h\" namespace OpenOasis :: CommImp :: Numeric { template < typename T , std :: size_t N = 3 > class VectorField : public Field < Vector < T , N >> { public : virtual ~ VectorField () = default ; VectorField ( FieldDomain domain = FieldDomain :: CELL ) { this -> mDomain = domain ; this -> mType = FieldType :: VECTOR ; } VectorField ( std :: size_t size , const Vector < T , N > & val = {}, FieldDomain domain = FieldDomain :: CELL ) : Field < Vector < T , N >> ( size , val ) { this -> mDomain = domain ; this -> mType = FieldType :: VECTOR ; } }; using VectorFieldInt3D = VectorField < int , 3 > ; using VectorFieldInt2D = VectorField < int , 2 > ; using VectorFieldDbl3D = VectorField < double , 3 > ; using VectorFieldDbl2D = VectorField < double , 2 > ; using VectorFieldFp = VectorField < Utils :: real , 3 > ; } // namespace OpenOasis::CommImp::Numeric","title":"File VectorField.h"},{"location":"models/_vector_field_8h_source/#file-vectorfieldh","text":"File List > CommImp > Numeric > VectorField.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommConstants.h\" #include \"Field.h\" #include \"Vector.h\" namespace OpenOasis :: CommImp :: Numeric { template < typename T , std :: size_t N = 3 > class VectorField : public Field < Vector < T , N >> { public : virtual ~ VectorField () = default ; VectorField ( FieldDomain domain = FieldDomain :: CELL ) { this -> mDomain = domain ; this -> mType = FieldType :: VECTOR ; } VectorField ( std :: size_t size , const Vector < T , N > & val = {}, FieldDomain domain = FieldDomain :: CELL ) : Field < Vector < T , N >> ( size , val ) { this -> mDomain = domain ; this -> mType = FieldType :: VECTOR ; } }; using VectorFieldInt3D = VectorField < int , 3 > ; using VectorFieldInt2D = VectorField < int , 2 > ; using VectorFieldDbl3D = VectorField < double , 3 > ; using VectorFieldDbl2D = VectorField < double , 2 > ; using VectorFieldFp = VectorField < Utils :: real , 3 > ; } // namespace OpenOasis::CommImp::Numeric","title":"File VectorField.h"},{"location":"models/dir_47a0bcc12c466f07097ed8db741700fa/","text":"Dir Models/CommImp/Spatial \u00b6 FileList > CommImp > Spatial Files \u00b6 Type Name file Coordinate.cpp file Coordinate.h file GeoCalculator.cpp file GeoCalculator.h file Grid.cpp file Grid.h file Grid1D.cpp file Grid1D.h file Grid2D.cpp file Grid2D.h file Grid3D.cpp file Grid3D.h file MeshStructs.h file XYGeoStructs.cpp file XYGeoStructs.h file XYGeoTools.cpp file XYGeoTools.h The documentation for this class was generated from the following file Models/CommImp/Spatial/","title":"Dir Models/CommImp/Spatial"},{"location":"models/dir_47a0bcc12c466f07097ed8db741700fa/#dir-modelscommimpspatial","text":"FileList > CommImp > Spatial","title":"Dir Models/CommImp/Spatial"},{"location":"models/dir_47a0bcc12c466f07097ed8db741700fa/#files","text":"Type Name file Coordinate.cpp file Coordinate.h file GeoCalculator.cpp file GeoCalculator.h file Grid.cpp file Grid.h file Grid1D.cpp file Grid1D.h file Grid2D.cpp file Grid2D.h file Grid3D.cpp file Grid3D.h file MeshStructs.h file XYGeoStructs.cpp file XYGeoStructs.h file XYGeoTools.cpp file XYGeoTools.h The documentation for this class was generated from the following file Models/CommImp/Spatial/","title":"Files"},{"location":"models/_coordinate_8cpp/","text":"File Coordinate.cpp \u00b6 FileList > CommImp > Spatial > Coordinate.cpp Go to the source code of this file #include \"Coordinate.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/Coordinate.cpp","title":"File Coordinate.cpp"},{"location":"models/_coordinate_8cpp/#file-coordinatecpp","text":"FileList > CommImp > Spatial > Coordinate.cpp Go to the source code of this file #include \"Coordinate.h\"","title":"File Coordinate.cpp"},{"location":"models/_coordinate_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/Coordinate.cpp","title":"Namespaces"},{"location":"models/_coordinate_8cpp_source/","text":"File Coordinate.cpp \u00b6 File List > CommImp > Spatial > Coordinate.cpp Go to the documentation of this file #include \"Coordinate.h\" namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; bool Coordinate::Equals ( real coorX , real coorY , real coorZ ) const { return Equals ({ coorX , coorY , coorZ }); } bool Coordinate::Equals ( const Coordinate & coor ) const { if ( ! IsEql ( x , coor . x ) || ! IsEql ( y , coor . y ) || ! IsEql ( z , coor . z )) return false ; return true ; } } // namespace OpenOasis::CommImp::Spatial","title":"File Coordinate.cpp"},{"location":"models/_coordinate_8cpp_source/#file-coordinatecpp","text":"File List > CommImp > Spatial > Coordinate.cpp Go to the documentation of this file #include \"Coordinate.h\" namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; bool Coordinate::Equals ( real coorX , real coorY , real coorZ ) const { return Equals ({ coorX , coorY , coorZ }); } bool Coordinate::Equals ( const Coordinate & coor ) const { if ( ! IsEql ( x , coor . x ) || ! IsEql ( y , coor . y ) || ! IsEql ( z , coor . z )) return false ; return true ; } } // namespace OpenOasis::CommImp::Spatial","title":"File Coordinate.cpp"},{"location":"models/_coordinate_8h/","text":"File Coordinate.h \u00b6 FileList > CommImp > Spatial > Coordinate.h Go to the source code of this file #include \"Models/Utils/CommConstants.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial Classes \u00b6 Type Name struct Coordinate The Coordinate struct contains a (x, y, z) coordinate. The documentation for this class was generated from the following file Models/CommImp/Spatial/Coordinate.h","title":"File Coordinate.h"},{"location":"models/_coordinate_8h/#file-coordinateh","text":"FileList > CommImp > Spatial > Coordinate.h Go to the source code of this file #include \"Models/Utils/CommConstants.h\"","title":"File Coordinate.h"},{"location":"models/_coordinate_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial","title":"Namespaces"},{"location":"models/_coordinate_8h/#classes","text":"Type Name struct Coordinate The Coordinate struct contains a (x, y, z) coordinate. The documentation for this class was generated from the following file Models/CommImp/Spatial/Coordinate.h","title":"Classes"},{"location":"models/_coordinate_8h_source/","text":"File Coordinate.h \u00b6 File List > CommImp > Spatial > Coordinate.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommConstants.h\" namespace OpenOasis :: CommImp :: Spatial { using Utils :: real ; struct Coordinate { real x = 0. ; real y = 0. ; real z = 0. ; bool Equals ( real coorX , real coorY , real coorZ ) const ; bool Equals ( const Coordinate & coor ) const ; }; } // namespace OpenOasis::CommImp::Spatial","title":"File Coordinate.h"},{"location":"models/_coordinate_8h_source/#file-coordinateh","text":"File List > CommImp > Spatial > Coordinate.h Go to the documentation of this file #pragma once #include \"Models/Utils/CommConstants.h\" namespace OpenOasis :: CommImp :: Spatial { using Utils :: real ; struct Coordinate { real x = 0. ; real y = 0. ; real z = 0. ; bool Equals ( real coorX , real coorY , real coorZ ) const ; bool Equals ( const Coordinate & coor ) const ; }; } // namespace OpenOasis::CommImp::Spatial","title":"File Coordinate.h"},{"location":"models/_geo_calculator_8cpp/","text":"File GeoCalculator.cpp \u00b6 FileList > CommImp > Spatial > GeoCalculator.cpp Go to the source code of this file #include \"GeoCalculator.h\" #include \"Models/Utils/Exception.h\" #include <set> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/GeoCalculator.cpp","title":"File GeoCalculator.cpp"},{"location":"models/_geo_calculator_8cpp/#file-geocalculatorcpp","text":"FileList > CommImp > Spatial > GeoCalculator.cpp Go to the source code of this file #include \"GeoCalculator.h\" #include \"Models/Utils/Exception.h\" #include <set>","title":"File GeoCalculator.cpp"},{"location":"models/_geo_calculator_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/GeoCalculator.cpp","title":"Namespaces"},{"location":"models/_geo_calculator_8cpp_source/","text":"File GeoCalculator.cpp \u00b6 File List > CommImp > Spatial > GeoCalculator.cpp Go to the documentation of this file #include \"GeoCalculator.h\" #include \"Models/Utils/Exception.h\" #include <set> namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; vector < int > GeoCalculator :: SortNodes ( const vector < int > & nodeIdxs , const unordered_map < int , Node > & nodes ) { vector < int > sortedIdxs ( nodeIdxs ); // has error. // auto centroid = CalculateCentroid(nodeIdxs, nodes); // int ignoredAxis = ChooseFoldedAxis(nodeIdxs, nodes); // for (int i = 0; i < sortedIdxs.size() - 1; i++) // { // int curr = sortedIdxs[i]; // for (int j = 0; j < sortedIdxs.size() - i - 1; j++) // { // double next = sortedIdxs[j]; // if (CompareNodeOrder(nodes.at(j), nodes.at(j + 1), centroid, // ignoredAxis)) // { // sortedIdxs[j] = next; // sortedIdxs[j + 1] = curr; // } // } // } return sortedIdxs ; } vector < int > GeoCalculator :: SortFaceNodes ( int faceIndex , const Mesh & mesh ) { return SortNodes ( mesh . faces . at ( faceIndex ). nodeIndexes , mesh . nodes ); } int GeoCalculator :: ChooseFoldedAxis ( const vector < int > & nodeIdxs , const unordered_map < int , Node > & nodes ) { int num = nodeIdxs . size (); vector < real > Xs ( num ), Ys ( num ), Zs ( num ); for ( int idx : nodeIdxs ) { const auto & coor = nodes . at ( idx ). coor ; Xs . push_back ( coor . x ); Ys . push_back ( coor . y ); Zs . push_back ( coor . z ); } int axisX = 0 , axisY = 0 , axisZ = 0 ; for ( int i = 0 ; i < num ; ++ i ) { for ( int j = i ; j < num ; ++ j ) { if ( IsSim ( Xs [ i ], Xs [ j ], EPSILON )) axisX += 1 ; if ( IsSim ( Ys [ i ], Ys [ j ], EPSILON )) axisY += 1 ; if ( IsSim ( Zs [ i ], Zs [ j ], EPSILON )) axisZ += 1 ; } } if ( axisX > axisY && axisX > axisZ ) return 0 ; if ( axisY > axisX && axisY > axisZ ) return 1 ; return 2 ; } bool GeoCalculator :: CompareNodeOrder ( const Node & node0 , const Node & node1 , const Coordinate & centroid , int ignoredAxis ) { Coordinate n0 , n1 , o ; if ( ignoredAxis == 2 ) { n0 = { node0 . coor . x , node0 . coor . y , 0 }; n1 = { node1 . coor . x , node1 . coor . y , 0 }; o = { centroid . x , centroid . y , 0 }; } else if ( ignoredAxis == 1 ) { n0 = { node0 . coor . x , node0 . coor . z , 0 }; n1 = { node1 . coor . x , node1 . coor . z , 0 }; o = { centroid . x , centroid . z , 0 }; } else { n0 = { node0 . coor . y , node0 . coor . z , 0 }; n1 = { node1 . coor . y , node1 . coor . z , 0 }; o = { centroid . y , centroid . z , 0 }; } if ( n0 . x >= 0 && n1 . x < 0 ) return true ; if ( n0 . x == 0 && n1 . x == 0 ) return n0 . y > n1 . y ; real dx0 = n0 . x - o . x , dx1 = n1 . x - o . x ; real dy1 = n0 . y - o . y , dy0 = n1 . y - o . y ; int det = dx0 * dy1 - dx1 * dy0 ; if ( det < 0 ) return true ; if ( det > 0 ) return false ; int dist0 = dx0 * dx0 + dy0 * dy0 ; int dist1 = dx1 * dx1 + dy1 * dy1 ; return dist0 > dist1 ; } Coordinate GeoCalculator :: CalculateCentroid ( const vector < int > & nodeIdxs , const unordered_map < int , Node > & nodes ) { if ( nodeIdxs . empty ()) return {}; real sumX = 0. , sumY = 0. , sumZ = 0. ; for ( int idx : nodeIdxs ) { sumX += nodes . at ( idx ). coor . x ; sumY += nodes . at ( idx ). coor . y ; sumZ += nodes . at ( idx ). coor . z ; } int size = int ( nodeIdxs . size ()); return { sumX / size , sumY / size , sumZ / size }; } Coordinate GeoCalculator :: CalculateFaceCentroid ( int faceIdx , const Mesh & mesh ) { return CalculateCentroid ( mesh . faces . at ( faceIdx ). nodeIndexes , mesh . nodes ); } Coordinate GeoCalculator :: CalculateCellCentroid ( int cellIdx , const Mesh & mesh ) { return CalculateCentroid ( GetCellNodeIndexes ( cellIdx , mesh ), mesh . nodes ); } vector < int > GeoCalculator :: GetCellNodeIndexes ( int cellIdx , const Mesh & mesh ) { set < int > nodeIdxs ; for ( int faceIdx : mesh . cells . at ( cellIdx ). faceIndexes ) { for ( int nodeIdx : mesh . faces . at ( faceIdx ). nodeIndexes ) { nodeIdxs . emplace ( nodeIdx ); } } vector < int > idxs ( nodeIdxs . begin (), nodeIdxs . end ()); return idxs ; } array < real , 3 > GeoCalculator :: CalculateNormal ( const vector < int > & nodeIdxs , const unordered_map < int , Node > & nodes ) { int size = nodeIdxs . size (); // 2D mesh, calculate the normal vector projected by an edge onto the xy plane. if ( size == 2 ) { auto vec = ToVector ( nodes . at ( nodeIdxs [ 0 ]), nodes . at ( nodeIdxs [ 1 ])); vec . Normalize (); return { vec ( 1 ), vec ( 0 ), 0. }; } // 3D mesh, calculate the normal vector of the face. else { const auto & v1 = ToVector ( nodes . at ( nodeIdxs [ 1 ]), nodes . at ( nodeIdxs [ 0 ])); const auto & v2 = ToVector ( nodes . at ( nodeIdxs [ 1 ]), nodes . at ( nodeIdxs [ 2 ])); auto n = v1 & v2 ; n . Normalize (); return { n ( 0 ), n ( 1 ), n ( 2 )}; } } array < real , 3 > GeoCalculator :: CalculateFaceNormal ( int faceIdx , const Mesh & mesh ) { return CalculateNormal ( mesh . faces . at ( faceIdx ). nodeIndexes , mesh . nodes ); } real GeoCalculator :: CalculateArea ( const Vector < real , 3 > & normal , const vector < int > & nodeIdxs , const unordered_map < int , Node > & nodes ) { int size = nodeIdxs . size (); // 2D mesh. if ( size == 2 ) { return 0. ; } // 3D mesh, calculate face area by Shoelace Theorem in 3d. // area = 1/2 * { // cos(n, z) * sum(x_i * y_i+1 - x_i+1 * y_i) + // cos(n, x) * sum(y_i * z_i+1 - y_i+1 * z_i) + // cos(n, y) * sum(z_i * x_i+1 - z_i+1 * x_i) // } Vector < real , 3 > x = { 1. , 0. , 0. }, y = { 0. , 1. , 0. }, z = { 0. , 0. , 1. }; real zCos = normal * z ; real xCos = normal * x ; real yCos = normal * y ; real area = 0.0 ; for ( int i = 0 ; i < size - 1 ; ++ i ) { const auto & node0 = nodes . at ( nodeIdxs [ i ]). coor ; const auto & node1 = nodes . at ( nodeIdxs [ i + 1 ]). coor ; area += zCos * ( node0 . x * node1 . y - node0 . y * node1 . x ); area += xCos * ( node0 . y * node1 . z - node0 . z * node1 . y ); area += yCos * ( node0 . z * node1 . x - node0 . x * node1 . z ); } return abs ( area ) / 2.0 ; } real GeoCalculator :: CalculateFaceArea ( int faceIdx , const Mesh & mesh ) { const auto & face = mesh . faces . at ( faceIdx ); return CalculateArea ( face . normal , face . nodeIndexes , mesh . nodes ); } real GeoCalculator :: CalculateLength ( const Node & node0 , const Node & node1 ) { const auto & vec = ToVector ( node0 , node1 ); return vec . Length (); } real GeoCalculator :: CalculateFacePerimeter ( int faceIdx , const Mesh & mesh ) { const auto & fNodes = mesh . faces . at ( faceIdx ). nodeIndexes ; int n = fNodes . size (); const auto & nodes = mesh . nodes ; double len = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { len += CalculateLength ( nodes . at ( fNodes [ i ]), nodes . at ( fNodes [ i + 1 ])); } if ( n > 2 ) { len += CalculateLength ( nodes . at ( fNodes [ n - 1 ]), nodes . at ( fNodes [ 0 ])); } return len ; } real GeoCalculator :: CalculateVolume ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ) { // Only tetrahedral and prismatic volume calculations are supported. int size = nodeIdxs . size (); // tetrahedral cell. if ( size == 4 ) { const auto & v1 = ToVector ( nodes . at ( nodeIdxs [ 0 ]), nodes . at ( nodeIdxs [ 1 ])); const auto & v2 = ToVector ( nodes . at ( nodeIdxs [ 0 ]), nodes . at ( nodeIdxs [ 2 ])); const auto & v3 = ToVector ( nodes . at ( nodeIdxs [ 0 ]), nodes . at ( nodeIdxs [ 3 ])); real vol = (( v1 & v2 ) * v3 ) / 6.0 ; return vol ; } else { throw NotImplementedException (); } } real GeoCalculator :: CalculateCellVolume ( int cellIdx , const Mesh & mesh ) { const auto & nodeIdxs = GetCellNodeIndexes ( cellIdx , mesh ); return CalculateVolume ( nodeIdxs , mesh . nodes ); } Vector < real , 3 > GeoCalculator :: ToVector ( const Node & start , const Node & end ) { const auto & node0 = start . coor ; const auto & node1 = end . coor ; return { node1 . x - node0 . x , node1 . y - node0 . y , node1 . z - node0 . z }; } } // namespace OpenOasis::CommImp::Spatial","title":"File GeoCalculator.cpp"},{"location":"models/_geo_calculator_8cpp_source/#file-geocalculatorcpp","text":"File List > CommImp > Spatial > GeoCalculator.cpp Go to the documentation of this file #include \"GeoCalculator.h\" #include \"Models/Utils/Exception.h\" #include <set> namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; vector < int > GeoCalculator :: SortNodes ( const vector < int > & nodeIdxs , const unordered_map < int , Node > & nodes ) { vector < int > sortedIdxs ( nodeIdxs ); // has error. // auto centroid = CalculateCentroid(nodeIdxs, nodes); // int ignoredAxis = ChooseFoldedAxis(nodeIdxs, nodes); // for (int i = 0; i < sortedIdxs.size() - 1; i++) // { // int curr = sortedIdxs[i]; // for (int j = 0; j < sortedIdxs.size() - i - 1; j++) // { // double next = sortedIdxs[j]; // if (CompareNodeOrder(nodes.at(j), nodes.at(j + 1), centroid, // ignoredAxis)) // { // sortedIdxs[j] = next; // sortedIdxs[j + 1] = curr; // } // } // } return sortedIdxs ; } vector < int > GeoCalculator :: SortFaceNodes ( int faceIndex , const Mesh & mesh ) { return SortNodes ( mesh . faces . at ( faceIndex ). nodeIndexes , mesh . nodes ); } int GeoCalculator :: ChooseFoldedAxis ( const vector < int > & nodeIdxs , const unordered_map < int , Node > & nodes ) { int num = nodeIdxs . size (); vector < real > Xs ( num ), Ys ( num ), Zs ( num ); for ( int idx : nodeIdxs ) { const auto & coor = nodes . at ( idx ). coor ; Xs . push_back ( coor . x ); Ys . push_back ( coor . y ); Zs . push_back ( coor . z ); } int axisX = 0 , axisY = 0 , axisZ = 0 ; for ( int i = 0 ; i < num ; ++ i ) { for ( int j = i ; j < num ; ++ j ) { if ( IsSim ( Xs [ i ], Xs [ j ], EPSILON )) axisX += 1 ; if ( IsSim ( Ys [ i ], Ys [ j ], EPSILON )) axisY += 1 ; if ( IsSim ( Zs [ i ], Zs [ j ], EPSILON )) axisZ += 1 ; } } if ( axisX > axisY && axisX > axisZ ) return 0 ; if ( axisY > axisX && axisY > axisZ ) return 1 ; return 2 ; } bool GeoCalculator :: CompareNodeOrder ( const Node & node0 , const Node & node1 , const Coordinate & centroid , int ignoredAxis ) { Coordinate n0 , n1 , o ; if ( ignoredAxis == 2 ) { n0 = { node0 . coor . x , node0 . coor . y , 0 }; n1 = { node1 . coor . x , node1 . coor . y , 0 }; o = { centroid . x , centroid . y , 0 }; } else if ( ignoredAxis == 1 ) { n0 = { node0 . coor . x , node0 . coor . z , 0 }; n1 = { node1 . coor . x , node1 . coor . z , 0 }; o = { centroid . x , centroid . z , 0 }; } else { n0 = { node0 . coor . y , node0 . coor . z , 0 }; n1 = { node1 . coor . y , node1 . coor . z , 0 }; o = { centroid . y , centroid . z , 0 }; } if ( n0 . x >= 0 && n1 . x < 0 ) return true ; if ( n0 . x == 0 && n1 . x == 0 ) return n0 . y > n1 . y ; real dx0 = n0 . x - o . x , dx1 = n1 . x - o . x ; real dy1 = n0 . y - o . y , dy0 = n1 . y - o . y ; int det = dx0 * dy1 - dx1 * dy0 ; if ( det < 0 ) return true ; if ( det > 0 ) return false ; int dist0 = dx0 * dx0 + dy0 * dy0 ; int dist1 = dx1 * dx1 + dy1 * dy1 ; return dist0 > dist1 ; } Coordinate GeoCalculator :: CalculateCentroid ( const vector < int > & nodeIdxs , const unordered_map < int , Node > & nodes ) { if ( nodeIdxs . empty ()) return {}; real sumX = 0. , sumY = 0. , sumZ = 0. ; for ( int idx : nodeIdxs ) { sumX += nodes . at ( idx ). coor . x ; sumY += nodes . at ( idx ). coor . y ; sumZ += nodes . at ( idx ). coor . z ; } int size = int ( nodeIdxs . size ()); return { sumX / size , sumY / size , sumZ / size }; } Coordinate GeoCalculator :: CalculateFaceCentroid ( int faceIdx , const Mesh & mesh ) { return CalculateCentroid ( mesh . faces . at ( faceIdx ). nodeIndexes , mesh . nodes ); } Coordinate GeoCalculator :: CalculateCellCentroid ( int cellIdx , const Mesh & mesh ) { return CalculateCentroid ( GetCellNodeIndexes ( cellIdx , mesh ), mesh . nodes ); } vector < int > GeoCalculator :: GetCellNodeIndexes ( int cellIdx , const Mesh & mesh ) { set < int > nodeIdxs ; for ( int faceIdx : mesh . cells . at ( cellIdx ). faceIndexes ) { for ( int nodeIdx : mesh . faces . at ( faceIdx ). nodeIndexes ) { nodeIdxs . emplace ( nodeIdx ); } } vector < int > idxs ( nodeIdxs . begin (), nodeIdxs . end ()); return idxs ; } array < real , 3 > GeoCalculator :: CalculateNormal ( const vector < int > & nodeIdxs , const unordered_map < int , Node > & nodes ) { int size = nodeIdxs . size (); // 2D mesh, calculate the normal vector projected by an edge onto the xy plane. if ( size == 2 ) { auto vec = ToVector ( nodes . at ( nodeIdxs [ 0 ]), nodes . at ( nodeIdxs [ 1 ])); vec . Normalize (); return { vec ( 1 ), vec ( 0 ), 0. }; } // 3D mesh, calculate the normal vector of the face. else { const auto & v1 = ToVector ( nodes . at ( nodeIdxs [ 1 ]), nodes . at ( nodeIdxs [ 0 ])); const auto & v2 = ToVector ( nodes . at ( nodeIdxs [ 1 ]), nodes . at ( nodeIdxs [ 2 ])); auto n = v1 & v2 ; n . Normalize (); return { n ( 0 ), n ( 1 ), n ( 2 )}; } } array < real , 3 > GeoCalculator :: CalculateFaceNormal ( int faceIdx , const Mesh & mesh ) { return CalculateNormal ( mesh . faces . at ( faceIdx ). nodeIndexes , mesh . nodes ); } real GeoCalculator :: CalculateArea ( const Vector < real , 3 > & normal , const vector < int > & nodeIdxs , const unordered_map < int , Node > & nodes ) { int size = nodeIdxs . size (); // 2D mesh. if ( size == 2 ) { return 0. ; } // 3D mesh, calculate face area by Shoelace Theorem in 3d. // area = 1/2 * { // cos(n, z) * sum(x_i * y_i+1 - x_i+1 * y_i) + // cos(n, x) * sum(y_i * z_i+1 - y_i+1 * z_i) + // cos(n, y) * sum(z_i * x_i+1 - z_i+1 * x_i) // } Vector < real , 3 > x = { 1. , 0. , 0. }, y = { 0. , 1. , 0. }, z = { 0. , 0. , 1. }; real zCos = normal * z ; real xCos = normal * x ; real yCos = normal * y ; real area = 0.0 ; for ( int i = 0 ; i < size - 1 ; ++ i ) { const auto & node0 = nodes . at ( nodeIdxs [ i ]). coor ; const auto & node1 = nodes . at ( nodeIdxs [ i + 1 ]). coor ; area += zCos * ( node0 . x * node1 . y - node0 . y * node1 . x ); area += xCos * ( node0 . y * node1 . z - node0 . z * node1 . y ); area += yCos * ( node0 . z * node1 . x - node0 . x * node1 . z ); } return abs ( area ) / 2.0 ; } real GeoCalculator :: CalculateFaceArea ( int faceIdx , const Mesh & mesh ) { const auto & face = mesh . faces . at ( faceIdx ); return CalculateArea ( face . normal , face . nodeIndexes , mesh . nodes ); } real GeoCalculator :: CalculateLength ( const Node & node0 , const Node & node1 ) { const auto & vec = ToVector ( node0 , node1 ); return vec . Length (); } real GeoCalculator :: CalculateFacePerimeter ( int faceIdx , const Mesh & mesh ) { const auto & fNodes = mesh . faces . at ( faceIdx ). nodeIndexes ; int n = fNodes . size (); const auto & nodes = mesh . nodes ; double len = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { len += CalculateLength ( nodes . at ( fNodes [ i ]), nodes . at ( fNodes [ i + 1 ])); } if ( n > 2 ) { len += CalculateLength ( nodes . at ( fNodes [ n - 1 ]), nodes . at ( fNodes [ 0 ])); } return len ; } real GeoCalculator :: CalculateVolume ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ) { // Only tetrahedral and prismatic volume calculations are supported. int size = nodeIdxs . size (); // tetrahedral cell. if ( size == 4 ) { const auto & v1 = ToVector ( nodes . at ( nodeIdxs [ 0 ]), nodes . at ( nodeIdxs [ 1 ])); const auto & v2 = ToVector ( nodes . at ( nodeIdxs [ 0 ]), nodes . at ( nodeIdxs [ 2 ])); const auto & v3 = ToVector ( nodes . at ( nodeIdxs [ 0 ]), nodes . at ( nodeIdxs [ 3 ])); real vol = (( v1 & v2 ) * v3 ) / 6.0 ; return vol ; } else { throw NotImplementedException (); } } real GeoCalculator :: CalculateCellVolume ( int cellIdx , const Mesh & mesh ) { const auto & nodeIdxs = GetCellNodeIndexes ( cellIdx , mesh ); return CalculateVolume ( nodeIdxs , mesh . nodes ); } Vector < real , 3 > GeoCalculator :: ToVector ( const Node & start , const Node & end ) { const auto & node0 = start . coor ; const auto & node1 = end . coor ; return { node1 . x - node0 . x , node1 . y - node0 . y , node1 . z - node0 . z }; } } // namespace OpenOasis::CommImp::Spatial","title":"File GeoCalculator.cpp"},{"location":"models/_geo_calculator_8h/","text":"File GeoCalculator.h \u00b6 FileList > CommImp > Spatial > GeoCalculator.h Go to the source code of this file #include \"MeshStructs.h\" #include \"Models/CommImp/Numeric/Vector.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial Classes \u00b6 Type Name class GeoCalculator The GeoCalculator is a collection of general geometry functions. The documentation for this class was generated from the following file Models/CommImp/Spatial/GeoCalculator.h","title":"File GeoCalculator.h"},{"location":"models/_geo_calculator_8h/#file-geocalculatorh","text":"FileList > CommImp > Spatial > GeoCalculator.h Go to the source code of this file #include \"MeshStructs.h\" #include \"Models/CommImp/Numeric/Vector.h\"","title":"File GeoCalculator.h"},{"location":"models/_geo_calculator_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial","title":"Namespaces"},{"location":"models/_geo_calculator_8h/#classes","text":"Type Name class GeoCalculator The GeoCalculator is a collection of general geometry functions. The documentation for this class was generated from the following file Models/CommImp/Spatial/GeoCalculator.h","title":"Classes"},{"location":"models/_geo_calculator_8h_source/","text":"File GeoCalculator.h \u00b6 File List > CommImp > Spatial > GeoCalculator.h Go to the documentation of this file #pragma once #include \"MeshStructs.h\" #include \"Models/CommImp/Numeric/Vector.h\" namespace OpenOasis { namespace CommImp { namespace Spatial { using namespace Numeric ; using Utils :: real ; class GeoCalculator final { public : static constexpr real EPSILON = 1.0e-5 ; static std :: vector < int > GetCellNodeIndexes ( int cellIdx , const Mesh & mesh ); static std :: vector < int > SortNodes ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ); static std :: vector < int > SortFaceNodes ( int faceIndex , const Mesh & mesh ); static Coordinate CalculateCentroid ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ); static Coordinate CalculateFaceCentroid ( int faceIdx , const Mesh & mesh ); static Coordinate CalculateCellCentroid ( int cellIdx , const Mesh & mesh ); static std :: array < real , 3 > CalculateNormal ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ); static std :: array < real , 3 > CalculateFaceNormal ( int faceIdx , const Mesh & mesh ); static real CalculateArea ( const Vector < real , 3 > & normal , const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ); static real CalculateFaceArea ( int faceIdx , const Mesh & mesh ); static real CalculateLength ( const Node & node0 , const Node & node1 ); static real CalculateFacePerimeter ( int faceIdx , const Mesh & mesh ); static real CalculateVolume ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ); static real CalculateCellVolume ( int cellIdx , const Mesh & mesh ); private : static Vector < real , 3 > ToVector ( const Node & start , const Node & stop ); static int ChooseFoldedAxis ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ); static bool CompareNodeOrder ( const Node & node0 , const Node & node1 , const Coordinate & centroid , int ignoredAxis ); }; } // namespace Spatial } // namespace CommImp } // namespace OpenOasis","title":"File GeoCalculator.h"},{"location":"models/_geo_calculator_8h_source/#file-geocalculatorh","text":"File List > CommImp > Spatial > GeoCalculator.h Go to the documentation of this file #pragma once #include \"MeshStructs.h\" #include \"Models/CommImp/Numeric/Vector.h\" namespace OpenOasis { namespace CommImp { namespace Spatial { using namespace Numeric ; using Utils :: real ; class GeoCalculator final { public : static constexpr real EPSILON = 1.0e-5 ; static std :: vector < int > GetCellNodeIndexes ( int cellIdx , const Mesh & mesh ); static std :: vector < int > SortNodes ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ); static std :: vector < int > SortFaceNodes ( int faceIndex , const Mesh & mesh ); static Coordinate CalculateCentroid ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ); static Coordinate CalculateFaceCentroid ( int faceIdx , const Mesh & mesh ); static Coordinate CalculateCellCentroid ( int cellIdx , const Mesh & mesh ); static std :: array < real , 3 > CalculateNormal ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ); static std :: array < real , 3 > CalculateFaceNormal ( int faceIdx , const Mesh & mesh ); static real CalculateArea ( const Vector < real , 3 > & normal , const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ); static real CalculateFaceArea ( int faceIdx , const Mesh & mesh ); static real CalculateLength ( const Node & node0 , const Node & node1 ); static real CalculateFacePerimeter ( int faceIdx , const Mesh & mesh ); static real CalculateVolume ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ); static real CalculateCellVolume ( int cellIdx , const Mesh & mesh ); private : static Vector < real , 3 > ToVector ( const Node & start , const Node & stop ); static int ChooseFoldedAxis ( const std :: vector < int > & nodeIdxs , const std :: unordered_map < int , Node > & nodes ); static bool CompareNodeOrder ( const Node & node0 , const Node & node1 , const Coordinate & centroid , int ignoredAxis ); }; } // namespace Spatial } // namespace CommImp } // namespace OpenOasis","title":"File GeoCalculator.h"},{"location":"models/_grid_8cpp/","text":"File Grid.cpp \u00b6 FileList > CommImp > Spatial > Grid.cpp Go to the source code of this file #include \"Grid.h\" #include \"GeoCalculator.h\" #include \"XYGeoTools.h\" #include \"Models/Utils/Exception.h\" #include \"Models/Utils/MapHelper.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid.cpp","title":"File Grid.cpp"},{"location":"models/_grid_8cpp/#file-gridcpp","text":"FileList > CommImp > Spatial > Grid.cpp Go to the source code of this file #include \"Grid.h\" #include \"GeoCalculator.h\" #include \"XYGeoTools.h\" #include \"Models/Utils/Exception.h\" #include \"Models/Utils/MapHelper.h\"","title":"File Grid.cpp"},{"location":"models/_grid_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid.cpp","title":"Namespaces"},{"location":"models/_grid_8cpp_source/","text":"File Grid.cpp \u00b6 File List > CommImp > Spatial > Grid.cpp Go to the documentation of this file #include \"Grid.h\" #include \"GeoCalculator.h\" #include \"XYGeoTools.h\" #include \"Models/Utils/Exception.h\" #include \"Models/Utils/MapHelper.h\" namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; // ------------------------------------------------------------------------------------ Grid :: Grid ( unordered_map < int , Coordinate > & nodeCoords , unordered_map < int , Coordinate > & faceCoords , unordered_map < int , Coordinate > & cellCoords , unordered_map < int , vector < int >> & faceNodes , unordered_map < int , vector < int >> & cellFaces , unordered_map < string , vector < int >> & patches , unordered_map < string , vector < int >> & zones ) { #pragma omp parallel sections { #pragma omp section { for ( auto & node : nodeCoords ) { mMesh . nodes [ node . first ] = {}; mMesh . nodes [ node . first ]. coor = node . second ; } nodeCoords . clear (); } #pragma omp section { for ( auto & face : faceCoords ) { int i = face . first ; mMesh . faces [ i ] = {}; mMesh . faces [ i ]. centroid = face . second ; mMesh . faces [ i ]. nodeIndexes = faceNodes [ i ]; } faceCoords . clear (); faceNodes . clear (); } #pragma omp section { for ( auto & cell : cellCoords ) { int i = cell . first ; mMesh . cells [ i ] = {}; mMesh . cells [ i ]. centroid = cellCoords [ i ]; mMesh . cells [ i ]. faceIndexes = cellFaces [ i ]; } cellCoords . clear (); cellFaces . clear (); } } mPatches = patches ; mZones = zones ; mRawNodesNum = mMesh . nodes . size (); mRawFacesNum = mMesh . faces . size (); mRawCellsNum = mMesh . cells . size (); } Grid :: Grid ( const shared_ptr < Grid > & grid ) { mMesh = grid -> mMesh ; mRawCellsNum = grid -> mRawCellsNum ; mRawFacesNum = grid -> mRawFacesNum ; mRawNodesNum = grid -> mRawNodesNum ; mPatches = grid -> mPatches ; mZones = grid -> mZones ; } void Grid :: Activate () { // Complete mesh topological connections. CollectCellsSharedNode (); CollectFacesSharedNode (); CollectCellsSharedFace (); CollectCellNeighbors (); CollectCellsInZone (); // Sort node counterclockwise. SortNodes (); // Activate mesh face structures in orderly. CalculateFaceDirector (); CalculateFaceNormal (); CalculateFaceArea (); CalculateFacePerimeter (); // Activate mesh cell structures. CalculateCellSurface (); CalculateCellVolume (); // Check mesh validation. CheckMesh (); // Analysis mesh structures. #pragma omp parallel sections { #pragma omp section { CalculateCellDistances (); } #pragma omp section { CalculateBoundaryCenterDistances (); } #pragma omp section { CollectBoundaryFacesAndCells (); } #pragma omp section { CalculateFaceIntersections (); CalculateFaceWeights (); CalculateFaceCorrectionVector (); } } } void Grid :: CollectCellsSharedNode () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawCellsNum ; i ++ ) { const auto & nodeIdxs = GeoCalculator :: GetCellNodeIndexes ( i , mMesh ); for ( int nIdx : nodeIdxs ) mMesh . nodes [ nIdx ]. cellIndexes . push_back ( i ); } } void Grid :: CollectFacesSharedNode () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; i ++ ) { for ( int nIdx : mMesh . faces [ i ]. nodeIndexes ) { mMesh . nodes [ nIdx ]. faceIndexes . push_back ( i ); } } } void Grid :: CollectCellsSharedFace () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawCellsNum ; i ++ ) { for ( int fIdx : mMesh . cells [ i ]. faceIndexes ) { mMesh . faces [ fIdx ]. cellIndexes . push_back ( i ); } } } void Grid :: CollectCellNeighbors () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; i ++ ) { const auto & cells = mMesh . faces [ i ]. cellIndexes ; if ( cells . size () != 2 ) continue ; mMesh . cells [ cells [ 0 ]]. neighbors . push_back ( cells [ 1 ]); mMesh . cells [ cells [ 1 ]]. neighbors . push_back ( cells [ 0 ]); } } void Grid :: SortNodes () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; i ++ ) { mMesh . faces [ i ]. nodeIndexes = GeoCalculator :: SortFaceNodes ( i , mMesh ); } } void Grid :: CalculateFaceDirector () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; i ++ ) { auto & face = mMesh . faces [ i ]; const auto & fPoint = face . centroid ; const auto & cPoint = mMesh . cells [ face . cellIndexes [ 0 ]]. centroid ; double x = cPoint . x - fPoint . x ; double y = cPoint . y - fPoint . y ; double z = cPoint . z - fPoint . z ; auto vec = Vector < real , 3 > ( x , y , z ); auto res = vec * face . normal ; auto dir = ( res > 0 ) ? 1 : -1 ; face . cellSides . push_back ( dir ); if ( face . cellIndexes . size () == 2 ) face . cellSides . push_back ( - dir ); } } void Grid :: CheckMesh () const {} void Grid :: CalculateCellDistances () { for ( int i = 0 ; i < mRawCellsNum ; i ++ ) { const auto & cell = mMesh . cells [ i ]; const auto & n1 = cell . centroid ; for ( int j : cell . neighbors ) { auto index1 = MultiIndex ({ i , j }); if ( mCenterDists . count ( index1 ) > 0 ) continue ; const auto & n2 = mMesh . cells [ j ]. centroid ; mCenterDists [ index1 ] = CalculateDistance ( n1 , n2 ); auto index2 = MultiIndex ({ j , i }); mCenterDists [ index2 ] = mCenterDists [ index1 ]; } } } void Grid :: CalculateBoundaryCenterDistances () { for ( int i = 0 ; i < mRawCellsNum ; i ++ ) { const auto & cell = mMesh . cells [ i ]; const auto & n1 = cell . centroid ; for ( int j : cell . faceIndexes ) { auto index1 = MultiIndex ({ i , j }); if ( mBoundaryCenterDists . count ( index1 ) > 0 ) continue ; const auto & n2 = mMesh . faces [ j ]. centroid ; double dist = CalculateDistance ( n1 , n2 ); mBoundaryCenterDists [ index1 ] = dist ; auto index2 = MultiIndex ({ j , i }); mBoundaryCenterDists [ index2 ] = dist ; } } } void Grid :: CollectBoundaryFacesAndCells () { #pragma omp parallel for schedule(dynamic) for ( std :: size_t i = 0 ; i < mMesh . faces . size (); ++ i ) // for (const auto &face : mMesh.faces) { const auto & face = mMesh . faces [ i ]; if ( face . cellIndexes . size () == 1 ) { mBoundaryFaces . push_back ( i ); mBoundaryCells . push_back ( face . cellIndexes [ 0 ]); } } } void Grid :: CalculateFaceIntersections () { // only supported on 2d mesh now. #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawCellsNum ; i ++ ) { const auto & cell = mMesh . cells [ i ]; for ( int j : cell . faceIndexes ) { if ( mFaceIntersection . count ( j ) > 0 ) continue ; const auto & face = mMesh . faces [ j ]; if ( face . cellIndexes . size () != 2 ) { mFaceIntersection [ j ] = face . centroid ; continue ; } int cIdx = ( face . cellIndexes [ 0 ] == i ) ? face . cellIndexes [ 1 ] : face . cellIndexes [ 0 ]; const auto & c = mMesh . cells [ cIdx ]; XYLine l1 ( cell . centroid . x , cell . centroid . y , c . centroid . x , c . centroid . y ); Node n1 = mMesh . nodes [ face . nodeIndexes [ 0 ]]; Node n2 = mMesh . nodes [ face . nodeIndexes [ 1 ]]; XYPoint p1 ( n1 . coor . x , n1 . coor . y ); XYPoint p2 ( n2 . coor . x , n2 . coor . y ); XYLine l2 ( p1 , p2 ); auto point = XYGeoTools :: CalculateIntersectionPoint ( l1 , l2 ); mFaceIntersection [ j ] = { FP ( point . x ), FP ( point . y ), FP ( face . centroid . z )}; } } } void Grid :: CalculateFaceWeights () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; ++ i ) { const auto & cellIdxs = mMesh . faces [ i ]. cellIndexes ; if ( cellIdxs . size () != 2 ) continue ; int cIdx1 = cellIdxs [ 0 ]; int cIdx2 = cellIdxs [ 1 ]; const auto & fPoint = mFaceIntersection [ i ]; const auto & cPoint1 = mMesh . cells [ cIdx1 ]. centroid ; const auto & cPoint2 = mMesh . cells [ cIdx2 ]. centroid ; double distCf1 = CalculateDistance ( fPoint , cPoint1 ); double distCf2 = CalculateDistance ( fPoint , cPoint2 ); auto index1 = MultiIndex ({ cIdx1 , i }); mCellFaceWeight [ index1 ] = distCf1 / ( distCf1 + distCf2 ); auto index2 = MultiIndex ({ cIdx2 , i }); mCellFaceWeight [ index2 ] = distCf2 / ( distCf1 + distCf2 ); } } void Grid :: CalculateFaceCorrectionVector () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; ++ i ) { const auto & p1 = mMesh . faces [ i ]. centroid ; const auto & p2 = mFaceIntersection [ i ]; mFaceCorrVecs [ i ] = Vector < double > { p2 . x - p1 . x , p2 . y - p1 . y , p2 . z - p1 . z }; } } int Grid :: GetRawNumCells () const { return mRawCellsNum ; } int Grid :: GetRawNumFaces () const { return mRawFacesNum ; } int Grid :: GetRawNumNodes () const { return mRawNodesNum ; } int Grid :: GetNumCells () const { return ( int ) mMesh . cells . size (); } int Grid :: GetNumFaces () const { return ( int ) mMesh . faces . size (); } int Grid :: GetNumNodes () const { return ( int ) mMesh . nodes . size (); } const Cell & Grid :: GetCell ( int cellIndex ) const { return mMesh . cells . at ( cellIndex ); } const Face & Grid :: GetFace ( int faceIndex ) const { return mMesh . faces . at ( faceIndex ); } const Node & Grid :: GetNode ( int nodeIndex ) const { return mMesh . nodes . at ( nodeIndex ); } vector < string > Grid :: GetPatchIds () const { return MapHelper :: GetKeys ( mPatches ); } vector < string > Grid :: GetZoneIds () const { return MapHelper :: GetKeys ( mZones ); } vector < int > Grid :: GetPatchFaceIndexes ( const string & patchId ) const { return mPatches . at ( patchId ); } vector < int > Grid :: GetZoneCellIndexes ( const string & zoneId ) const { throw NotImplementedException (); } const MultiIndexMap < double > & Grid :: GetBoundaryCenterDistances () const { return mBoundaryCenterDists ; } double Grid :: GetBoundaryCenterDistance ( int cellIdx , int boundaryFaceIdx ) const { return mBoundaryCenterDists . at ( MultiIndex ({ cellIdx , boundaryFaceIdx })); } const MultiIndexMap < double > & Grid :: GetCellCenterDistances () const { return mCenterDists ; } double Grid :: GetCellCenterDistance ( int cellIdx , int neighborCellIdx ) const { return mCenterDists . at ( MultiIndex ({ cellIdx , neighborCellIdx })); } const vector < int > & Grid :: GetBoundaryFaceIndexes () const { return mBoundaryFaces ; } const vector < int > & Grid :: GetBoundaryCellIndexes () const { return mBoundaryCells ; } const MultiIndexMap < double > & Grid :: GetCellWeightAtFace () const { return mCellFaceWeight ; } double Grid :: GetCellWeightAtFace ( int cellIdx , int faceIdx ) const { return mCellFaceWeight . at ( MultiIndex ({ cellIdx , faceIdx })); } const unordered_map < int , Vector < double >> & Grid :: GetFaceCorrectionVector () const { return mFaceCorrVecs ; } const Vector < double > & Grid :: GetFaceCorrectionVector ( int faceIdx ) const { return mFaceCorrVecs . at ( faceIdx ); } } // namespace OpenOasis::CommImp::Spatial","title":"File Grid.cpp"},{"location":"models/_grid_8cpp_source/#file-gridcpp","text":"File List > CommImp > Spatial > Grid.cpp Go to the documentation of this file #include \"Grid.h\" #include \"GeoCalculator.h\" #include \"XYGeoTools.h\" #include \"Models/Utils/Exception.h\" #include \"Models/Utils/MapHelper.h\" namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; // ------------------------------------------------------------------------------------ Grid :: Grid ( unordered_map < int , Coordinate > & nodeCoords , unordered_map < int , Coordinate > & faceCoords , unordered_map < int , Coordinate > & cellCoords , unordered_map < int , vector < int >> & faceNodes , unordered_map < int , vector < int >> & cellFaces , unordered_map < string , vector < int >> & patches , unordered_map < string , vector < int >> & zones ) { #pragma omp parallel sections { #pragma omp section { for ( auto & node : nodeCoords ) { mMesh . nodes [ node . first ] = {}; mMesh . nodes [ node . first ]. coor = node . second ; } nodeCoords . clear (); } #pragma omp section { for ( auto & face : faceCoords ) { int i = face . first ; mMesh . faces [ i ] = {}; mMesh . faces [ i ]. centroid = face . second ; mMesh . faces [ i ]. nodeIndexes = faceNodes [ i ]; } faceCoords . clear (); faceNodes . clear (); } #pragma omp section { for ( auto & cell : cellCoords ) { int i = cell . first ; mMesh . cells [ i ] = {}; mMesh . cells [ i ]. centroid = cellCoords [ i ]; mMesh . cells [ i ]. faceIndexes = cellFaces [ i ]; } cellCoords . clear (); cellFaces . clear (); } } mPatches = patches ; mZones = zones ; mRawNodesNum = mMesh . nodes . size (); mRawFacesNum = mMesh . faces . size (); mRawCellsNum = mMesh . cells . size (); } Grid :: Grid ( const shared_ptr < Grid > & grid ) { mMesh = grid -> mMesh ; mRawCellsNum = grid -> mRawCellsNum ; mRawFacesNum = grid -> mRawFacesNum ; mRawNodesNum = grid -> mRawNodesNum ; mPatches = grid -> mPatches ; mZones = grid -> mZones ; } void Grid :: Activate () { // Complete mesh topological connections. CollectCellsSharedNode (); CollectFacesSharedNode (); CollectCellsSharedFace (); CollectCellNeighbors (); CollectCellsInZone (); // Sort node counterclockwise. SortNodes (); // Activate mesh face structures in orderly. CalculateFaceDirector (); CalculateFaceNormal (); CalculateFaceArea (); CalculateFacePerimeter (); // Activate mesh cell structures. CalculateCellSurface (); CalculateCellVolume (); // Check mesh validation. CheckMesh (); // Analysis mesh structures. #pragma omp parallel sections { #pragma omp section { CalculateCellDistances (); } #pragma omp section { CalculateBoundaryCenterDistances (); } #pragma omp section { CollectBoundaryFacesAndCells (); } #pragma omp section { CalculateFaceIntersections (); CalculateFaceWeights (); CalculateFaceCorrectionVector (); } } } void Grid :: CollectCellsSharedNode () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawCellsNum ; i ++ ) { const auto & nodeIdxs = GeoCalculator :: GetCellNodeIndexes ( i , mMesh ); for ( int nIdx : nodeIdxs ) mMesh . nodes [ nIdx ]. cellIndexes . push_back ( i ); } } void Grid :: CollectFacesSharedNode () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; i ++ ) { for ( int nIdx : mMesh . faces [ i ]. nodeIndexes ) { mMesh . nodes [ nIdx ]. faceIndexes . push_back ( i ); } } } void Grid :: CollectCellsSharedFace () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawCellsNum ; i ++ ) { for ( int fIdx : mMesh . cells [ i ]. faceIndexes ) { mMesh . faces [ fIdx ]. cellIndexes . push_back ( i ); } } } void Grid :: CollectCellNeighbors () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; i ++ ) { const auto & cells = mMesh . faces [ i ]. cellIndexes ; if ( cells . size () != 2 ) continue ; mMesh . cells [ cells [ 0 ]]. neighbors . push_back ( cells [ 1 ]); mMesh . cells [ cells [ 1 ]]. neighbors . push_back ( cells [ 0 ]); } } void Grid :: SortNodes () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; i ++ ) { mMesh . faces [ i ]. nodeIndexes = GeoCalculator :: SortFaceNodes ( i , mMesh ); } } void Grid :: CalculateFaceDirector () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; i ++ ) { auto & face = mMesh . faces [ i ]; const auto & fPoint = face . centroid ; const auto & cPoint = mMesh . cells [ face . cellIndexes [ 0 ]]. centroid ; double x = cPoint . x - fPoint . x ; double y = cPoint . y - fPoint . y ; double z = cPoint . z - fPoint . z ; auto vec = Vector < real , 3 > ( x , y , z ); auto res = vec * face . normal ; auto dir = ( res > 0 ) ? 1 : -1 ; face . cellSides . push_back ( dir ); if ( face . cellIndexes . size () == 2 ) face . cellSides . push_back ( - dir ); } } void Grid :: CheckMesh () const {} void Grid :: CalculateCellDistances () { for ( int i = 0 ; i < mRawCellsNum ; i ++ ) { const auto & cell = mMesh . cells [ i ]; const auto & n1 = cell . centroid ; for ( int j : cell . neighbors ) { auto index1 = MultiIndex ({ i , j }); if ( mCenterDists . count ( index1 ) > 0 ) continue ; const auto & n2 = mMesh . cells [ j ]. centroid ; mCenterDists [ index1 ] = CalculateDistance ( n1 , n2 ); auto index2 = MultiIndex ({ j , i }); mCenterDists [ index2 ] = mCenterDists [ index1 ]; } } } void Grid :: CalculateBoundaryCenterDistances () { for ( int i = 0 ; i < mRawCellsNum ; i ++ ) { const auto & cell = mMesh . cells [ i ]; const auto & n1 = cell . centroid ; for ( int j : cell . faceIndexes ) { auto index1 = MultiIndex ({ i , j }); if ( mBoundaryCenterDists . count ( index1 ) > 0 ) continue ; const auto & n2 = mMesh . faces [ j ]. centroid ; double dist = CalculateDistance ( n1 , n2 ); mBoundaryCenterDists [ index1 ] = dist ; auto index2 = MultiIndex ({ j , i }); mBoundaryCenterDists [ index2 ] = dist ; } } } void Grid :: CollectBoundaryFacesAndCells () { #pragma omp parallel for schedule(dynamic) for ( std :: size_t i = 0 ; i < mMesh . faces . size (); ++ i ) // for (const auto &face : mMesh.faces) { const auto & face = mMesh . faces [ i ]; if ( face . cellIndexes . size () == 1 ) { mBoundaryFaces . push_back ( i ); mBoundaryCells . push_back ( face . cellIndexes [ 0 ]); } } } void Grid :: CalculateFaceIntersections () { // only supported on 2d mesh now. #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawCellsNum ; i ++ ) { const auto & cell = mMesh . cells [ i ]; for ( int j : cell . faceIndexes ) { if ( mFaceIntersection . count ( j ) > 0 ) continue ; const auto & face = mMesh . faces [ j ]; if ( face . cellIndexes . size () != 2 ) { mFaceIntersection [ j ] = face . centroid ; continue ; } int cIdx = ( face . cellIndexes [ 0 ] == i ) ? face . cellIndexes [ 1 ] : face . cellIndexes [ 0 ]; const auto & c = mMesh . cells [ cIdx ]; XYLine l1 ( cell . centroid . x , cell . centroid . y , c . centroid . x , c . centroid . y ); Node n1 = mMesh . nodes [ face . nodeIndexes [ 0 ]]; Node n2 = mMesh . nodes [ face . nodeIndexes [ 1 ]]; XYPoint p1 ( n1 . coor . x , n1 . coor . y ); XYPoint p2 ( n2 . coor . x , n2 . coor . y ); XYLine l2 ( p1 , p2 ); auto point = XYGeoTools :: CalculateIntersectionPoint ( l1 , l2 ); mFaceIntersection [ j ] = { FP ( point . x ), FP ( point . y ), FP ( face . centroid . z )}; } } } void Grid :: CalculateFaceWeights () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; ++ i ) { const auto & cellIdxs = mMesh . faces [ i ]. cellIndexes ; if ( cellIdxs . size () != 2 ) continue ; int cIdx1 = cellIdxs [ 0 ]; int cIdx2 = cellIdxs [ 1 ]; const auto & fPoint = mFaceIntersection [ i ]; const auto & cPoint1 = mMesh . cells [ cIdx1 ]. centroid ; const auto & cPoint2 = mMesh . cells [ cIdx2 ]. centroid ; double distCf1 = CalculateDistance ( fPoint , cPoint1 ); double distCf2 = CalculateDistance ( fPoint , cPoint2 ); auto index1 = MultiIndex ({ cIdx1 , i }); mCellFaceWeight [ index1 ] = distCf1 / ( distCf1 + distCf2 ); auto index2 = MultiIndex ({ cIdx2 , i }); mCellFaceWeight [ index2 ] = distCf2 / ( distCf1 + distCf2 ); } } void Grid :: CalculateFaceCorrectionVector () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; ++ i ) { const auto & p1 = mMesh . faces [ i ]. centroid ; const auto & p2 = mFaceIntersection [ i ]; mFaceCorrVecs [ i ] = Vector < double > { p2 . x - p1 . x , p2 . y - p1 . y , p2 . z - p1 . z }; } } int Grid :: GetRawNumCells () const { return mRawCellsNum ; } int Grid :: GetRawNumFaces () const { return mRawFacesNum ; } int Grid :: GetRawNumNodes () const { return mRawNodesNum ; } int Grid :: GetNumCells () const { return ( int ) mMesh . cells . size (); } int Grid :: GetNumFaces () const { return ( int ) mMesh . faces . size (); } int Grid :: GetNumNodes () const { return ( int ) mMesh . nodes . size (); } const Cell & Grid :: GetCell ( int cellIndex ) const { return mMesh . cells . at ( cellIndex ); } const Face & Grid :: GetFace ( int faceIndex ) const { return mMesh . faces . at ( faceIndex ); } const Node & Grid :: GetNode ( int nodeIndex ) const { return mMesh . nodes . at ( nodeIndex ); } vector < string > Grid :: GetPatchIds () const { return MapHelper :: GetKeys ( mPatches ); } vector < string > Grid :: GetZoneIds () const { return MapHelper :: GetKeys ( mZones ); } vector < int > Grid :: GetPatchFaceIndexes ( const string & patchId ) const { return mPatches . at ( patchId ); } vector < int > Grid :: GetZoneCellIndexes ( const string & zoneId ) const { throw NotImplementedException (); } const MultiIndexMap < double > & Grid :: GetBoundaryCenterDistances () const { return mBoundaryCenterDists ; } double Grid :: GetBoundaryCenterDistance ( int cellIdx , int boundaryFaceIdx ) const { return mBoundaryCenterDists . at ( MultiIndex ({ cellIdx , boundaryFaceIdx })); } const MultiIndexMap < double > & Grid :: GetCellCenterDistances () const { return mCenterDists ; } double Grid :: GetCellCenterDistance ( int cellIdx , int neighborCellIdx ) const { return mCenterDists . at ( MultiIndex ({ cellIdx , neighborCellIdx })); } const vector < int > & Grid :: GetBoundaryFaceIndexes () const { return mBoundaryFaces ; } const vector < int > & Grid :: GetBoundaryCellIndexes () const { return mBoundaryCells ; } const MultiIndexMap < double > & Grid :: GetCellWeightAtFace () const { return mCellFaceWeight ; } double Grid :: GetCellWeightAtFace ( int cellIdx , int faceIdx ) const { return mCellFaceWeight . at ( MultiIndex ({ cellIdx , faceIdx })); } const unordered_map < int , Vector < double >> & Grid :: GetFaceCorrectionVector () const { return mFaceCorrVecs ; } const Vector < double > & Grid :: GetFaceCorrectionVector ( int faceIdx ) const { return mFaceCorrVecs . at ( faceIdx ); } } // namespace OpenOasis::CommImp::Spatial","title":"File Grid.cpp"},{"location":"models/_grid_8h/","text":"File Grid.h \u00b6 FileList > CommImp > Spatial > Grid.h Go to the source code of this file #include \"MeshStructs.h\" #include \"Models/CommImp/Numeric/Vector.h\" #include \"Models/Utils/MultiIndexMapper.h\" #include <string> #include <memory> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial Classes \u00b6 Type Name class Grid Grid encapsulate the mesh data for numerical calculation. The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid.h","title":"File Grid.h"},{"location":"models/_grid_8h/#file-gridh","text":"FileList > CommImp > Spatial > Grid.h Go to the source code of this file #include \"MeshStructs.h\" #include \"Models/CommImp/Numeric/Vector.h\" #include \"Models/Utils/MultiIndexMapper.h\" #include <string> #include <memory>","title":"File Grid.h"},{"location":"models/_grid_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial","title":"Namespaces"},{"location":"models/_grid_8h/#classes","text":"Type Name class Grid Grid encapsulate the mesh data for numerical calculation. The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid.h","title":"Classes"},{"location":"models/_grid_8h_source/","text":"File Grid.h \u00b6 File List > CommImp > Spatial > Grid.h Go to the documentation of this file #pragma once #include \"MeshStructs.h\" #include \"Models/CommImp/Numeric/Vector.h\" #include \"Models/Utils/MultiIndexMapper.h\" #include <string> #include <memory> namespace OpenOasis :: CommImp :: Spatial { using Numeric :: Vector ; using Utils :: MultiIndexMap ; class Grid { protected : Mesh mMesh ; // The number of original objects in the mesh before // refining or coarsening. int mRawNodesNum , mRawCellsNum , mRawFacesNum ; // The boundary cells and faces. std :: vector < int > mBoundaryCells ; std :: vector < int > mBoundaryFaces ; // The outer or inner boundary patches, each of them // is composed of Face indexes. std :: unordered_map < std :: string , std :: vector < int >> mPatches ; // The zone enclosed by Face indexes. std :: unordered_map < std :: string , std :: vector < int >> mZones ; // The zone composed of Cell indexes. std :: unordered_map < std :: string , std :: vector < int >> mZoneCells ; // The distances between cell centroids. MultiIndexMap < double > mCenterDists ; // The distances between cell centroid and boundary face. MultiIndexMap < double > mBoundaryCenterDists ; // The interfacial intersection point with line of cell centers. std :: unordered_map < int , Coordinate > mFaceIntersection ; // The weight of each cell at face. MultiIndexMap < double > mCellFaceWeight ; // The distance between face centroid and intersection. std :: unordered_map < int , Vector < double >> mFaceCorrVecs ; public : virtual ~ Grid () = default ; Grid ( const std :: shared_ptr < Grid > & grid ); Grid ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int >> & faceNodes , std :: unordered_map < int , std :: vector < int >> & cellFaces , std :: unordered_map < std :: string , std :: vector < int >> & patches , std :: unordered_map < std :: string , std :: vector < int >> & zones ); // Methods used for mesh operations. // virtual int Type () const = 0 ; virtual void Activate (); virtual void RefineCell ( int cellIndex ) = 0 ; virtual void RelaxCell ( int cellIndex ) = 0 ; // Methods used for mesh query. // int GetRawNumCells () const ; int GetRawNumFaces () const ; int GetRawNumNodes () const ; int GetNumCells () const ; int GetNumFaces () const ; int GetNumNodes () const ; const Cell & GetCell ( int cellIndex ) const ; const Face & GetFace ( int faceIndex ) const ; const Node & GetNode ( int nodeIndex ) const ; std :: vector < std :: string > GetPatchIds () const ; std :: vector < std :: string > GetZoneIds () const ; std :: vector < int > GetPatchFaceIndexes ( const std :: string & patchId ) const ; std :: vector < int > GetZoneCellIndexes ( const std :: string & zoneId ) const ; const std :: vector < int > & GetBoundaryFaceIndexes () const ; const std :: vector < int > & GetBoundaryCellIndexes () const ; // Methods used for mesh analysis. // const MultiIndexMap < double > & GetBoundaryCenterDistances () const ; double GetBoundaryCenterDistance ( int cellIdx , int boundaryFaceIdx ) const ; const MultiIndexMap < double > & GetCellCenterDistances () const ; double GetCellCenterDistance ( int cellIdx , int neighborCellIdx ) const ; const MultiIndexMap < double > & GetCellWeightAtFace () const ; double GetCellWeightAtFace ( int cellIdx , int faceIdx ) const ; const std :: unordered_map < int , Vector < double >> & GetFaceCorrectionVector () const ; const Vector < double > & GetFaceCorrectionVector ( int faceIdx ) const ; protected : // Methods used for activating mesh data. // virtual void CollectCellsSharedNode (); virtual void CollectFacesSharedNode (); virtual void CollectCellsSharedFace (); virtual void CollectCellNeighbors (); virtual void CollectCellsInZone (){}; virtual void SortNodes (); virtual void CalculateFaceDirector (); virtual void CalculateFaceNormal (){}; virtual void CalculateFaceArea (){}; virtual void CalculateFacePerimeter (){}; virtual void CalculateCellSurface (){}; virtual void CalculateCellVolume (){}; virtual void CheckMesh () const ; // Methods used for analysing mesh data. // virtual void CalculateCellDistances (); virtual void CalculateBoundaryCenterDistances (); virtual void CollectBoundaryFacesAndCells (); virtual void CalculateFaceIntersections (); virtual void CalculateFaceWeights (); virtual void CalculateFaceCorrectionVector (); inline double CalculateDistance ( const Coordinate & n1 , const Coordinate & n2 ) const { return sqrt ( pow ( n1 . x - n2 . x , 2 ) + pow ( n1 . y - n2 . y , 2 ) + pow ( n1 . z - n2 . z , 2 )); } }; } // namespace OpenOasis::CommImp::Spatial","title":"File Grid.h"},{"location":"models/_grid_8h_source/#file-gridh","text":"File List > CommImp > Spatial > Grid.h Go to the documentation of this file #pragma once #include \"MeshStructs.h\" #include \"Models/CommImp/Numeric/Vector.h\" #include \"Models/Utils/MultiIndexMapper.h\" #include <string> #include <memory> namespace OpenOasis :: CommImp :: Spatial { using Numeric :: Vector ; using Utils :: MultiIndexMap ; class Grid { protected : Mesh mMesh ; // The number of original objects in the mesh before // refining or coarsening. int mRawNodesNum , mRawCellsNum , mRawFacesNum ; // The boundary cells and faces. std :: vector < int > mBoundaryCells ; std :: vector < int > mBoundaryFaces ; // The outer or inner boundary patches, each of them // is composed of Face indexes. std :: unordered_map < std :: string , std :: vector < int >> mPatches ; // The zone enclosed by Face indexes. std :: unordered_map < std :: string , std :: vector < int >> mZones ; // The zone composed of Cell indexes. std :: unordered_map < std :: string , std :: vector < int >> mZoneCells ; // The distances between cell centroids. MultiIndexMap < double > mCenterDists ; // The distances between cell centroid and boundary face. MultiIndexMap < double > mBoundaryCenterDists ; // The interfacial intersection point with line of cell centers. std :: unordered_map < int , Coordinate > mFaceIntersection ; // The weight of each cell at face. MultiIndexMap < double > mCellFaceWeight ; // The distance between face centroid and intersection. std :: unordered_map < int , Vector < double >> mFaceCorrVecs ; public : virtual ~ Grid () = default ; Grid ( const std :: shared_ptr < Grid > & grid ); Grid ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int >> & faceNodes , std :: unordered_map < int , std :: vector < int >> & cellFaces , std :: unordered_map < std :: string , std :: vector < int >> & patches , std :: unordered_map < std :: string , std :: vector < int >> & zones ); // Methods used for mesh operations. // virtual int Type () const = 0 ; virtual void Activate (); virtual void RefineCell ( int cellIndex ) = 0 ; virtual void RelaxCell ( int cellIndex ) = 0 ; // Methods used for mesh query. // int GetRawNumCells () const ; int GetRawNumFaces () const ; int GetRawNumNodes () const ; int GetNumCells () const ; int GetNumFaces () const ; int GetNumNodes () const ; const Cell & GetCell ( int cellIndex ) const ; const Face & GetFace ( int faceIndex ) const ; const Node & GetNode ( int nodeIndex ) const ; std :: vector < std :: string > GetPatchIds () const ; std :: vector < std :: string > GetZoneIds () const ; std :: vector < int > GetPatchFaceIndexes ( const std :: string & patchId ) const ; std :: vector < int > GetZoneCellIndexes ( const std :: string & zoneId ) const ; const std :: vector < int > & GetBoundaryFaceIndexes () const ; const std :: vector < int > & GetBoundaryCellIndexes () const ; // Methods used for mesh analysis. // const MultiIndexMap < double > & GetBoundaryCenterDistances () const ; double GetBoundaryCenterDistance ( int cellIdx , int boundaryFaceIdx ) const ; const MultiIndexMap < double > & GetCellCenterDistances () const ; double GetCellCenterDistance ( int cellIdx , int neighborCellIdx ) const ; const MultiIndexMap < double > & GetCellWeightAtFace () const ; double GetCellWeightAtFace ( int cellIdx , int faceIdx ) const ; const std :: unordered_map < int , Vector < double >> & GetFaceCorrectionVector () const ; const Vector < double > & GetFaceCorrectionVector ( int faceIdx ) const ; protected : // Methods used for activating mesh data. // virtual void CollectCellsSharedNode (); virtual void CollectFacesSharedNode (); virtual void CollectCellsSharedFace (); virtual void CollectCellNeighbors (); virtual void CollectCellsInZone (){}; virtual void SortNodes (); virtual void CalculateFaceDirector (); virtual void CalculateFaceNormal (){}; virtual void CalculateFaceArea (){}; virtual void CalculateFacePerimeter (){}; virtual void CalculateCellSurface (){}; virtual void CalculateCellVolume (){}; virtual void CheckMesh () const ; // Methods used for analysing mesh data. // virtual void CalculateCellDistances (); virtual void CalculateBoundaryCenterDistances (); virtual void CollectBoundaryFacesAndCells (); virtual void CalculateFaceIntersections (); virtual void CalculateFaceWeights (); virtual void CalculateFaceCorrectionVector (); inline double CalculateDistance ( const Coordinate & n1 , const Coordinate & n2 ) const { return sqrt ( pow ( n1 . x - n2 . x , 2 ) + pow ( n1 . y - n2 . y , 2 ) + pow ( n1 . z - n2 . z , 2 )); } }; } // namespace OpenOasis::CommImp::Spatial","title":"File Grid.h"},{"location":"models/_grid1_d_8cpp/","text":"File Grid1D.cpp \u00b6 FileList > CommImp > Spatial > Grid1D.cpp Go to the source code of this file #include \"Grid1D.h\" #include \"Models/Utils/Exception.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid1D.cpp","title":"File Grid1D.cpp"},{"location":"models/_grid1_d_8cpp/#file-grid1dcpp","text":"FileList > CommImp > Spatial > Grid1D.cpp Go to the source code of this file #include \"Grid1D.h\" #include \"Models/Utils/Exception.h\"","title":"File Grid1D.cpp"},{"location":"models/_grid1_d_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid1D.cpp","title":"Namespaces"},{"location":"models/_grid1_d_8cpp_source/","text":"File Grid1D.cpp \u00b6 File List > CommImp > Spatial > Grid1D.cpp Go to the documentation of this file #include \"Grid1D.h\" #include \"Models/Utils/Exception.h\" namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; } // namespace OpenOasis::CommImp::Spatial","title":"File Grid1D.cpp"},{"location":"models/_grid1_d_8cpp_source/#file-grid1dcpp","text":"File List > CommImp > Spatial > Grid1D.cpp Go to the documentation of this file #include \"Grid1D.h\" #include \"Models/Utils/Exception.h\" namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; } // namespace OpenOasis::CommImp::Spatial","title":"File Grid1D.cpp"},{"location":"models/_grid1_d_8h/","text":"File Grid1D.h \u00b6 FileList > CommImp > Spatial > Grid1D.h Go to the source code of this file #include \"Grid.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial Classes \u00b6 Type Name class Grid1D The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid1D.h","title":"File Grid1D.h"},{"location":"models/_grid1_d_8h/#file-grid1dh","text":"FileList > CommImp > Spatial > Grid1D.h Go to the source code of this file #include \"Grid.h\"","title":"File Grid1D.h"},{"location":"models/_grid1_d_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial","title":"Namespaces"},{"location":"models/_grid1_d_8h/#classes","text":"Type Name class Grid1D The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid1D.h","title":"Classes"},{"location":"models/_grid1_d_8h_source/","text":"File Grid1D.h \u00b6 File List > CommImp > Spatial > Grid1D.h Go to the documentation of this file #pragma once #include \"Grid.h\" namespace OpenOasis { namespace CommImp { namespace Spatial { class Grid1D : public Grid { public : virtual ~ Grid1D () = default ; Grid1D ( const std :: shared_ptr < Grid > & grid ); Grid1D ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int >> & faceNodes , std :: unordered_map < int , std :: vector < int >> & cellFaces , std :: unordered_map < std :: string , std :: vector < int >> & patches , std :: unordered_map < std :: string , std :: vector < int >> & zones ); int Type () const override ; void RefineCell ( int cellIndex ) override ; void RelaxCell ( int cellIndex ) override ; private : void CollectCellsInZone () override ; void CalculateFaceNormal () override ; void CalculateFaceArea () override ; void CalculateFacePerimeter () override ; void CalculateCellSurface () override ; void CalculateCellVolume () override ; void CheckMesh () const override ; }; } // namespace Spatial } // namespace CommImp } // namespace OpenOasis","title":"File Grid1D.h"},{"location":"models/_grid1_d_8h_source/#file-grid1dh","text":"File List > CommImp > Spatial > Grid1D.h Go to the documentation of this file #pragma once #include \"Grid.h\" namespace OpenOasis { namespace CommImp { namespace Spatial { class Grid1D : public Grid { public : virtual ~ Grid1D () = default ; Grid1D ( const std :: shared_ptr < Grid > & grid ); Grid1D ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int >> & faceNodes , std :: unordered_map < int , std :: vector < int >> & cellFaces , std :: unordered_map < std :: string , std :: vector < int >> & patches , std :: unordered_map < std :: string , std :: vector < int >> & zones ); int Type () const override ; void RefineCell ( int cellIndex ) override ; void RelaxCell ( int cellIndex ) override ; private : void CollectCellsInZone () override ; void CalculateFaceNormal () override ; void CalculateFaceArea () override ; void CalculateFacePerimeter () override ; void CalculateCellSurface () override ; void CalculateCellVolume () override ; void CheckMesh () const override ; }; } // namespace Spatial } // namespace CommImp } // namespace OpenOasis","title":"File Grid1D.h"},{"location":"models/_grid2_d_8cpp/","text":"File Grid2D.cpp \u00b6 FileList > CommImp > Spatial > Grid2D.cpp Go to the source code of this file #include \"Grid2D.h\" #include \"GeoCalculator.h\" #include \"Models/Utils/Exception.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid2D.cpp","title":"File Grid2D.cpp"},{"location":"models/_grid2_d_8cpp/#file-grid2dcpp","text":"FileList > CommImp > Spatial > Grid2D.cpp Go to the source code of this file #include \"Grid2D.h\" #include \"GeoCalculator.h\" #include \"Models/Utils/Exception.h\"","title":"File Grid2D.cpp"},{"location":"models/_grid2_d_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid2D.cpp","title":"Namespaces"},{"location":"models/_grid2_d_8cpp_source/","text":"File Grid2D.cpp \u00b6 File List > CommImp > Spatial > Grid2D.cpp Go to the documentation of this file #include \"Grid2D.h\" #include \"GeoCalculator.h\" #include \"Models/Utils/Exception.h\" namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; Grid2D :: Grid2D ( unordered_map < int , Coordinate > & nodeCoords , unordered_map < int , Coordinate > & faceCoords , unordered_map < int , Coordinate > & cellCoords , unordered_map < int , vector < int >> & faceNodes , unordered_map < int , vector < int >> & cellFaces , unordered_map < string , vector < int >> & patches , unordered_map < string , vector < int >> & zones ) : Grid ( nodeCoords , faceCoords , cellCoords , faceNodes , cellFaces , patches , zones ) {} Grid2D :: Grid2D ( const shared_ptr < Grid > & grid ) : Grid ( grid ) {} int Grid2D :: Type () const { return 2 ; } void Grid2D :: RefineCell ( int cellIndex ) { throw NotImplementedException ( \"Not implemented\" ); } void Grid2D :: RelaxCell ( int cellIndex ) { throw NotImplementedException ( \"Not implemented\" ); } void Grid2D :: CollectCellsInZone () { // Not implemented. } void Grid2D :: CalculateFaceNormal () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; i ++ ) { mMesh . faces [ i ]. normal = GeoCalculator :: CalculateFaceNormal ( i , mMesh ); } } void Grid2D :: CalculateFaceArea () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; i ++ ) { mMesh . faces [ i ]. area = GeoCalculator :: CalculateFacePerimeter ( i , mMesh ); } } void Grid2D :: CalculateFacePerimeter () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; i ++ ) { mMesh . faces [ i ]. perimeter = GeoCalculator :: CalculateFacePerimeter ( i , mMesh ); } } void Grid2D :: CalculateCellSurface () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawCellsNum ; i ++ ) { mMesh . cells [ i ]. surface = 0.0 ; } } void Grid2D :: CalculateCellVolume () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawCellsNum ; i ++ ) { mMesh . cells [ i ]. volume = 0.0 ; } } void Grid2D :: CheckMesh () const { // Not implemented. } } // namespace OpenOasis::CommImp::Spatial","title":"File Grid2D.cpp"},{"location":"models/_grid2_d_8cpp_source/#file-grid2dcpp","text":"File List > CommImp > Spatial > Grid2D.cpp Go to the documentation of this file #include \"Grid2D.h\" #include \"GeoCalculator.h\" #include \"Models/Utils/Exception.h\" namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; Grid2D :: Grid2D ( unordered_map < int , Coordinate > & nodeCoords , unordered_map < int , Coordinate > & faceCoords , unordered_map < int , Coordinate > & cellCoords , unordered_map < int , vector < int >> & faceNodes , unordered_map < int , vector < int >> & cellFaces , unordered_map < string , vector < int >> & patches , unordered_map < string , vector < int >> & zones ) : Grid ( nodeCoords , faceCoords , cellCoords , faceNodes , cellFaces , patches , zones ) {} Grid2D :: Grid2D ( const shared_ptr < Grid > & grid ) : Grid ( grid ) {} int Grid2D :: Type () const { return 2 ; } void Grid2D :: RefineCell ( int cellIndex ) { throw NotImplementedException ( \"Not implemented\" ); } void Grid2D :: RelaxCell ( int cellIndex ) { throw NotImplementedException ( \"Not implemented\" ); } void Grid2D :: CollectCellsInZone () { // Not implemented. } void Grid2D :: CalculateFaceNormal () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; i ++ ) { mMesh . faces [ i ]. normal = GeoCalculator :: CalculateFaceNormal ( i , mMesh ); } } void Grid2D :: CalculateFaceArea () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; i ++ ) { mMesh . faces [ i ]. area = GeoCalculator :: CalculateFacePerimeter ( i , mMesh ); } } void Grid2D :: CalculateFacePerimeter () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawFacesNum ; i ++ ) { mMesh . faces [ i ]. perimeter = GeoCalculator :: CalculateFacePerimeter ( i , mMesh ); } } void Grid2D :: CalculateCellSurface () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawCellsNum ; i ++ ) { mMesh . cells [ i ]. surface = 0.0 ; } } void Grid2D :: CalculateCellVolume () { #pragma omp parallel for schedule(dynamic) for ( int i = 0 ; i < mRawCellsNum ; i ++ ) { mMesh . cells [ i ]. volume = 0.0 ; } } void Grid2D :: CheckMesh () const { // Not implemented. } } // namespace OpenOasis::CommImp::Spatial","title":"File Grid2D.cpp"},{"location":"models/_grid2_d_8h/","text":"File Grid2D.h \u00b6 FileList > CommImp > Spatial > Grid2D.h Go to the source code of this file #include \"Grid.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial Classes \u00b6 Type Name class Grid2D Grid formed by flat cells in 2d. The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid2D.h","title":"File Grid2D.h"},{"location":"models/_grid2_d_8h/#file-grid2dh","text":"FileList > CommImp > Spatial > Grid2D.h Go to the source code of this file #include \"Grid.h\"","title":"File Grid2D.h"},{"location":"models/_grid2_d_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial","title":"Namespaces"},{"location":"models/_grid2_d_8h/#classes","text":"Type Name class Grid2D Grid formed by flat cells in 2d. The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid2D.h","title":"Classes"},{"location":"models/_grid2_d_8h_source/","text":"File Grid2D.h \u00b6 File List > CommImp > Spatial > Grid2D.h Go to the documentation of this file #pragma once #include \"Grid.h\" namespace OpenOasis { namespace CommImp { namespace Spatial { class Grid2D : public Grid { public : virtual ~ Grid2D () = default ; Grid2D ( const std :: shared_ptr < Grid > & grid ); Grid2D ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int >> & faceNodes , std :: unordered_map < int , std :: vector < int >> & cellFaces , std :: unordered_map < std :: string , std :: vector < int >> & patches , std :: unordered_map < std :: string , std :: vector < int >> & zones ); int Type () const override ; void RefineCell ( int cellIndex ) override ; void RelaxCell ( int cellIndex ) override ; private : void CollectCellsInZone () override ; void CalculateFaceNormal () override ; void CalculateFaceArea () override ; void CalculateFacePerimeter () override ; void CalculateCellSurface () override ; void CalculateCellVolume () override ; void CheckMesh () const override ; }; } // namespace Spatial } // namespace CommImp } // namespace OpenOasis","title":"File Grid2D.h"},{"location":"models/_grid2_d_8h_source/#file-grid2dh","text":"File List > CommImp > Spatial > Grid2D.h Go to the documentation of this file #pragma once #include \"Grid.h\" namespace OpenOasis { namespace CommImp { namespace Spatial { class Grid2D : public Grid { public : virtual ~ Grid2D () = default ; Grid2D ( const std :: shared_ptr < Grid > & grid ); Grid2D ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int >> & faceNodes , std :: unordered_map < int , std :: vector < int >> & cellFaces , std :: unordered_map < std :: string , std :: vector < int >> & patches , std :: unordered_map < std :: string , std :: vector < int >> & zones ); int Type () const override ; void RefineCell ( int cellIndex ) override ; void RelaxCell ( int cellIndex ) override ; private : void CollectCellsInZone () override ; void CalculateFaceNormal () override ; void CalculateFaceArea () override ; void CalculateFacePerimeter () override ; void CalculateCellSurface () override ; void CalculateCellVolume () override ; void CheckMesh () const override ; }; } // namespace Spatial } // namespace CommImp } // namespace OpenOasis","title":"File Grid2D.h"},{"location":"models/_grid3_d_8cpp/","text":"File Grid3D.cpp \u00b6 FileList > CommImp > Spatial > Grid3D.cpp Go to the source code of this file #include \"Grid3D.h\" #include \"Models/Utils/Exception.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid3D.cpp","title":"File Grid3D.cpp"},{"location":"models/_grid3_d_8cpp/#file-grid3dcpp","text":"FileList > CommImp > Spatial > Grid3D.cpp Go to the source code of this file #include \"Grid3D.h\" #include \"Models/Utils/Exception.h\"","title":"File Grid3D.cpp"},{"location":"models/_grid3_d_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid3D.cpp","title":"Namespaces"},{"location":"models/_grid3_d_8cpp_source/","text":"File Grid3D.cpp \u00b6 File List > CommImp > Spatial > Grid3D.cpp Go to the documentation of this file #include \"Grid3D.h\" #include \"Models/Utils/Exception.h\" namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; } // namespace OpenOasis::CommImp::Spatial","title":"File Grid3D.cpp"},{"location":"models/_grid3_d_8cpp_source/#file-grid3dcpp","text":"File List > CommImp > Spatial > Grid3D.cpp Go to the documentation of this file #include \"Grid3D.h\" #include \"Models/Utils/Exception.h\" namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; } // namespace OpenOasis::CommImp::Spatial","title":"File Grid3D.cpp"},{"location":"models/_grid3_d_8h/","text":"File Grid3D.h \u00b6 FileList > CommImp > Spatial > Grid3D.h Go to the source code of this file #include \"Grid.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial Classes \u00b6 Type Name class Grid3D The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid3D.h","title":"File Grid3D.h"},{"location":"models/_grid3_d_8h/#file-grid3dh","text":"FileList > CommImp > Spatial > Grid3D.h Go to the source code of this file #include \"Grid.h\"","title":"File Grid3D.h"},{"location":"models/_grid3_d_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial","title":"Namespaces"},{"location":"models/_grid3_d_8h/#classes","text":"Type Name class Grid3D The documentation for this class was generated from the following file Models/CommImp/Spatial/Grid3D.h","title":"Classes"},{"location":"models/_grid3_d_8h_source/","text":"File Grid3D.h \u00b6 File List > CommImp > Spatial > Grid3D.h Go to the documentation of this file #pragma once #include \"Grid.h\" namespace OpenOasis { namespace CommImp { namespace Spatial { class Grid3D : public Grid { public : virtual ~ Grid3D () = default ; Grid3D ( const std :: shared_ptr < Grid > & grid ); Grid3D ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int >> & faceNodes , std :: unordered_map < int , std :: vector < int >> & cellFaces , std :: unordered_map < std :: string , std :: vector < int >> & patches , std :: unordered_map < std :: string , std :: vector < int >> & zones ); int Type () const override ; void RefineCell ( int cellIndex ) override ; void RelaxCell ( int cellIndex ) override ; private : void CollectCellsInZone () override ; void CalculateFaceNormal () override ; void CalculateFaceArea () override ; void CalculateFacePerimeter () override ; void CalculateCellSurface () override ; void CalculateCellVolume () override ; void CheckMesh () const override ; }; } // namespace Spatial } // namespace CommImp } // namespace OpenOasis","title":"File Grid3D.h"},{"location":"models/_grid3_d_8h_source/#file-grid3dh","text":"File List > CommImp > Spatial > Grid3D.h Go to the documentation of this file #pragma once #include \"Grid.h\" namespace OpenOasis { namespace CommImp { namespace Spatial { class Grid3D : public Grid { public : virtual ~ Grid3D () = default ; Grid3D ( const std :: shared_ptr < Grid > & grid ); Grid3D ( std :: unordered_map < int , Coordinate > & nodeCoords , std :: unordered_map < int , Coordinate > & faceCoords , std :: unordered_map < int , Coordinate > & cellCoords , std :: unordered_map < int , std :: vector < int >> & faceNodes , std :: unordered_map < int , std :: vector < int >> & cellFaces , std :: unordered_map < std :: string , std :: vector < int >> & patches , std :: unordered_map < std :: string , std :: vector < int >> & zones ); int Type () const override ; void RefineCell ( int cellIndex ) override ; void RelaxCell ( int cellIndex ) override ; private : void CollectCellsInZone () override ; void CalculateFaceNormal () override ; void CalculateFaceArea () override ; void CalculateFacePerimeter () override ; void CalculateCellSurface () override ; void CalculateCellVolume () override ; void CheckMesh () const override ; }; } // namespace Spatial } // namespace CommImp } // namespace OpenOasis","title":"File Grid3D.h"},{"location":"models/_mesh_structs_8h/","text":"File MeshStructs.h \u00b6 FileList > CommImp > Spatial > MeshStructs.h Go to the source code of this file #include \"Coordinate.h\" #include <vector> #include <array> #include <unordered_map> #include <cmath> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial Classes \u00b6 Type Name struct Cell Mesh cell data structure. Polygon type for 1D and 2D mesh, Polyhedron type for 3D mesh. struct Face Mesh face data structure. Polyline type for 1D or 2D mesh, Polygon type for 3D mesh. struct Mesh Mesh structure. struct Node Mesh node data structure. (Point type). The documentation for this class was generated from the following file Models/CommImp/Spatial/MeshStructs.h","title":"File MeshStructs.h"},{"location":"models/_mesh_structs_8h/#file-meshstructsh","text":"FileList > CommImp > Spatial > MeshStructs.h Go to the source code of this file #include \"Coordinate.h\" #include <vector> #include <array> #include <unordered_map> #include <cmath>","title":"File MeshStructs.h"},{"location":"models/_mesh_structs_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial","title":"Namespaces"},{"location":"models/_mesh_structs_8h/#classes","text":"Type Name struct Cell Mesh cell data structure. Polygon type for 1D and 2D mesh, Polyhedron type for 3D mesh. struct Face Mesh face data structure. Polyline type for 1D or 2D mesh, Polygon type for 3D mesh. struct Mesh Mesh structure. struct Node Mesh node data structure. (Point type). The documentation for this class was generated from the following file Models/CommImp/Spatial/MeshStructs.h","title":"Classes"},{"location":"models/_mesh_structs_8h_source/","text":"File MeshStructs.h \u00b6 File List > CommImp > Spatial > MeshStructs.h Go to the documentation of this file #pragma once #include \"Coordinate.h\" #include <vector> #include <array> #include <unordered_map> #include <cmath> namespace OpenOasis { namespace CommImp { namespace Spatial { struct Node { Coordinate coor ; // unit(m). // Indexes of mesh faces shared the node. std :: vector < int > faceIndexes ; // Indexes of mesh cells shared the node. std :: vector < int > cellIndexes ; }; struct Face { Coordinate centroid ; // Perimeter of the face in (m). real perimeter = NAN ; // Area of the face in (m^2). real area = NAN ; // Unit normal vector. std :: array < real , 3 > normal ; // Indexes of mesh nodes on the // face sorted counterclockwise. std :: vector < int > nodeIndexes ; // Indexes of mesh cells shared // the face. std :: vector < int > cellIndexes ; // Orientation of cells to face // (Same or opposite to normal) // (Corresponds to cellIndexes) std :: vector < int > cellSides ; }; struct Cell { Coordinate centroid ; // Volume of the cell in (m^3). real volume = NAN ; // Surface area in (m^2). real surface = NAN ; // Indexes of faces on the cell. std :: vector < int > faceIndexes ; // Indexes of neighboring cells. std :: vector < int > neighbors ; // Indexes of sub-cells // after current cell's refined. std :: vector < int > subCells ; }; struct Mesh { // Mesh nodes set. std :: unordered_map < int , Node > nodes ; // Mesh faces set. std :: unordered_map < int , Face > faces ; // Mesh cells set. std :: unordered_map < int , Cell > cells ; }; } // namespace Spatial } // namespace CommImp } // namespace OpenOasis","title":"File MeshStructs.h"},{"location":"models/_mesh_structs_8h_source/#file-meshstructsh","text":"File List > CommImp > Spatial > MeshStructs.h Go to the documentation of this file #pragma once #include \"Coordinate.h\" #include <vector> #include <array> #include <unordered_map> #include <cmath> namespace OpenOasis { namespace CommImp { namespace Spatial { struct Node { Coordinate coor ; // unit(m). // Indexes of mesh faces shared the node. std :: vector < int > faceIndexes ; // Indexes of mesh cells shared the node. std :: vector < int > cellIndexes ; }; struct Face { Coordinate centroid ; // Perimeter of the face in (m). real perimeter = NAN ; // Area of the face in (m^2). real area = NAN ; // Unit normal vector. std :: array < real , 3 > normal ; // Indexes of mesh nodes on the // face sorted counterclockwise. std :: vector < int > nodeIndexes ; // Indexes of mesh cells shared // the face. std :: vector < int > cellIndexes ; // Orientation of cells to face // (Same or opposite to normal) // (Corresponds to cellIndexes) std :: vector < int > cellSides ; }; struct Cell { Coordinate centroid ; // Volume of the cell in (m^3). real volume = NAN ; // Surface area in (m^2). real surface = NAN ; // Indexes of faces on the cell. std :: vector < int > faceIndexes ; // Indexes of neighboring cells. std :: vector < int > neighbors ; // Indexes of sub-cells // after current cell's refined. std :: vector < int > subCells ; }; struct Mesh { // Mesh nodes set. std :: unordered_map < int , Node > nodes ; // Mesh faces set. std :: unordered_map < int , Face > faces ; // Mesh cells set. std :: unordered_map < int , Cell > cells ; }; } // namespace Spatial } // namespace CommImp } // namespace OpenOasis","title":"File MeshStructs.h"},{"location":"models/_x_y_geo_structs_8cpp/","text":"File XYGeoStructs.cpp \u00b6 FileList > CommImp > Spatial > XYGeoStructs.cpp Go to the source code of this file #include \"XYGeoStructs.h\" #include \"XYGeoTools.h\" #include \"Models/Utils/CommConstants.h\" #include \"Models/Utils/StringHelper.h\" #include \"Models/Utils/Exception.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoStructs.cpp","title":"File XYGeoStructs.cpp"},{"location":"models/_x_y_geo_structs_8cpp/#file-xygeostructscpp","text":"FileList > CommImp > Spatial > XYGeoStructs.cpp Go to the source code of this file #include \"XYGeoStructs.h\" #include \"XYGeoTools.h\" #include \"Models/Utils/CommConstants.h\" #include \"Models/Utils/StringHelper.h\" #include \"Models/Utils/Exception.h\"","title":"File XYGeoStructs.cpp"},{"location":"models/_x_y_geo_structs_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoStructs.cpp","title":"Namespaces"},{"location":"models/_x_y_geo_structs_8cpp_source/","text":"File XYGeoStructs.cpp \u00b6 File List > CommImp > Spatial > XYGeoStructs.cpp Go to the documentation of this file #include \"XYGeoStructs.h\" #include \"XYGeoTools.h\" #include \"Models/Utils/CommConstants.h\" #include \"Models/Utils/StringHelper.h\" #include \"Models/Utils/Exception.h\" namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; // struct XYPoint --------------------------------------------------------------------- XYPoint :: XYPoint ( double coorX , double coorY ) { x = coorX ; y = coorY ; } XYPoint :: XYPoint ( const Coordinate & coor ) { x = coor . x ; y = coor . y ; } XYPoint :: XYPoint ( const XYPoint & point ) { x = point . x ; y = point . y ; } // struct XYLine ---------------------------------------------------------------------- XYLine :: XYLine ( double x1 , double y1 , double x2 , double y2 ) { point1 = XYPoint ( x1 , y1 ); point2 = XYPoint ( x2 , y2 ); } XYLine :: XYLine ( const XYPoint & p1 , const XYPoint & p2 ) { point1 = p1 ; point2 = p2 ; } XYLine :: XYLine ( const XYLine & line ) { point1 = line . point1 ; point2 = line . point2 ; } double XYLine :: GetLength () const { double dx = point2 . x - point1 . x ; double dy = point2 . y - point1 . y ; return sqrt ( dx * dx + dy * dy ); } // struct XYPolyline ------------------------------------------------------------------ XYPolyline :: XYPolyline ( const vector < XYPoint > & xyPoints ) { points = xyPoints ; } XYPolyline :: XYPolyline ( const XYPolyline & pline ) { points = pline . points ; } bool XYPolyline :: Validate () const { if ( points . empty () || points . size () < 2 ) { throw runtime_error ( \"Number of vertices in polyline element is less than 2.\" ); } for ( int i = 0 ; i < ( int ) points . size () - 1 ; i ++ ) { if ( GetLine ( i ). GetLength () <= 0.0 ) { throw runtime_error ( StringHelper :: FormatSimple ( \"Length of line segment no: [{}] (0-based) of XYPolyline is zero.\" , i )); } } return true ; } XYLine XYPolyline :: GetLine ( int lineNumber ) const { if ( points . empty () || lineNumber >= ( int ) points . size ()) { throw runtime_error ( \"The line segment index exceeds the XYPolyLine size.\" ); } return XYLine ( points [ lineNumber - 1 ], points [ lineNumber ]); } double XYPolyline :: GetLength () const { if ( points . empty ()) return 0.0 ; double len = 0.0 ; for ( int i = 0 ; i < ( int ) points . size () - 1 ; ++ i ) { len += GetLine ( i ). GetLength (); } return len ; } // struct XYPolygon ------------------------------------------------------------------- XYPolygon :: XYPolygon ( const vector < XYPoint > & xypoints ) { points = xypoints ; } XYPolygon :: XYPolygon ( const XYPolygon & polygon ) { points = polygon . points ; } bool XYPolygon :: Validate () const { if ( points . empty () || points . size () < 3 ) { throw runtime_error ( \"Number of vertices in polygon element is less than 3.\" ); } if ( GetArea () <= 0.0 ) { throw runtime_error ( \"Area of polygon is negative or zero.\" ); } for ( int i = 0 ; i < ( int ) points . size () - 1 ; i ++ ) { if ( GetLine ( i ). GetLength () <= 0.0 ) { throw runtime_error ( StringHelper :: FormatSimple ( \"Length of line segment no: [{}] (0-based) of XYPolyon is zero.\" , i )); } for ( int j = 0 ; j < i ; ++ j ) { if ( XYGeoTools :: IsLinesIntersected ( GetLine ( j ), GetLine ( i ))) { throw runtime_error ( StringHelper :: FormatSimple ( \"Line no: [{}] and line no: [{}] of XYPolygon crosses.\" , j , i )); } } } return true ; } double XYPolygon :: GetArea () const { // For a polygon, Assuming the coordinates of each vertice are known: // A1(x1, y1), A2(x2, y2), A3(x3, y3), ..., An(xn, yn), // // then, the area of the polygon is: // S = 0.5 * |\u2211(x_i * y_i+1 - x_i+1 * y_i)|, for i = 0, ...n // // Among them, x_n+1 = x_1, y_n+1 = y_1. // if ( points . empty () || points . size () < 3 ) return 0.0 ; auto size = ( int ) points . size (); double area = 0.0 ; for ( int i = 0 ; i < size - 1 ; ++ i ) { area += points [ i ]. x * points [ i + 1 ]. y - points [ i + 1 ]. x * points [ i ]. y ; } area += points [ size - 1 ]. x * points [ 0 ]. y - points [ 0 ]. x * points [ size - 1 ]. y ; area *= 0.5 ; return abs ( area ); } XYLine XYPolygon :: GetLine ( int lineNumber ) const { if ( points . empty () || lineNumber >= ( int ) points . size ()) { throw runtime_error ( \"The line segment index exceeds the XYPolygon size.\" ); } int index2 = ( lineNumber == ( int ) points . size () - 1 ) ? 0 : lineNumber + 1 ; return XYLine ( points [ lineNumber ], points [ index2 ]); } bool XYPolygon :: IsConvex ( int index ) const { // Acute angles are convex. if ( points . empty ()) { return false ; } auto prevIndex = ( index - 1 < 0 ) ? ( int ) points . size () - 1 : index - 1 ; auto nextIndex = ( index + 1 > ( int ) points . size () - 1 ) ? 0 : index + 1 ; const XYPoint & p1 = points [ prevIndex ], & p2 = points [ nextIndex ], & p = points [ index ]; double dot = ( p1 . x - p . x ) * ( p2 . x - p . x ) + ( p1 . y - p . y ) * ( p2 . y - p . y ); return ( IsBigger ( dot , 0.0 )) ? true : false ; } // struct XYExtent -------------------------------------------------------------------- XYExtent :: XYExtent ( const XYExtent & obj ) { xMin = obj . xMin ; xMax = obj . xMax ; yMin = obj . yMin ; yMax = obj . yMax ; } XYExtent :: XYExtent ( const XYPoint & point , double epsilon ) { xMin = point . x - epsilon ; xMax = point . x + epsilon ; yMin = point . y - epsilon ; yMax = point . y + epsilon ; } XYExtent :: XYExtent ( const XYLine & line ) { xMin = std :: min ( line . point1 . x , line . point2 . x ); xMax = std :: max ( line . point1 . x , line . point2 . x ); yMin = std :: min ( line . point1 . y , line . point2 . y ); yMax = std :: max ( line . point1 . y , line . point2 . y ); } XYExtent :: XYExtent ( const XYPolyline & polyline ) { for ( const auto & p : polyline . points ) { Include ( p . x , p . y ); } } XYExtent :: XYExtent ( const XYPolygon & polygon ) { for ( const auto & p : polygon . points ) { Include ( p . x , p . y ); } } XYExtent :: XYExtent ( double xmin , double xmax , double ymin , double ymax ) { xMin = xmin ; xMax = xmax ; yMin = ymin ; yMax = ymax ; } void XYExtent :: Include ( const XYExtent & other ) { if ( other . xMin < xMin ) { xMin = other . xMin ; } if ( other . xMax > xMax ) { xMax = other . xMax ; } if ( other . yMin < yMin ) { yMin = other . yMin ; } if ( other . yMax > yMax ) { yMax = other . yMax ; } } void XYExtent :: Include ( double x , double y ) { if ( x < xMin ) { xMin = x ; } if ( x > xMax ) { xMax = x ; } if ( y < yMin ) { yMin = y ; } if ( y > yMax ) { yMax = y ; } } bool XYExtent :: IsContains ( double x , double y ) const { return xMin <= x && x <= xMax && yMin <= y && y <= yMax ; } bool XYExtent :: IsOverlaps ( const XYExtent & other ) const { return xMin <= other . xMax && xMax >= other . xMin && yMin <= other . yMax && yMax >= other . yMin ; } } // namespace OpenOasis::CommImp::Spatial","title":"File XYGeoStructs.cpp"},{"location":"models/_x_y_geo_structs_8cpp_source/#file-xygeostructscpp","text":"File List > CommImp > Spatial > XYGeoStructs.cpp Go to the documentation of this file #include \"XYGeoStructs.h\" #include \"XYGeoTools.h\" #include \"Models/Utils/CommConstants.h\" #include \"Models/Utils/StringHelper.h\" #include \"Models/Utils/Exception.h\" namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; // struct XYPoint --------------------------------------------------------------------- XYPoint :: XYPoint ( double coorX , double coorY ) { x = coorX ; y = coorY ; } XYPoint :: XYPoint ( const Coordinate & coor ) { x = coor . x ; y = coor . y ; } XYPoint :: XYPoint ( const XYPoint & point ) { x = point . x ; y = point . y ; } // struct XYLine ---------------------------------------------------------------------- XYLine :: XYLine ( double x1 , double y1 , double x2 , double y2 ) { point1 = XYPoint ( x1 , y1 ); point2 = XYPoint ( x2 , y2 ); } XYLine :: XYLine ( const XYPoint & p1 , const XYPoint & p2 ) { point1 = p1 ; point2 = p2 ; } XYLine :: XYLine ( const XYLine & line ) { point1 = line . point1 ; point2 = line . point2 ; } double XYLine :: GetLength () const { double dx = point2 . x - point1 . x ; double dy = point2 . y - point1 . y ; return sqrt ( dx * dx + dy * dy ); } // struct XYPolyline ------------------------------------------------------------------ XYPolyline :: XYPolyline ( const vector < XYPoint > & xyPoints ) { points = xyPoints ; } XYPolyline :: XYPolyline ( const XYPolyline & pline ) { points = pline . points ; } bool XYPolyline :: Validate () const { if ( points . empty () || points . size () < 2 ) { throw runtime_error ( \"Number of vertices in polyline element is less than 2.\" ); } for ( int i = 0 ; i < ( int ) points . size () - 1 ; i ++ ) { if ( GetLine ( i ). GetLength () <= 0.0 ) { throw runtime_error ( StringHelper :: FormatSimple ( \"Length of line segment no: [{}] (0-based) of XYPolyline is zero.\" , i )); } } return true ; } XYLine XYPolyline :: GetLine ( int lineNumber ) const { if ( points . empty () || lineNumber >= ( int ) points . size ()) { throw runtime_error ( \"The line segment index exceeds the XYPolyLine size.\" ); } return XYLine ( points [ lineNumber - 1 ], points [ lineNumber ]); } double XYPolyline :: GetLength () const { if ( points . empty ()) return 0.0 ; double len = 0.0 ; for ( int i = 0 ; i < ( int ) points . size () - 1 ; ++ i ) { len += GetLine ( i ). GetLength (); } return len ; } // struct XYPolygon ------------------------------------------------------------------- XYPolygon :: XYPolygon ( const vector < XYPoint > & xypoints ) { points = xypoints ; } XYPolygon :: XYPolygon ( const XYPolygon & polygon ) { points = polygon . points ; } bool XYPolygon :: Validate () const { if ( points . empty () || points . size () < 3 ) { throw runtime_error ( \"Number of vertices in polygon element is less than 3.\" ); } if ( GetArea () <= 0.0 ) { throw runtime_error ( \"Area of polygon is negative or zero.\" ); } for ( int i = 0 ; i < ( int ) points . size () - 1 ; i ++ ) { if ( GetLine ( i ). GetLength () <= 0.0 ) { throw runtime_error ( StringHelper :: FormatSimple ( \"Length of line segment no: [{}] (0-based) of XYPolyon is zero.\" , i )); } for ( int j = 0 ; j < i ; ++ j ) { if ( XYGeoTools :: IsLinesIntersected ( GetLine ( j ), GetLine ( i ))) { throw runtime_error ( StringHelper :: FormatSimple ( \"Line no: [{}] and line no: [{}] of XYPolygon crosses.\" , j , i )); } } } return true ; } double XYPolygon :: GetArea () const { // For a polygon, Assuming the coordinates of each vertice are known: // A1(x1, y1), A2(x2, y2), A3(x3, y3), ..., An(xn, yn), // // then, the area of the polygon is: // S = 0.5 * |\u2211(x_i * y_i+1 - x_i+1 * y_i)|, for i = 0, ...n // // Among them, x_n+1 = x_1, y_n+1 = y_1. // if ( points . empty () || points . size () < 3 ) return 0.0 ; auto size = ( int ) points . size (); double area = 0.0 ; for ( int i = 0 ; i < size - 1 ; ++ i ) { area += points [ i ]. x * points [ i + 1 ]. y - points [ i + 1 ]. x * points [ i ]. y ; } area += points [ size - 1 ]. x * points [ 0 ]. y - points [ 0 ]. x * points [ size - 1 ]. y ; area *= 0.5 ; return abs ( area ); } XYLine XYPolygon :: GetLine ( int lineNumber ) const { if ( points . empty () || lineNumber >= ( int ) points . size ()) { throw runtime_error ( \"The line segment index exceeds the XYPolygon size.\" ); } int index2 = ( lineNumber == ( int ) points . size () - 1 ) ? 0 : lineNumber + 1 ; return XYLine ( points [ lineNumber ], points [ index2 ]); } bool XYPolygon :: IsConvex ( int index ) const { // Acute angles are convex. if ( points . empty ()) { return false ; } auto prevIndex = ( index - 1 < 0 ) ? ( int ) points . size () - 1 : index - 1 ; auto nextIndex = ( index + 1 > ( int ) points . size () - 1 ) ? 0 : index + 1 ; const XYPoint & p1 = points [ prevIndex ], & p2 = points [ nextIndex ], & p = points [ index ]; double dot = ( p1 . x - p . x ) * ( p2 . x - p . x ) + ( p1 . y - p . y ) * ( p2 . y - p . y ); return ( IsBigger ( dot , 0.0 )) ? true : false ; } // struct XYExtent -------------------------------------------------------------------- XYExtent :: XYExtent ( const XYExtent & obj ) { xMin = obj . xMin ; xMax = obj . xMax ; yMin = obj . yMin ; yMax = obj . yMax ; } XYExtent :: XYExtent ( const XYPoint & point , double epsilon ) { xMin = point . x - epsilon ; xMax = point . x + epsilon ; yMin = point . y - epsilon ; yMax = point . y + epsilon ; } XYExtent :: XYExtent ( const XYLine & line ) { xMin = std :: min ( line . point1 . x , line . point2 . x ); xMax = std :: max ( line . point1 . x , line . point2 . x ); yMin = std :: min ( line . point1 . y , line . point2 . y ); yMax = std :: max ( line . point1 . y , line . point2 . y ); } XYExtent :: XYExtent ( const XYPolyline & polyline ) { for ( const auto & p : polyline . points ) { Include ( p . x , p . y ); } } XYExtent :: XYExtent ( const XYPolygon & polygon ) { for ( const auto & p : polygon . points ) { Include ( p . x , p . y ); } } XYExtent :: XYExtent ( double xmin , double xmax , double ymin , double ymax ) { xMin = xmin ; xMax = xmax ; yMin = ymin ; yMax = ymax ; } void XYExtent :: Include ( const XYExtent & other ) { if ( other . xMin < xMin ) { xMin = other . xMin ; } if ( other . xMax > xMax ) { xMax = other . xMax ; } if ( other . yMin < yMin ) { yMin = other . yMin ; } if ( other . yMax > yMax ) { yMax = other . yMax ; } } void XYExtent :: Include ( double x , double y ) { if ( x < xMin ) { xMin = x ; } if ( x > xMax ) { xMax = x ; } if ( y < yMin ) { yMin = y ; } if ( y > yMax ) { yMax = y ; } } bool XYExtent :: IsContains ( double x , double y ) const { return xMin <= x && x <= xMax && yMin <= y && y <= yMax ; } bool XYExtent :: IsOverlaps ( const XYExtent & other ) const { return xMin <= other . xMax && xMax >= other . xMin && yMin <= other . yMax && yMax >= other . yMin ; } } // namespace OpenOasis::CommImp::Spatial","title":"File XYGeoStructs.cpp"},{"location":"models/_x_y_geo_structs_8h/","text":"File XYGeoStructs.h \u00b6 FileList > CommImp > Spatial > XYGeoStructs.h Go to the source code of this file #include \"Coordinate.h\" #include <vector> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial Classes \u00b6 Type Name struct XYExtent Extent is a rectangle in xy-space. struct XYLine The XYline struct is used for representing a line segment. struct XYPoint XYPoint is simply a x and y coordinate point (has no z coordinate). struct XYPolygon The XYPolygon struct defines a polygon in the XY plane (no z coordinate). struct XYPolyline XYPolyline is a collection of points (at least 2) connected with straigth lines. XYPolylines are typically used for presentation of 1D data, river network. The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoStructs.h","title":"File XYGeoStructs.h"},{"location":"models/_x_y_geo_structs_8h/#file-xygeostructsh","text":"FileList > CommImp > Spatial > XYGeoStructs.h Go to the source code of this file #include \"Coordinate.h\" #include <vector>","title":"File XYGeoStructs.h"},{"location":"models/_x_y_geo_structs_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial","title":"Namespaces"},{"location":"models/_x_y_geo_structs_8h/#classes","text":"Type Name struct XYExtent Extent is a rectangle in xy-space. struct XYLine The XYline struct is used for representing a line segment. struct XYPoint XYPoint is simply a x and y coordinate point (has no z coordinate). struct XYPolygon The XYPolygon struct defines a polygon in the XY plane (no z coordinate). struct XYPolyline XYPolyline is a collection of points (at least 2) connected with straigth lines. XYPolylines are typically used for presentation of 1D data, river network. The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoStructs.h","title":"Classes"},{"location":"models/_x_y_geo_structs_8h_source/","text":"File XYGeoStructs.h \u00b6 File List > CommImp > Spatial > XYGeoStructs.h Go to the documentation of this file #pragma once #include \"Coordinate.h\" #include <vector> namespace OpenOasis { namespace CommImp { namespace Spatial { struct XYPoint { double x = 0. ; double y = 0. ; XYPoint () = default ; XYPoint ( const XYPoint & obj ); XYPoint ( const Coordinate & coor ); XYPoint ( double coorX , double coorY ); }; struct XYLine { XYPoint point1 ; // The start XYPoint. XYPoint point2 ; // The end XYPoint. XYLine () = default ; XYLine ( double x1 , double y1 , double x2 , double y2 ); XYLine ( const XYPoint & p1 , const XYPoint & p2 ); XYLine ( const XYLine & line ); double GetLength () const ; }; struct XYPolyline { std :: vector < XYPoint > points ; XYPolyline () = default ; XYPolyline ( const std :: vector < XYPoint > & points ); XYPolyline ( const XYPolyline & pline ); bool Validate () const ; double GetLength () const ; XYLine GetLine ( int lineNumber ) const ; }; struct XYPolygon { std :: vector < XYPoint > points ; XYPolygon () = default ; XYPolygon ( const std :: vector < XYPoint > & points ); XYPolygon ( const XYPolygon & polygon ); bool Validate () const ; double GetArea () const ; XYLine GetLine ( int lineNumber ) const ; bool IsConvex ( int index ) const ; }; struct XYExtent { double xMin = 0. ; double xMax = 0. ; double yMin = 0. ; double yMax = 0. ; XYExtent () = default ; XYExtent ( const XYPoint & point , double epsilon ); XYExtent ( const XYLine & line ); XYExtent ( const XYPolyline & polyline ); XYExtent ( const XYPolygon & polygon ); XYExtent ( const XYExtent & obj ); XYExtent ( double xmin , double xmax , double ymin , double ymax ); void Include ( const XYExtent & other ); void Include ( double x , double y ); bool IsContains ( double x , double y ) const ; bool IsOverlaps ( const XYExtent & other ) const ; }; } // namespace Spatial } // namespace CommImp } // namespace OpenOasis","title":"File XYGeoStructs.h"},{"location":"models/_x_y_geo_structs_8h_source/#file-xygeostructsh","text":"File List > CommImp > Spatial > XYGeoStructs.h Go to the documentation of this file #pragma once #include \"Coordinate.h\" #include <vector> namespace OpenOasis { namespace CommImp { namespace Spatial { struct XYPoint { double x = 0. ; double y = 0. ; XYPoint () = default ; XYPoint ( const XYPoint & obj ); XYPoint ( const Coordinate & coor ); XYPoint ( double coorX , double coorY ); }; struct XYLine { XYPoint point1 ; // The start XYPoint. XYPoint point2 ; // The end XYPoint. XYLine () = default ; XYLine ( double x1 , double y1 , double x2 , double y2 ); XYLine ( const XYPoint & p1 , const XYPoint & p2 ); XYLine ( const XYLine & line ); double GetLength () const ; }; struct XYPolyline { std :: vector < XYPoint > points ; XYPolyline () = default ; XYPolyline ( const std :: vector < XYPoint > & points ); XYPolyline ( const XYPolyline & pline ); bool Validate () const ; double GetLength () const ; XYLine GetLine ( int lineNumber ) const ; }; struct XYPolygon { std :: vector < XYPoint > points ; XYPolygon () = default ; XYPolygon ( const std :: vector < XYPoint > & points ); XYPolygon ( const XYPolygon & polygon ); bool Validate () const ; double GetArea () const ; XYLine GetLine ( int lineNumber ) const ; bool IsConvex ( int index ) const ; }; struct XYExtent { double xMin = 0. ; double xMax = 0. ; double yMin = 0. ; double yMax = 0. ; XYExtent () = default ; XYExtent ( const XYPoint & point , double epsilon ); XYExtent ( const XYLine & line ); XYExtent ( const XYPolyline & polyline ); XYExtent ( const XYPolygon & polygon ); XYExtent ( const XYExtent & obj ); XYExtent ( double xmin , double xmax , double ymin , double ymax ); void Include ( const XYExtent & other ); void Include ( double x , double y ); bool IsContains ( double x , double y ) const ; bool IsOverlaps ( const XYExtent & other ) const ; }; } // namespace Spatial } // namespace CommImp } // namespace OpenOasis","title":"File XYGeoStructs.h"},{"location":"models/_x_y_geo_tools_8cpp/","text":"File XYGeoTools.cpp \u00b6 FileList > CommImp > Spatial > XYGeoTools.cpp Go to the source code of this file #include \"XYGeoTools.h\" #include \"Models/Utils/Exception.h\" #include <algorithm> #include <cmath> Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoTools.cpp","title":"File XYGeoTools.cpp"},{"location":"models/_x_y_geo_tools_8cpp/#file-xygeotoolscpp","text":"FileList > CommImp > Spatial > XYGeoTools.cpp Go to the source code of this file #include \"XYGeoTools.h\" #include \"Models/Utils/Exception.h\" #include <algorithm> #include <cmath>","title":"File XYGeoTools.cpp"},{"location":"models/_x_y_geo_tools_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoTools.cpp","title":"Namespaces"},{"location":"models/_x_y_geo_tools_8cpp_source/","text":"File XYGeoTools.cpp \u00b6 File List > CommImp > Spatial > XYGeoTools.cpp Go to the documentation of this file #include \"XYGeoTools.h\" #include \"Models/Utils/Exception.h\" #include <algorithm> #include <cmath> namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; // struct XYGeoTools ------------------------------------------------------------------ double XYGeoTools::CalculatePointToPointDistance ( const XYPoint & p1 , const XYPoint & p2 ) { double dx = p2 . x - p1 . x ; double dy = p2 . y - p1 . y ; return sqrt ( dx * dx + dy * dy ); } bool XYGeoTools::IsLinesIntersected ( const XYLine & l1 , const XYLine & l2 ) { // Vector A \u00d7 B (\u00d7 is the cross product): // if the result is less than 0, then vector B is in the clockwise direction of A; // if result is greater than 0, vector B is in the counterclockwise direction of A; // if it's 0, that means that vector A is parallel to vector B. // // A(a1, b1), B(a2, b2), then: A \u00d7 B = |a1 b1| = a1*b2 - a2*b1 = |A| * |B| * sin(\u03b8). // |a2 b2| // // 1. Fast Rejection Test, // whether the projection of two line segments overlaps in x and y coordinates; // 2. Straddle Test, // the cross product is used to judge the intersection of line segments. // const XYPoint & l1p1 = l1 . point1 , & l1p2 = l1 . point2 ; const XYPoint & l2p1 = l2 . point1 , & l2p2 = l2 . point2 ; // Fast rejection test. if ( max ( l1p1 . x , l1p2 . x ) <= min ( l2p1 . x , l2p2 . x ) || max ( l2p1 . y , l2p2 . y ) <= min ( l1p1 . y , l1p2 . y ) || max ( l2p1 . x , l2p2 . x ) <= min ( l1p1 . x , l1p2 . x ) || max ( l1p1 . y , l1p2 . y ) <= min ( l2p1 . y , l2p2 . y )) { return false ; // line segment extents have no overlap. } // Straddle test. double l1det1 = ( l1p1 . x - l2p2 . x ) * ( l2p1 . y - l2p2 . y ) - ( l1p1 . y - l2p2 . y ) * ( l2p1 . x - l2p2 . x ); double l1det2 = ( l1p2 . x - l2p2 . x ) * ( l2p1 . y - l2p2 . y ) - ( l1p2 . y - l2p2 . y ) * ( l2p1 . x - l2p2 . x ); double l2det1 = ( l2p1 . x - l1p2 . x ) * ( l1p1 . y - l1p2 . y ) - ( l2p1 . y - l1p2 . y ) * ( l1p1 . x - l1p2 . x ); double l2det2 = ( l2p2 . x - l1p2 . x ) * ( l1p1 . y - l1p2 . y ) - ( l2p2 . y - l1p2 . y ) * ( l1p1 . x - l1p2 . x ); if ( l1det1 * l1det2 >= EPSILON || l2det1 * l2det2 >= EPSILON ) { return false ; // line segments not cross. } if ( abs ( l1det1 * l1det2 ) <= EPSILON && abs ( l2det1 * l2det2 ) <= EPSILON ) { return false ; // line segments are parrallel. } return true ; } XYPoint XYGeoTools::CalculateIntersectionPoint ( const XYLine & l1 , const XYLine & l2 ) { // Using the cross product to calculate the area and according to the ratio of // areas, calculate the proportional position of the intersection point `O` on // the line segment. // Then, using this scale to interpolate the coordinates. // if ( ! IsLinesIntersected ( l1 , l2 )) { throw runtime_error ( \"Line segments have no intersection point.\" ); } const XYPoint & l1p1 = l1 . point1 , & l1p2 = l1 . point2 ; const XYPoint & l2p1 = l2 . point1 , & l2p2 = l2 . point2 ; double area1 = ( l1p2 . x - l1p1 . x ) * ( l2p1 . y - l1p1 . y ) - ( l1p2 . y - l1p1 . y ) * ( l2p1 . x - l1p1 . x ); double area2 = ( l1p2 . x - l1p1 . x ) * ( l2p2 . y - l1p1 . y ) - ( l1p2 . y - l1p1 . y ) * ( l2p2 . x - l1p1 . x ); double lambda = abs ( area1 ) / abs ( area2 ); double x = l2p1 . x + lambda / ( lambda + 1 ) * ( l2p2 . x - l2p1 . x ); double y = l2p1 . y + lambda / ( lambda + 1 ) * ( l2p2 . y - l2p1 . y ); return XYPoint ( x , y ); } XYPoint XYGeoTools::CalculateMidpoint ( const XYLine & line ) { double x = ( line . point1 . x + line . point2 . x ) / 2. ; double y = ( line . point1 . y + line . point2 . y ) / 2. ; return XYPoint ( x , y ); } double XYGeoTools::CalculateLineToPointDistance ( const XYLine & line , const XYPoint & point ) { const XYPoint & p1 = line . point1 , & p2 = line . point2 ; // check if the line is a point actually. if ( abs ( line . GetLength ()) <= EPSILON ) // p1 == p2. { return CalculatePointToPointDistance ( point , p1 ); } // Point projected on line before P1, use distance to P1. double p2p1dotpp1 = ( p2 . x - p1 . x ) * ( point . x - p1 . x ) + ( p2 . y - p1 . y ) * ( point . y - p1 . y ); if ( p2p1dotpp1 <= EPSILON ) { return CalculatePointToPointDistance ( point , p1 ); } // Point projected on line after P2, use distance to P2. double p2p1dotpp2 = ( p2 . x - p1 . x ) * ( point . x - p2 . x ) + ( p2 . y - p1 . y ) * ( point . y - p2 . y ); if ( p2p1dotpp2 >= EPSILON ) { return CalculatePointToPointDistance ( point , p2 ); } // Point projected between P1 and P2, calculate distance to projection point. double p2p1crosspp1 = ( p2 . x - p1 . x ) * ( point . y - p1 . y ) - ( p2 . y - p1 . y ) * ( point . x - p1 . x ); return abs ( p2p1crosspp1 / line . GetLength ()); } double XYGeoTools::CalculatePolylineToPointDistance ( const XYPolyline & polyline , const XYPoint & point ) { if ( polyline . points . empty ()) { return 0 ; } int i = 1 ; double dist = CalculateLineToPointDistance ( polyline . GetLine ( 0 ), point ); while ( i < ( int ) polyline . points . size () - 1 ) { dist = min ( dist , CalculateLineToPointDistance ( polyline . GetLine ( i ++ ), point )); } return dist ; } double XYGeoTools::CalculateLengthOfPolylineInsidePolygon ( const XYPolyline & polyline , const XYPolygon & polygon ) { double lengthInside = 0 ; int numberOfLineSegments = polyline . points . size () - 1 ; for ( int i = 0 ; i < numberOfLineSegments ; i ++ ) { auto line = polyline . GetLine ( i ); lengthInside += CalculateLengthOfLineInsidePolygon ( line , polygon ); } return lengthInside ; } bool XYGeoTools::IsPointInLine ( const XYPoint & point , const XYLine & line ) { return ( abs ( CalculateLineToPointDistance ( line , point )) <= EPSILON ) ? true : false ; } bool XYGeoTools::IsPointInPolygon ( const XYPoint & point , const XYPolygon & polygon ) { // PNPoly algorithm (by W. Randolph Franklin), in general: // // For a polygon and a given point, draw a line horizontally through that point, // count how many times the line is compared to the edge of the polygon, // and then count the number of times the line crosses the polygon. // // If it's odd, the point is inside the polygon, otherwise it's outside polygon. // if ( ! polygon . Validate ()) { return false ; } bool isInside = false ; auto size = ( int ) polygon . points . size (); double x1 , y1 , x2 , y2 ; for ( int i = 0 ; i < size ; i ++ ) { if ( i < size - 1 ) { x1 = polygon . points [ i ]. x ; y1 = polygon . points [ i ]. y ; x2 = polygon . points [ i + 1 ]. x ; y2 = polygon . points [ i + 1 ]. y ; } else { x1 = polygon . points [ i ]. x ; y1 = polygon . points [ i ]. y ; x2 = polygon . points [ 0 ]. x ; y2 = polygon . points [ 0 ]. y ; } if ( point . y - min ( y1 , y2 ) >= EPSILON ) { if ( max ( y1 , y2 ) - point . y >= EPSILON ) { if ( max ( x1 , x2 ) - point . x >= EPSILON ) { if ( abs ( y1 - y2 ) > EPSILON ) { double xinter = ( point . y - y1 ) * ( x2 - x1 ) / ( y2 - y1 ) + x1 ; if ( abs ( x1 - x2 ) <= EPSILON || xinter - point . x >= EPSILON ) { isInside = ! isInside ; } } } } } } return isInside ; } double XYGeoTools::CalculateSharedArea ( const XYPolygon & polygonA , const XYPolygon & polygonB ) { const auto & triangleListA = GetTriangulations ( polygonA ); const auto & triangleListB = GetTriangulations ( polygonB ); double area = 0 ; for ( int ia = 0 ; ia < ( int ) triangleListA . size (); ia ++ ) { const auto & triangleA = triangleListA [ ia ]; for ( int ib = 0 ; ib < ( int ) triangleListB . size (); ib ++ ) { const auto & triangleB = triangleListB [ ib ]; area = area + CalculateTriangleSharedArea ( triangleA , triangleB ); } } return area ; } double XYGeoTools::CalculateTriangleSharedArea ( const XYPolygon & triangleA , const XYPolygon & triangleB ) { try { if ( triangleA . points . size () != 3 || triangleB . points . size () != 3 ) { throw runtime_error ( \"Argument must be a polygon with 3 points\" ); } int i = 1 ; // Index for \"next\" node in polygon a. // Index for \"next\" node in polygon b. // -1 indicates that the first has not yet been found. int j = -1 ; double area = 0 ; // Intersection area. XYPolygon intersectionPolygon ; // Intersection polygon. // Latest intersection node found. XYPoint pIntersect ( triangleA . points [ 0 ]); Intersect ( triangleA , triangleB , pIntersect , i , j , intersectionPolygon ); // First intersection point between triangles. XYPoint pFirst = pIntersect ; if ( j != -1 ) { // int jStop = IncrementModula(j, 3); bool complete = false ; int count = 0 ; while ( ! complete ) { // coordinates for vectors pointing to next triangleA and triangleB // point respectively. double vax = triangleA . points [ i ]. x - pIntersect . x ; double vay = triangleA . points [ i ]. y - pIntersect . y ; double vbx = triangleB . points [ j ]. x - pIntersect . x ; double vby = triangleB . points [ j ]. y - pIntersect . y ; // The sideOf tells if the vb vector or the va vector is the one // pointing \"left\" If sideOf is positive, vb is pointing left, otherwise // va is pointing left The \"left\" vector is the one that is inside the // polygon. double sideOf = vax * vby - vay * vbx ; // Make sure to get out of EPSILON reach from the original point, hence // 2*EPSILON if ( sideOf < 0 && IsPointInPolygon ( XYPoint ( pIntersect . x + 2 * EPSILON * vax , pIntersect . y + 2 * EPSILON * vay ), triangleB )) { Intersect ( triangleA , triangleB , pIntersect , i , j , intersectionPolygon ); } else if ( sideOf > 0 && IsPointInPolygon ( XYPoint ( pIntersect . x + 2 * EPSILON * vbx , pIntersect . y + 2 * EPSILON * vby ), triangleA )) { Intersect ( triangleB , triangleA , pIntersect , j , i , intersectionPolygon ); } // can be true if the point is on the edge of the triangleB. // TODO: Replace with IsPointOnEdge of triangleB. else if ( IsPointInPolygon ( XYPoint ( pIntersect . x + 2 * EPSILON * vax , pIntersect . y + 2 * EPSILON * vay ), triangleB )) { Intersect ( triangleA , triangleB , pIntersect , i , j , intersectionPolygon ); } // can be true if the point is on the edge of the triangleA // Should never happen, since above test basically does the same. // TODO: Replace with IsPointOnEdge of triangleA else if ( IsPointInPolygon ( XYPoint ( pIntersect . x + 2 * EPSILON * vbx , pIntersect . y + 2 * EPSILON * vby ), triangleA )) { Intersect ( triangleB , triangleA , pIntersect , j , i , intersectionPolygon ); } // triangleA and triangleB only touches one another but do not // intersect else { area = 0 ; return area ; } if ( ! intersectionPolygon . points . empty ()) { complete = ( CalculatePointToPointDistance ( pIntersect , pFirst ) < EPSILON ); } count ++ ; if ( count > 20 ) { throw runtime_error ( \"Failed to find intersection polygon\" ); } } area = intersectionPolygon . GetArea (); } else { // internal point in triangle a const auto & pointsA = triangleA . points ; double xPa = ( pointsA [ 0 ]. x + pointsA [ 1 ]. x + pointsA [ 2 ]. x ) / 3.0 ; double yPa = ( pointsA [ 0 ]. y + pointsA [ 1 ]. y + pointsA [ 2 ]. y ) / 3.0 ; XYPoint pa ( xPa , yPa ); // internal point in triangle b const auto & pointsB = triangleB . points ; double xPb = ( pointsB [ 0 ]. x + pointsB [ 1 ]. x + pointsB [ 2 ]. x ) / 3.0 ; double yPb = ( pointsB [ 0 ]. y + pointsB [ 1 ]. y + pointsB [ 2 ]. y ) / 3.0 ; XYPoint pb ( xPb , yPb ); if ( IsPointInPolygon ( pa , triangleB ) || IsPointInPolygon ( pb , triangleA )) // triangleA is completely inside triangleB { area = min ( triangleA . GetArea (), triangleB . GetArea ()); } else // triangleA and triangleB do dot intersect { area = 0 ; } } return area ; } catch ( const runtime_error & e ) { throw runtime_error ( \"GetTriangleSharedArea failed\" ); } } vector < XYPolygon > XYGeoTools :: GetTriangulations ( const XYPolygon & polygon ) { if ( ! polygon . Validate ()) { throw runtime_error ( \"Invalid Polygon object.\" ); } XYPolygon localPolygon ( polygon ); vector < XYPolygon > triangleList ; while ( localPolygon . points . size () > 3 ) { int i = FindTrianglePoints ( localPolygon ); auto n = ( int ) localPolygon . points . size (); auto prev = ( i == 0 ) ? n - 1 : i - 1 ; auto next = ( i == n - 1 ) ? 0 : i + 1 ; XYPolygon triangle ; triangle . points . push_back ( localPolygon . points [ prev ]); triangle . points . push_back ( localPolygon . points [ i ]); triangle . points . push_back ( localPolygon . points [ next ]); triangleList . push_back ( triangle ); localPolygon . points . erase ( localPolygon . points . begin () + i ); } triangleList . push_back ( localPolygon ); return triangleList ; } int XYGeoTools :: FindTrianglePoints ( const XYPolygon & polygon ) { bool found = false ; int i = 0 ; while ( i < ( int ) polygon . points . size () && ! found ) { if ( polygon . IsConvex ( i ) && ! IsTriangleIntersected ( polygon , i )) { found = true ; } else { i ++ ; } } return i ; } bool XYGeoTools :: IsTriangleIntersected ( const XYPolygon & polygon , int index ) { const auto & points = polygon . points ; auto prevIndex = ( index - 1 < 0 ) ? ( int ) points . size () - 1 : index - 1 ; auto nextIndex = ( index + 1 > ( int ) points . size () - 1 ) ? 0 : index + 1 ; const XYPoint & p1 = points [ prevIndex ], & p = points [ index ], & p2 = points [ nextIndex ]; XYPolygon triangulation ; triangulation . points . push_back ( p1 ); triangulation . points . push_back ( p ); triangulation . points . push_back ( p2 ); int i = 0 ; bool insertected = false ; while ( i < ( int ) points . size () - 1 && ! insertected ) { bool skip = ( i == index || i == prevIndex || i == nextIndex ); if ( ! skip && IsPointInPolygon ( points [ i ], triangulation )) { return true ; } else { i ++ ; } } return insertected ; } double XYGeoTools :: CalculateSharedLength ( const XYLine & lineA , const XYLine & lineB ) { if ( abs ( lineA . point2 . x - lineA . point1 . x ) < EPSILON && abs ( lineB . point2 . x - lineB . point1 . x ) < EPSILON && abs ( lineA . point1 . x - lineB . point1 . x ) < EPSILON ) { double YP1A = min ( lineA . point1 . y , lineA . point2 . y ); double YP2A = max ( lineA . point1 . y , lineA . point2 . y ); double YP1B = min ( lineB . point1 . y , lineB . point2 . y ); double YP2B = max ( lineB . point1 . y , lineB . point2 . y ); double YP1 = max ( YP1A , YP1B ); double YP2 = min ( YP2A , YP2B ); if ( YP1 < YP2 ) { return YP2 - YP1 ; } else { return 0 ; } } else if ( abs ( lineA . point2 . x - lineA . point1 . x ) < EPSILON || abs ( lineB . point2 . x - lineB . point1 . x ) < EPSILON ) { return 0 ; } else { XYPoint P1A , P2A ; if ( lineA . point1 . x < lineA . point2 . x ) { P1A = lineA . point1 ; P2A = lineA . point2 ; } else { P1A = lineA . point2 ; P2A = lineA . point1 ; } XYPoint P1B , P2B ; if ( lineB . point1 . x < lineB . point2 . x ) { P1B = lineB . point1 ; P2B = lineB . point2 ; } else { P1B = lineB . point2 ; P2B = lineB . point1 ; } double alphaA = ( P2A . y - P1A . y ) / ( P2A . x - P1A . x ); double betaA = - alphaA * P2A . x + P2A . y ; double alphaB = ( P2B . y - P1B . y ) / ( P2B . x - P1B . x ); double betaB = - alphaA * P2B . x + P2B . y ; if ( abs ( alphaA - alphaB ) < EPSILON && abs ( betaA - betaB ) < EPSILON ) { double x1 = max ( P1A . x , P1B . x ); double x2 = min ( P2A . x , P2B . x ); if ( x1 < x2 ) { XYLine line ( x1 , alphaA * x1 + betaA , x2 , alphaA * x2 + betaA ); return line . GetLength (); } else { return 0 ; } } else { return 0 ; } } } double XYGeoTools :: CalculateLengthOfLineInsidePolygon ( const XYLine & line , const XYPolygon & polygon ) { vector < XYLine > lineList { line }; for ( int i = 0 ; i < ( int ) polygon . points . size (); i ++ ) // All lines in the polygon { for ( int n = 0 ; n < ( int ) lineList . size (); n ++ ) { if ( lineList . size () > 1000 ) { throw runtime_error ( \"Line has been cut in more than 1000 pieces.\" ); } if ( IsLinesIntersected ( lineList [ n ], polygon . GetLine ( i ))) { // Split the intersecting line into two lines XYPoint IntersectionPoint ( CalculateIntersectionPoint ( lineList [ n ], polygon . GetLine ( i ))); XYLine tempVar ( IntersectionPoint , lineList [ n ]. point2 ); lineList . push_back ( tempVar ); lineList [ n ]. point2 . x = IntersectionPoint . x ; lineList [ n ]. point2 . y = IntersectionPoint . y ; break ; } } } for ( int i = 0 ; i < ( int ) lineList . size (); i ++ ) { if ( lineList . size () > 1000 ) { throw runtime_error ( \"Line has been cuttes in more than 100 pieces.\" ); } for ( int j = 0 ; j < ( int ) polygon . points . size (); j ++ ) { if ( IsPointInLineInterior ( polygon . GetLine ( j ). point1 , lineList [ i ])) { XYLine tempVar2 ( polygon . GetLine ( j ). point1 , lineList [ i ]. point2 ); lineList . push_back ( tempVar2 ); lineList [ i ]. point2 . x = polygon . GetLine ( j ). point1 . x ; lineList [ i ]. point2 . y = polygon . GetLine ( j ). point1 . y ; } } } double lengthInside = 0 ; for ( int i = 0 ; i < ( int ) lineList . size (); i ++ ) { double sharedLength = 0 ; for ( int j = 0 ; j < ( int ) polygon . points . size (); j ++ ) { sharedLength += CalculateSharedLength ( lineList [ i ], polygon . GetLine ( j )); } if ( sharedLength > EPSILON ) { lengthInside += sharedLength / 2 ; } else if ( IsPointInPolygon ( CalculateMidpoint ( lineList [ i ]), polygon )) { lengthInside += lineList [ i ]. GetLength (); } } return lengthInside ; } bool XYGeoTools :: IntersectionPoint ( const XYLine & LineA , const XYLine & LineB , XYPoint & intersectionPoint ) { if ( IsLinesIntersected ( LineA , LineB )) { intersectionPoint = CalculateIntersectionPoint ( LineA , LineB ); return true ; } if ( IsPointInLine ( LineA . point2 , LineB )) { intersectionPoint = LineA . point2 ; return true ; } if ( IsPointInLine ( LineB . point2 , LineA )) { intersectionPoint = LineB . point2 ; return true ; } if ( IsPointInLine ( LineB . point1 , LineA )) { intersectionPoint = LineB . point1 ; return true ; } if ( IsPointInLine ( LineA . point1 , LineB )) { intersectionPoint = LineA . point1 ; return true ; } return false ; } bool XYGeoTools :: IsPointInLineInterior ( const XYPoint & point , const XYLine & line ) { // TODO: Update to use projection method instead, see IsPointInLine. bool result = false ; if ( line . point1 . x - line . point2 . x != 0 ) // line is not vertical { if (( point . x > min ( line . point1 . x , line . point2 . x )) && ( point . x < max ( line . point1 . x , line . point2 . x ))) { if ( abs ( point . y - line . point1 . y - ( line . point2 . y - line . point1 . y ) / ( line . point1 . x - line . point2 . x ) * ( line . point1 . x - point . x )) < EPSILON * EPSILON ) { result = true ; } } } else // line is vertical { if ( line . point1 . x == point . x ) { if (( point . y > min ( line . point1 . y , line . point2 . y )) && ( point . y < max ( line . point1 . y , line . point2 . y ))) { result = true ; } } } return result ; } void XYGeoTools :: Intersect ( const XYPolygon & triangleA , const XYPolygon & triangleB , XYPoint & p , int & i , int & j , XYPolygon & intersectionPolygon ) { XYLine lineA ; XYLine lineB ; int im1 = DecrementModula ( i , 3 ); // \"i-1\" int count1 = 0 ; bool found = false ; while (( count1 < 3 ) && ( ! found )) { lineA = triangleA . GetLine ( im1 ); if ( count1 == 0 ) { lineA = XYLine ( lineA ); lineA . point1 = p ; } double MinDist = -1 ; // Distance used when a line is crossed more than once. int jm1 = 0 ; // \"j-1\" int jm1Store = -1 ; while ( jm1 < 3 ) { lineB = triangleB . GetLine ( jm1 ); found = IntersectionPoint ( lineA , lineB , p ); double Dist = CalculatePointToPointDistance ( lineA . point1 , p ); if ( Dist < EPSILON ) { found = false ; } if ( found ) { if (( MinDist < 0 ) || ( Dist < MinDist )) { MinDist = Dist ; jm1Store = jm1 ; } } jm1 ++ ; } if ( jm1Store > -1 ) { lineB = triangleB . GetLine ( jm1Store ); found = IntersectionPoint ( lineA , lineB , p ); XYPoint HelpCoordinate ( p ); XYPoint HelpNode ( HelpCoordinate ); intersectionPolygon . points . push_back ( HelpNode ); j = IncrementModula ( jm1Store , 3 ); } if ( ! found ) { count1 ++ ; im1 = IncrementModula ( im1 , 3 ); i = IncrementModula ( i , 3 ); if ( j != -1 ) { XYPoint HelpCoordinate ( lineA . point2 ); XYPoint HelpNode ( HelpCoordinate ); intersectionPolygon . points . push_back ( HelpNode ); } } } lineA = triangleA . GetLine ( DecrementModula ( i , 3 )); if ( CalculatePointToPointDistance ( p , lineA . point2 ) < EPSILON ) { i = IncrementModula ( i , 3 ); } lineB = triangleB . GetLine ( DecrementModula ( j , 3 )); if ( CalculatePointToPointDistance ( p , lineB . point2 ) < EPSILON ) { j = IncrementModula ( j , 3 ); } } int XYGeoTools :: IncrementModula ( int i , int n ) { i ++ ; i %= n ; return i ; } int XYGeoTools :: DecrementModula ( int i , int n ) { i -- ; if ( i < 0 ) { i = n - 1 ; } return i ; } } // namespace OpenOasis::CommImp::Spatial","title":"File XYGeoTools.cpp"},{"location":"models/_x_y_geo_tools_8cpp_source/#file-xygeotoolscpp","text":"File List > CommImp > Spatial > XYGeoTools.cpp Go to the documentation of this file #include \"XYGeoTools.h\" #include \"Models/Utils/Exception.h\" #include <algorithm> #include <cmath> namespace OpenOasis :: CommImp :: Spatial { using namespace Utils ; using namespace std ; // struct XYGeoTools ------------------------------------------------------------------ double XYGeoTools::CalculatePointToPointDistance ( const XYPoint & p1 , const XYPoint & p2 ) { double dx = p2 . x - p1 . x ; double dy = p2 . y - p1 . y ; return sqrt ( dx * dx + dy * dy ); } bool XYGeoTools::IsLinesIntersected ( const XYLine & l1 , const XYLine & l2 ) { // Vector A \u00d7 B (\u00d7 is the cross product): // if the result is less than 0, then vector B is in the clockwise direction of A; // if result is greater than 0, vector B is in the counterclockwise direction of A; // if it's 0, that means that vector A is parallel to vector B. // // A(a1, b1), B(a2, b2), then: A \u00d7 B = |a1 b1| = a1*b2 - a2*b1 = |A| * |B| * sin(\u03b8). // |a2 b2| // // 1. Fast Rejection Test, // whether the projection of two line segments overlaps in x and y coordinates; // 2. Straddle Test, // the cross product is used to judge the intersection of line segments. // const XYPoint & l1p1 = l1 . point1 , & l1p2 = l1 . point2 ; const XYPoint & l2p1 = l2 . point1 , & l2p2 = l2 . point2 ; // Fast rejection test. if ( max ( l1p1 . x , l1p2 . x ) <= min ( l2p1 . x , l2p2 . x ) || max ( l2p1 . y , l2p2 . y ) <= min ( l1p1 . y , l1p2 . y ) || max ( l2p1 . x , l2p2 . x ) <= min ( l1p1 . x , l1p2 . x ) || max ( l1p1 . y , l1p2 . y ) <= min ( l2p1 . y , l2p2 . y )) { return false ; // line segment extents have no overlap. } // Straddle test. double l1det1 = ( l1p1 . x - l2p2 . x ) * ( l2p1 . y - l2p2 . y ) - ( l1p1 . y - l2p2 . y ) * ( l2p1 . x - l2p2 . x ); double l1det2 = ( l1p2 . x - l2p2 . x ) * ( l2p1 . y - l2p2 . y ) - ( l1p2 . y - l2p2 . y ) * ( l2p1 . x - l2p2 . x ); double l2det1 = ( l2p1 . x - l1p2 . x ) * ( l1p1 . y - l1p2 . y ) - ( l2p1 . y - l1p2 . y ) * ( l1p1 . x - l1p2 . x ); double l2det2 = ( l2p2 . x - l1p2 . x ) * ( l1p1 . y - l1p2 . y ) - ( l2p2 . y - l1p2 . y ) * ( l1p1 . x - l1p2 . x ); if ( l1det1 * l1det2 >= EPSILON || l2det1 * l2det2 >= EPSILON ) { return false ; // line segments not cross. } if ( abs ( l1det1 * l1det2 ) <= EPSILON && abs ( l2det1 * l2det2 ) <= EPSILON ) { return false ; // line segments are parrallel. } return true ; } XYPoint XYGeoTools::CalculateIntersectionPoint ( const XYLine & l1 , const XYLine & l2 ) { // Using the cross product to calculate the area and according to the ratio of // areas, calculate the proportional position of the intersection point `O` on // the line segment. // Then, using this scale to interpolate the coordinates. // if ( ! IsLinesIntersected ( l1 , l2 )) { throw runtime_error ( \"Line segments have no intersection point.\" ); } const XYPoint & l1p1 = l1 . point1 , & l1p2 = l1 . point2 ; const XYPoint & l2p1 = l2 . point1 , & l2p2 = l2 . point2 ; double area1 = ( l1p2 . x - l1p1 . x ) * ( l2p1 . y - l1p1 . y ) - ( l1p2 . y - l1p1 . y ) * ( l2p1 . x - l1p1 . x ); double area2 = ( l1p2 . x - l1p1 . x ) * ( l2p2 . y - l1p1 . y ) - ( l1p2 . y - l1p1 . y ) * ( l2p2 . x - l1p1 . x ); double lambda = abs ( area1 ) / abs ( area2 ); double x = l2p1 . x + lambda / ( lambda + 1 ) * ( l2p2 . x - l2p1 . x ); double y = l2p1 . y + lambda / ( lambda + 1 ) * ( l2p2 . y - l2p1 . y ); return XYPoint ( x , y ); } XYPoint XYGeoTools::CalculateMidpoint ( const XYLine & line ) { double x = ( line . point1 . x + line . point2 . x ) / 2. ; double y = ( line . point1 . y + line . point2 . y ) / 2. ; return XYPoint ( x , y ); } double XYGeoTools::CalculateLineToPointDistance ( const XYLine & line , const XYPoint & point ) { const XYPoint & p1 = line . point1 , & p2 = line . point2 ; // check if the line is a point actually. if ( abs ( line . GetLength ()) <= EPSILON ) // p1 == p2. { return CalculatePointToPointDistance ( point , p1 ); } // Point projected on line before P1, use distance to P1. double p2p1dotpp1 = ( p2 . x - p1 . x ) * ( point . x - p1 . x ) + ( p2 . y - p1 . y ) * ( point . y - p1 . y ); if ( p2p1dotpp1 <= EPSILON ) { return CalculatePointToPointDistance ( point , p1 ); } // Point projected on line after P2, use distance to P2. double p2p1dotpp2 = ( p2 . x - p1 . x ) * ( point . x - p2 . x ) + ( p2 . y - p1 . y ) * ( point . y - p2 . y ); if ( p2p1dotpp2 >= EPSILON ) { return CalculatePointToPointDistance ( point , p2 ); } // Point projected between P1 and P2, calculate distance to projection point. double p2p1crosspp1 = ( p2 . x - p1 . x ) * ( point . y - p1 . y ) - ( p2 . y - p1 . y ) * ( point . x - p1 . x ); return abs ( p2p1crosspp1 / line . GetLength ()); } double XYGeoTools::CalculatePolylineToPointDistance ( const XYPolyline & polyline , const XYPoint & point ) { if ( polyline . points . empty ()) { return 0 ; } int i = 1 ; double dist = CalculateLineToPointDistance ( polyline . GetLine ( 0 ), point ); while ( i < ( int ) polyline . points . size () - 1 ) { dist = min ( dist , CalculateLineToPointDistance ( polyline . GetLine ( i ++ ), point )); } return dist ; } double XYGeoTools::CalculateLengthOfPolylineInsidePolygon ( const XYPolyline & polyline , const XYPolygon & polygon ) { double lengthInside = 0 ; int numberOfLineSegments = polyline . points . size () - 1 ; for ( int i = 0 ; i < numberOfLineSegments ; i ++ ) { auto line = polyline . GetLine ( i ); lengthInside += CalculateLengthOfLineInsidePolygon ( line , polygon ); } return lengthInside ; } bool XYGeoTools::IsPointInLine ( const XYPoint & point , const XYLine & line ) { return ( abs ( CalculateLineToPointDistance ( line , point )) <= EPSILON ) ? true : false ; } bool XYGeoTools::IsPointInPolygon ( const XYPoint & point , const XYPolygon & polygon ) { // PNPoly algorithm (by W. Randolph Franklin), in general: // // For a polygon and a given point, draw a line horizontally through that point, // count how many times the line is compared to the edge of the polygon, // and then count the number of times the line crosses the polygon. // // If it's odd, the point is inside the polygon, otherwise it's outside polygon. // if ( ! polygon . Validate ()) { return false ; } bool isInside = false ; auto size = ( int ) polygon . points . size (); double x1 , y1 , x2 , y2 ; for ( int i = 0 ; i < size ; i ++ ) { if ( i < size - 1 ) { x1 = polygon . points [ i ]. x ; y1 = polygon . points [ i ]. y ; x2 = polygon . points [ i + 1 ]. x ; y2 = polygon . points [ i + 1 ]. y ; } else { x1 = polygon . points [ i ]. x ; y1 = polygon . points [ i ]. y ; x2 = polygon . points [ 0 ]. x ; y2 = polygon . points [ 0 ]. y ; } if ( point . y - min ( y1 , y2 ) >= EPSILON ) { if ( max ( y1 , y2 ) - point . y >= EPSILON ) { if ( max ( x1 , x2 ) - point . x >= EPSILON ) { if ( abs ( y1 - y2 ) > EPSILON ) { double xinter = ( point . y - y1 ) * ( x2 - x1 ) / ( y2 - y1 ) + x1 ; if ( abs ( x1 - x2 ) <= EPSILON || xinter - point . x >= EPSILON ) { isInside = ! isInside ; } } } } } } return isInside ; } double XYGeoTools::CalculateSharedArea ( const XYPolygon & polygonA , const XYPolygon & polygonB ) { const auto & triangleListA = GetTriangulations ( polygonA ); const auto & triangleListB = GetTriangulations ( polygonB ); double area = 0 ; for ( int ia = 0 ; ia < ( int ) triangleListA . size (); ia ++ ) { const auto & triangleA = triangleListA [ ia ]; for ( int ib = 0 ; ib < ( int ) triangleListB . size (); ib ++ ) { const auto & triangleB = triangleListB [ ib ]; area = area + CalculateTriangleSharedArea ( triangleA , triangleB ); } } return area ; } double XYGeoTools::CalculateTriangleSharedArea ( const XYPolygon & triangleA , const XYPolygon & triangleB ) { try { if ( triangleA . points . size () != 3 || triangleB . points . size () != 3 ) { throw runtime_error ( \"Argument must be a polygon with 3 points\" ); } int i = 1 ; // Index for \"next\" node in polygon a. // Index for \"next\" node in polygon b. // -1 indicates that the first has not yet been found. int j = -1 ; double area = 0 ; // Intersection area. XYPolygon intersectionPolygon ; // Intersection polygon. // Latest intersection node found. XYPoint pIntersect ( triangleA . points [ 0 ]); Intersect ( triangleA , triangleB , pIntersect , i , j , intersectionPolygon ); // First intersection point between triangles. XYPoint pFirst = pIntersect ; if ( j != -1 ) { // int jStop = IncrementModula(j, 3); bool complete = false ; int count = 0 ; while ( ! complete ) { // coordinates for vectors pointing to next triangleA and triangleB // point respectively. double vax = triangleA . points [ i ]. x - pIntersect . x ; double vay = triangleA . points [ i ]. y - pIntersect . y ; double vbx = triangleB . points [ j ]. x - pIntersect . x ; double vby = triangleB . points [ j ]. y - pIntersect . y ; // The sideOf tells if the vb vector or the va vector is the one // pointing \"left\" If sideOf is positive, vb is pointing left, otherwise // va is pointing left The \"left\" vector is the one that is inside the // polygon. double sideOf = vax * vby - vay * vbx ; // Make sure to get out of EPSILON reach from the original point, hence // 2*EPSILON if ( sideOf < 0 && IsPointInPolygon ( XYPoint ( pIntersect . x + 2 * EPSILON * vax , pIntersect . y + 2 * EPSILON * vay ), triangleB )) { Intersect ( triangleA , triangleB , pIntersect , i , j , intersectionPolygon ); } else if ( sideOf > 0 && IsPointInPolygon ( XYPoint ( pIntersect . x + 2 * EPSILON * vbx , pIntersect . y + 2 * EPSILON * vby ), triangleA )) { Intersect ( triangleB , triangleA , pIntersect , j , i , intersectionPolygon ); } // can be true if the point is on the edge of the triangleB. // TODO: Replace with IsPointOnEdge of triangleB. else if ( IsPointInPolygon ( XYPoint ( pIntersect . x + 2 * EPSILON * vax , pIntersect . y + 2 * EPSILON * vay ), triangleB )) { Intersect ( triangleA , triangleB , pIntersect , i , j , intersectionPolygon ); } // can be true if the point is on the edge of the triangleA // Should never happen, since above test basically does the same. // TODO: Replace with IsPointOnEdge of triangleA else if ( IsPointInPolygon ( XYPoint ( pIntersect . x + 2 * EPSILON * vbx , pIntersect . y + 2 * EPSILON * vby ), triangleA )) { Intersect ( triangleB , triangleA , pIntersect , j , i , intersectionPolygon ); } // triangleA and triangleB only touches one another but do not // intersect else { area = 0 ; return area ; } if ( ! intersectionPolygon . points . empty ()) { complete = ( CalculatePointToPointDistance ( pIntersect , pFirst ) < EPSILON ); } count ++ ; if ( count > 20 ) { throw runtime_error ( \"Failed to find intersection polygon\" ); } } area = intersectionPolygon . GetArea (); } else { // internal point in triangle a const auto & pointsA = triangleA . points ; double xPa = ( pointsA [ 0 ]. x + pointsA [ 1 ]. x + pointsA [ 2 ]. x ) / 3.0 ; double yPa = ( pointsA [ 0 ]. y + pointsA [ 1 ]. y + pointsA [ 2 ]. y ) / 3.0 ; XYPoint pa ( xPa , yPa ); // internal point in triangle b const auto & pointsB = triangleB . points ; double xPb = ( pointsB [ 0 ]. x + pointsB [ 1 ]. x + pointsB [ 2 ]. x ) / 3.0 ; double yPb = ( pointsB [ 0 ]. y + pointsB [ 1 ]. y + pointsB [ 2 ]. y ) / 3.0 ; XYPoint pb ( xPb , yPb ); if ( IsPointInPolygon ( pa , triangleB ) || IsPointInPolygon ( pb , triangleA )) // triangleA is completely inside triangleB { area = min ( triangleA . GetArea (), triangleB . GetArea ()); } else // triangleA and triangleB do dot intersect { area = 0 ; } } return area ; } catch ( const runtime_error & e ) { throw runtime_error ( \"GetTriangleSharedArea failed\" ); } } vector < XYPolygon > XYGeoTools :: GetTriangulations ( const XYPolygon & polygon ) { if ( ! polygon . Validate ()) { throw runtime_error ( \"Invalid Polygon object.\" ); } XYPolygon localPolygon ( polygon ); vector < XYPolygon > triangleList ; while ( localPolygon . points . size () > 3 ) { int i = FindTrianglePoints ( localPolygon ); auto n = ( int ) localPolygon . points . size (); auto prev = ( i == 0 ) ? n - 1 : i - 1 ; auto next = ( i == n - 1 ) ? 0 : i + 1 ; XYPolygon triangle ; triangle . points . push_back ( localPolygon . points [ prev ]); triangle . points . push_back ( localPolygon . points [ i ]); triangle . points . push_back ( localPolygon . points [ next ]); triangleList . push_back ( triangle ); localPolygon . points . erase ( localPolygon . points . begin () + i ); } triangleList . push_back ( localPolygon ); return triangleList ; } int XYGeoTools :: FindTrianglePoints ( const XYPolygon & polygon ) { bool found = false ; int i = 0 ; while ( i < ( int ) polygon . points . size () && ! found ) { if ( polygon . IsConvex ( i ) && ! IsTriangleIntersected ( polygon , i )) { found = true ; } else { i ++ ; } } return i ; } bool XYGeoTools :: IsTriangleIntersected ( const XYPolygon & polygon , int index ) { const auto & points = polygon . points ; auto prevIndex = ( index - 1 < 0 ) ? ( int ) points . size () - 1 : index - 1 ; auto nextIndex = ( index + 1 > ( int ) points . size () - 1 ) ? 0 : index + 1 ; const XYPoint & p1 = points [ prevIndex ], & p = points [ index ], & p2 = points [ nextIndex ]; XYPolygon triangulation ; triangulation . points . push_back ( p1 ); triangulation . points . push_back ( p ); triangulation . points . push_back ( p2 ); int i = 0 ; bool insertected = false ; while ( i < ( int ) points . size () - 1 && ! insertected ) { bool skip = ( i == index || i == prevIndex || i == nextIndex ); if ( ! skip && IsPointInPolygon ( points [ i ], triangulation )) { return true ; } else { i ++ ; } } return insertected ; } double XYGeoTools :: CalculateSharedLength ( const XYLine & lineA , const XYLine & lineB ) { if ( abs ( lineA . point2 . x - lineA . point1 . x ) < EPSILON && abs ( lineB . point2 . x - lineB . point1 . x ) < EPSILON && abs ( lineA . point1 . x - lineB . point1 . x ) < EPSILON ) { double YP1A = min ( lineA . point1 . y , lineA . point2 . y ); double YP2A = max ( lineA . point1 . y , lineA . point2 . y ); double YP1B = min ( lineB . point1 . y , lineB . point2 . y ); double YP2B = max ( lineB . point1 . y , lineB . point2 . y ); double YP1 = max ( YP1A , YP1B ); double YP2 = min ( YP2A , YP2B ); if ( YP1 < YP2 ) { return YP2 - YP1 ; } else { return 0 ; } } else if ( abs ( lineA . point2 . x - lineA . point1 . x ) < EPSILON || abs ( lineB . point2 . x - lineB . point1 . x ) < EPSILON ) { return 0 ; } else { XYPoint P1A , P2A ; if ( lineA . point1 . x < lineA . point2 . x ) { P1A = lineA . point1 ; P2A = lineA . point2 ; } else { P1A = lineA . point2 ; P2A = lineA . point1 ; } XYPoint P1B , P2B ; if ( lineB . point1 . x < lineB . point2 . x ) { P1B = lineB . point1 ; P2B = lineB . point2 ; } else { P1B = lineB . point2 ; P2B = lineB . point1 ; } double alphaA = ( P2A . y - P1A . y ) / ( P2A . x - P1A . x ); double betaA = - alphaA * P2A . x + P2A . y ; double alphaB = ( P2B . y - P1B . y ) / ( P2B . x - P1B . x ); double betaB = - alphaA * P2B . x + P2B . y ; if ( abs ( alphaA - alphaB ) < EPSILON && abs ( betaA - betaB ) < EPSILON ) { double x1 = max ( P1A . x , P1B . x ); double x2 = min ( P2A . x , P2B . x ); if ( x1 < x2 ) { XYLine line ( x1 , alphaA * x1 + betaA , x2 , alphaA * x2 + betaA ); return line . GetLength (); } else { return 0 ; } } else { return 0 ; } } } double XYGeoTools :: CalculateLengthOfLineInsidePolygon ( const XYLine & line , const XYPolygon & polygon ) { vector < XYLine > lineList { line }; for ( int i = 0 ; i < ( int ) polygon . points . size (); i ++ ) // All lines in the polygon { for ( int n = 0 ; n < ( int ) lineList . size (); n ++ ) { if ( lineList . size () > 1000 ) { throw runtime_error ( \"Line has been cut in more than 1000 pieces.\" ); } if ( IsLinesIntersected ( lineList [ n ], polygon . GetLine ( i ))) { // Split the intersecting line into two lines XYPoint IntersectionPoint ( CalculateIntersectionPoint ( lineList [ n ], polygon . GetLine ( i ))); XYLine tempVar ( IntersectionPoint , lineList [ n ]. point2 ); lineList . push_back ( tempVar ); lineList [ n ]. point2 . x = IntersectionPoint . x ; lineList [ n ]. point2 . y = IntersectionPoint . y ; break ; } } } for ( int i = 0 ; i < ( int ) lineList . size (); i ++ ) { if ( lineList . size () > 1000 ) { throw runtime_error ( \"Line has been cuttes in more than 100 pieces.\" ); } for ( int j = 0 ; j < ( int ) polygon . points . size (); j ++ ) { if ( IsPointInLineInterior ( polygon . GetLine ( j ). point1 , lineList [ i ])) { XYLine tempVar2 ( polygon . GetLine ( j ). point1 , lineList [ i ]. point2 ); lineList . push_back ( tempVar2 ); lineList [ i ]. point2 . x = polygon . GetLine ( j ). point1 . x ; lineList [ i ]. point2 . y = polygon . GetLine ( j ). point1 . y ; } } } double lengthInside = 0 ; for ( int i = 0 ; i < ( int ) lineList . size (); i ++ ) { double sharedLength = 0 ; for ( int j = 0 ; j < ( int ) polygon . points . size (); j ++ ) { sharedLength += CalculateSharedLength ( lineList [ i ], polygon . GetLine ( j )); } if ( sharedLength > EPSILON ) { lengthInside += sharedLength / 2 ; } else if ( IsPointInPolygon ( CalculateMidpoint ( lineList [ i ]), polygon )) { lengthInside += lineList [ i ]. GetLength (); } } return lengthInside ; } bool XYGeoTools :: IntersectionPoint ( const XYLine & LineA , const XYLine & LineB , XYPoint & intersectionPoint ) { if ( IsLinesIntersected ( LineA , LineB )) { intersectionPoint = CalculateIntersectionPoint ( LineA , LineB ); return true ; } if ( IsPointInLine ( LineA . point2 , LineB )) { intersectionPoint = LineA . point2 ; return true ; } if ( IsPointInLine ( LineB . point2 , LineA )) { intersectionPoint = LineB . point2 ; return true ; } if ( IsPointInLine ( LineB . point1 , LineA )) { intersectionPoint = LineB . point1 ; return true ; } if ( IsPointInLine ( LineA . point1 , LineB )) { intersectionPoint = LineA . point1 ; return true ; } return false ; } bool XYGeoTools :: IsPointInLineInterior ( const XYPoint & point , const XYLine & line ) { // TODO: Update to use projection method instead, see IsPointInLine. bool result = false ; if ( line . point1 . x - line . point2 . x != 0 ) // line is not vertical { if (( point . x > min ( line . point1 . x , line . point2 . x )) && ( point . x < max ( line . point1 . x , line . point2 . x ))) { if ( abs ( point . y - line . point1 . y - ( line . point2 . y - line . point1 . y ) / ( line . point1 . x - line . point2 . x ) * ( line . point1 . x - point . x )) < EPSILON * EPSILON ) { result = true ; } } } else // line is vertical { if ( line . point1 . x == point . x ) { if (( point . y > min ( line . point1 . y , line . point2 . y )) && ( point . y < max ( line . point1 . y , line . point2 . y ))) { result = true ; } } } return result ; } void XYGeoTools :: Intersect ( const XYPolygon & triangleA , const XYPolygon & triangleB , XYPoint & p , int & i , int & j , XYPolygon & intersectionPolygon ) { XYLine lineA ; XYLine lineB ; int im1 = DecrementModula ( i , 3 ); // \"i-1\" int count1 = 0 ; bool found = false ; while (( count1 < 3 ) && ( ! found )) { lineA = triangleA . GetLine ( im1 ); if ( count1 == 0 ) { lineA = XYLine ( lineA ); lineA . point1 = p ; } double MinDist = -1 ; // Distance used when a line is crossed more than once. int jm1 = 0 ; // \"j-1\" int jm1Store = -1 ; while ( jm1 < 3 ) { lineB = triangleB . GetLine ( jm1 ); found = IntersectionPoint ( lineA , lineB , p ); double Dist = CalculatePointToPointDistance ( lineA . point1 , p ); if ( Dist < EPSILON ) { found = false ; } if ( found ) { if (( MinDist < 0 ) || ( Dist < MinDist )) { MinDist = Dist ; jm1Store = jm1 ; } } jm1 ++ ; } if ( jm1Store > -1 ) { lineB = triangleB . GetLine ( jm1Store ); found = IntersectionPoint ( lineA , lineB , p ); XYPoint HelpCoordinate ( p ); XYPoint HelpNode ( HelpCoordinate ); intersectionPolygon . points . push_back ( HelpNode ); j = IncrementModula ( jm1Store , 3 ); } if ( ! found ) { count1 ++ ; im1 = IncrementModula ( im1 , 3 ); i = IncrementModula ( i , 3 ); if ( j != -1 ) { XYPoint HelpCoordinate ( lineA . point2 ); XYPoint HelpNode ( HelpCoordinate ); intersectionPolygon . points . push_back ( HelpNode ); } } } lineA = triangleA . GetLine ( DecrementModula ( i , 3 )); if ( CalculatePointToPointDistance ( p , lineA . point2 ) < EPSILON ) { i = IncrementModula ( i , 3 ); } lineB = triangleB . GetLine ( DecrementModula ( j , 3 )); if ( CalculatePointToPointDistance ( p , lineB . point2 ) < EPSILON ) { j = IncrementModula ( j , 3 ); } } int XYGeoTools :: IncrementModula ( int i , int n ) { i ++ ; i %= n ; return i ; } int XYGeoTools :: DecrementModula ( int i , int n ) { i -- ; if ( i < 0 ) { i = n - 1 ; } return i ; } } // namespace OpenOasis::CommImp::Spatial","title":"File XYGeoTools.cpp"},{"location":"models/_x_y_geo_tools_8h/","text":"File XYGeoTools.h \u00b6 FileList > CommImp > Spatial > XYGeoTools.h Go to the source code of this file #include \"XYGeoStructs.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Spatial Classes \u00b6 Type Name class XYGeoTools The XYGeoTools class is a collection of general geometry functions. The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoTools.h","title":"File XYGeoTools.h"},{"location":"models/_x_y_geo_tools_8h/#file-xygeotoolsh","text":"FileList > CommImp > Spatial > XYGeoTools.h Go to the source code of this file #include \"XYGeoStructs.h\"","title":"File XYGeoTools.h"},{"location":"models/_x_y_geo_tools_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Spatial","title":"Namespaces"},{"location":"models/_x_y_geo_tools_8h/#classes","text":"Type Name class XYGeoTools The XYGeoTools class is a collection of general geometry functions. The documentation for this class was generated from the following file Models/CommImp/Spatial/XYGeoTools.h","title":"Classes"},{"location":"models/_x_y_geo_tools_8h_source/","text":"File XYGeoTools.h \u00b6 File List > CommImp > Spatial > XYGeoTools.h Go to the documentation of this file #pragma once #include \"XYGeoStructs.h\" namespace OpenOasis { namespace CommImp { namespace Spatial { class XYGeoTools final { public : static constexpr double EPSILON = 1.0e-5 ; static double CalculatePointToPointDistance ( const XYPoint & p1 , const XYPoint & p2 ); static bool IsLinesIntersected ( const XYLine & l1 , const XYLine & l2 ); static XYPoint CalculateIntersectionPoint ( const XYLine & l1 , const XYLine & l2 ); static XYPoint CalculateMidpoint ( const XYLine & line ); static double CalculateLineToPointDistance ( const XYLine & line , const XYPoint & point ); static double CalculatePolylineToPointDistance ( const XYPolyline & polyline , const XYPoint & point ); static bool IsPointInLine ( const XYPoint & point , const XYLine & line ); static double CalculateSharedArea ( const XYPolygon & polygonA , const XYPolygon & polygonB ); static bool IsPointInPolygon ( const XYPoint & point , const XYPolygon & polygon ); static std :: vector < XYPolygon > GetTriangulations ( const XYPolygon & polygon ); static double CalculateLengthOfLineInsidePolygon ( const XYLine & line , const XYPolygon & polygon ); static double CalculateLengthOfPolylineInsidePolygon ( const XYPolyline & polyline , const XYPolygon & polygon ); protected : static int FindTrianglePoints ( const XYPolygon & polygon ); static bool IsTriangleIntersected ( const XYPolygon & polygon , int i ); static double CalculateTriangleSharedArea ( const XYPolygon & triangleA , const XYPolygon & triangleB ); static double CalculateSharedLength ( const XYLine & lineA , const XYLine & lineB ); static bool IntersectionPoint ( const XYLine & LineA , const XYLine & LineB , XYPoint & intersectionPoint ); static bool IsPointInLineInterior ( const XYPoint & point , const XYLine & line ); static void Intersect ( const XYPolygon & triangleA , const XYPolygon & triangleB , XYPoint & p , int & i , int & j , XYPolygon & intersectionPolygon ); static int IncrementModula ( int i , int n ); static int DecrementModula ( int i , int n ); }; } // namespace Spatial } // namespace CommImp } // namespace OpenOasis","title":"File XYGeoTools.h"},{"location":"models/_x_y_geo_tools_8h_source/#file-xygeotoolsh","text":"File List > CommImp > Spatial > XYGeoTools.h Go to the documentation of this file #pragma once #include \"XYGeoStructs.h\" namespace OpenOasis { namespace CommImp { namespace Spatial { class XYGeoTools final { public : static constexpr double EPSILON = 1.0e-5 ; static double CalculatePointToPointDistance ( const XYPoint & p1 , const XYPoint & p2 ); static bool IsLinesIntersected ( const XYLine & l1 , const XYLine & l2 ); static XYPoint CalculateIntersectionPoint ( const XYLine & l1 , const XYLine & l2 ); static XYPoint CalculateMidpoint ( const XYLine & line ); static double CalculateLineToPointDistance ( const XYLine & line , const XYPoint & point ); static double CalculatePolylineToPointDistance ( const XYPolyline & polyline , const XYPoint & point ); static bool IsPointInLine ( const XYPoint & point , const XYLine & line ); static double CalculateSharedArea ( const XYPolygon & polygonA , const XYPolygon & polygonB ); static bool IsPointInPolygon ( const XYPoint & point , const XYPolygon & polygon ); static std :: vector < XYPolygon > GetTriangulations ( const XYPolygon & polygon ); static double CalculateLengthOfLineInsidePolygon ( const XYLine & line , const XYPolygon & polygon ); static double CalculateLengthOfPolylineInsidePolygon ( const XYPolyline & polyline , const XYPolygon & polygon ); protected : static int FindTrianglePoints ( const XYPolygon & polygon ); static bool IsTriangleIntersected ( const XYPolygon & polygon , int i ); static double CalculateTriangleSharedArea ( const XYPolygon & triangleA , const XYPolygon & triangleB ); static double CalculateSharedLength ( const XYLine & lineA , const XYLine & lineB ); static bool IntersectionPoint ( const XYLine & LineA , const XYLine & LineB , XYPoint & intersectionPoint ); static bool IsPointInLineInterior ( const XYPoint & point , const XYLine & line ); static void Intersect ( const XYPolygon & triangleA , const XYPolygon & triangleB , XYPoint & p , int & i , int & j , XYPolygon & intersectionPolygon ); static int IncrementModula ( int i , int n ); static int DecrementModula ( int i , int n ); }; } // namespace Spatial } // namespace CommImp } // namespace OpenOasis","title":"File XYGeoTools.h"},{"location":"models/dir_ffb56fa5fbb3b89fb2d1e87d90c0c2f7/","text":"Dir Models/CommImp/Temporal \u00b6 FileList > CommImp > Temporal Files \u00b6 Type Name file TimeBuffer.cpp file TimeBuffer.h The documentation for this class was generated from the following file Models/CommImp/Temporal/","title":"Dir Models/CommImp/Temporal"},{"location":"models/dir_ffb56fa5fbb3b89fb2d1e87d90c0c2f7/#dir-modelscommimptemporal","text":"FileList > CommImp > Temporal","title":"Dir Models/CommImp/Temporal"},{"location":"models/dir_ffb56fa5fbb3b89fb2d1e87d90c0c2f7/#files","text":"Type Name file TimeBuffer.cpp file TimeBuffer.h The documentation for this class was generated from the following file Models/CommImp/Temporal/","title":"Files"},{"location":"models/_time_buffer_8cpp/","text":"File TimeBuffer.cpp \u00b6 FileList > CommImp > Temporal > TimeBuffer.cpp Go to the source code of this file #include \"TimeBuffer.h\" #include \"Models/CommImp/Time.h\" #include \"Models/CommImp/DevSupports/ExtensionMethods.h\" #include \"Models/Utils/Exception.h\" Namespaces \u00b6 Type Name namespace DevSupports namespace OpenOasis namespace CommImp namespace Temporal The documentation for this class was generated from the following file Models/CommImp/Temporal/TimeBuffer.cpp","title":"File TimeBuffer.cpp"},{"location":"models/_time_buffer_8cpp/#file-timebuffercpp","text":"FileList > CommImp > Temporal > TimeBuffer.cpp Go to the source code of this file #include \"TimeBuffer.h\" #include \"Models/CommImp/Time.h\" #include \"Models/CommImp/DevSupports/ExtensionMethods.h\" #include \"Models/Utils/Exception.h\"","title":"File TimeBuffer.cpp"},{"location":"models/_time_buffer_8cpp/#namespaces","text":"Type Name namespace DevSupports namespace OpenOasis namespace CommImp namespace Temporal The documentation for this class was generated from the following file Models/CommImp/Temporal/TimeBuffer.cpp","title":"Namespaces"},{"location":"models/_time_buffer_8cpp_source/","text":"File TimeBuffer.cpp \u00b6 File List > CommImp > Temporal > TimeBuffer.cpp Go to the documentation of this file #include \"TimeBuffer.h\" #include \"Models/CommImp/Time.h\" #include \"Models/CommImp/DevSupports/ExtensionMethods.h\" #include \"Models/Utils/Exception.h\" namespace OpenOasis :: CommImp :: Temporal { using namespace DevSupports ; using namespace Utils ; using namespace std ; TimeBuffer :: TimeBuffer () { SetDoExtrapolate ( true ); Create (); } TimeBuffer :: TimeBuffer ( const TimeBuffer & TimeBuffer ) { SetDoExtrapolate ( true ); Create (); } void TimeBuffer :: SetDoExtrapolate ( bool value ) { mDoExtrapolate = value ; } bool TimeBuffer :: GetDoExtrapolate () const { return mDoExtrapolate ; } void TimeBuffer :: Create () { mDoExtendedDataVerification = true ; mRelaxationFactor = 1.0 ; mTimes = make_shared < TimeSet > (); mValues = make_shared < ValueSet2D > (); } void TimeBuffer :: AddValues ( const shared_ptr < ITime > & time , const vector < real > & values ) { AddValuesToBuffer ( time , values ); } void TimeBuffer :: AddValuesToBuffer ( const shared_ptr < ITime > & time , const vector < real > & values ) { // Check if we can add the values if ( mTimes -> HasDurations ()) { if ( time -> GetDurationInDays () <= 0 ) { throw runtime_error ( \"Time without duration added to time set with durations.\" ); } // Order of times: The end time is allowed to overlap with at most // Time::EpsilonForTimeCompare with the new time. if ( mTimes -> GetTimes (). size () > 0 && time -> GetTimeStamp () + Time :: EpsilonForTimeCompare < ExtensionMethods :: EndTimeStamp ( mTimes -> GetTimeHorizon ())) { return ; // throw runtime_error(\"Overlapping times out of order times in time // buffer.\"); } } else { if ( time -> GetDurationInDays () > 0 ) { throw runtime_error ( \"Time with duration added to time set without durations.\" ); } // Order of times: There must at least be a difference of // Time.EpsilonForTimeCompare between two stamps. if ( mTimes -> GetCount () > 0 && time -> GetTimeStamp () - Time :: EpsilonForTimeCompare < mTimes -> GetTimeHorizon () -> GetTimeStamp ()) { return ; // throw runtime_error(\"Overlapping times out of order times in time // buffer.\"); } } mTimes -> AddTime ( make_shared < Time > ( time )); // save a copy of time for ( int i = 0 ; i < ( int ) values . size (); ++ i ) { mValues -> SetOrAddValue ({ mTimes -> GetCount () - 1 , i }, values [ i ]); } } real TimeBuffer :: GetRelaxationFactor () const { return mRelaxationFactor ; } void TimeBuffer :: SetRelaxationFactor ( real value ) { mRelaxationFactor = value ; if ( mRelaxationFactor < 0 || mRelaxationFactor > 1 ) { throw runtime_error ( \"ReleaxationFactor is out of range\" ); } } shared_ptr < ITime > TimeBuffer :: GetTimeAt ( int timeStep ) const { if ( mDoExtendedDataVerification ) { CheckBuffer (); } return ( * mTimes )[ timeStep ]; } void TimeBuffer :: CheckBuffer () const { if ( mTimes -> GetCount () != mValues -> GetIndexCount ({ 0 })) { throw runtime_error ( \"Different numbers of values and times in buffer\" ); } if ( mTimes -> GetCount () == 0 ) { throw runtime_error ( \"Buffer is empty\" ); } } vector < real > TimeBuffer :: GetValuesAt ( int timeStep ) const { if ( mDoExtendedDataVerification ) { CheckBuffer (); } vector < real > values ; for ( const auto & val : mValues -> GetElementValuesForTime ( timeStep )) { values . push_back ( any_cast < real > ( val )); } return values ; } vector < real > TimeBuffer :: GetValues ( const shared_ptr < ITime > & requestedTime ) { if ( mDoExtendedDataVerification ) { CheckBuffer (); } if ( ! mDoExtrapolate ) { if ( ExtensionMethods :: End ( requestedTime ) -> GetTimeStamp () > ExtensionMethods :: End ( mTimes -> GetTimeHorizon ()) -> GetTimeStamp () + Time :: EpsilonForTimeCompare || ExtensionMethods :: Start ( requestedTime ) -> GetTimeStamp () < ExtensionMethods :: Start ( mTimes -> GetTimeHorizon ()) -> GetTimeStamp () - Time :: EpsilonForTimeCompare ) { throw runtime_error ( \"Extrapolation not allowed for this buffer\" ); } } vector < real > returnValues ; if ( mValues -> GetIndexCount ({ 0 }) != 0 ) { if ( mTimes -> HasDurations () && requestedTime -> GetDurationInDays () > 0 ) { returnValues = MapFromTimeSpansToTimeSpan ( requestedTime ); } else if ( mTimes -> HasDurations () && requestedTime -> GetDurationInDays () <= Time :: EpsilonForTimeCompare ) { returnValues = MapFromTimeSpansToTimeStamp ( requestedTime ); } else if ( ! mTimes -> HasDurations () && requestedTime -> GetDurationInDays () > 0 ) { returnValues = MapFromTimeStampsToTimeSpan ( requestedTime ); } else // time stamps { returnValues = MapFromTimeStampsToTimeStamp ( requestedTime ); } } return returnValues ; } vector < real > TimeBuffer :: MapFromTimeStampsToTimeStamp ( const shared_ptr < ITime > & requestedTimeStamp ) { try { int elementCount = mValues -> GetIndexCount ({ 0 , 0 }); real tr = requestedTimeStamp -> GetTimeStamp (); // Requested TimeStamp vector < real > vr ( elementCount ); // Values to return const auto & times = mTimes -> GetTimes (); if ( times . size () == 1 ) { //------------------------------------------------------------------------- // Buffered TimesStamps:| >tb0< // Requested TimeStamp: | >tr< // or Requested TimeStamp: | >tr< // or Requested TimeStamp: | >tr< // -------------------------------------------> t // ------------------------------------------------------------------------ if ( tr > ( times . front () -> GetTimeStamp () + Time :: EpsilonForTimeCompare ) && ! mDoExtrapolate ) { throw runtime_error ( \"Extrapolation not allowed\" ); } for ( int i = 0 ; i < elementCount ; i ++ ) { vr [ i ] = any_cast < real > ( mValues -> GetValue ({ 0 , i })); } } else if ( tr <= times . front () -> GetTimeStamp ()) { //------------------------------------------------------------------------- // Buffered TimesStamps:| >tb0< >tb1< >tb2< >tbN< // Requested TimeStamp: | >tr< // ---------------------------------------------> t // ------------------------------------------------------------------------ real tb0 = times [ 0 ] -> GetTimeStamp (); real tb1 = times [ 1 ] -> GetTimeStamp (); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); real sbi1 = any_cast < real > ( mValues -> GetValue ({ i , i })); vr [ i ] = (( sbi0 - sbi1 ) / ( tb0 - tb1 )) * ( tr - tb0 ) * ( 1 - mRelaxationFactor ) + sbi0 ; } } else if ( tr > times . back () -> GetTimeStamp ()) { //------------------------------------------------------------------------- // Buffered TimesStamps:| >tb0< >tb1< >tb2< >tbN_2< >tbN_1< // Requested TimeStamp: | >tr< // ---------------------------------------------> t // ------------------------------------------------------------------------ int size = times . size (); real tbN_2 = times [ size - 2 ] -> GetTimeStamp (); real tbN_1 = times [ size - 1 ] -> GetTimeStamp (); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN_2 = any_cast < real > ( mValues -> GetValue ({ size - 2 , i })); real sbiN_1 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); vr [ i ] = (( sbiN_1 - sbiN_2 ) / ( tbN_1 - tbN_2 )) * ( tr - tbN_1 ) * ( 1 - mRelaxationFactor ) + sbiN_1 ; } } else { //------------------------------------------------------------------------- // Available TimesStamps: | >tb0< >tb1< >tbna< >tnb< >tbN_1< >tbN_2< // Requested TimeStamp: | >tr< // ---------------------------------------------> t // ------------------------------------------------------------------------ const auto & iter = find_if ( begin ( times ), end ( times ), [ & tr ]( const auto & t ) { return t -> GetTimeStamp () >= tr ; }); int iHigh = distance ( begin ( times ), iter ); real fraction = ( tr - times [ iHigh - 1 ] -> GetTimeStamp ()) / ( times [ iHigh ] -> GetTimeStamp () - times [ iHigh - 1 ] -> GetTimeStamp ()); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbinA = any_cast < real > ( mValues -> GetValue ({ iHigh - 1 , i })); real sbinB = any_cast < real > ( mValues -> GetValue ({ iHigh , i })); vr [ i ] = sbinA + fraction * ( sbinB - sbinA ); } } return vr ; } catch ( const runtime_error & e ) { throw runtime_error ( \"MapFromTimeStampsToTimeStamp Failed\" ); } } vector < real > TimeBuffer :: MapFromTimeSpansToTimeSpan ( const shared_ptr < ITime > & requestedTime ) { try { int elementCount = mValues -> GetIndexCount ({ 0 , 0 }); vector < real > vr ( elementCount ); // Values to return // Begin time in requester time interval real trb = requestedTime -> GetTimeStamp (); // End time in requester time interval real tre = requestedTime -> GetTimeStamp () + requestedTime -> GetDurationInDays (); // length of requested time interval real trl = tre - trb ; const auto & times = mTimes -> GetTimes (); int size = ( int ) times . size (); if ( times . empty ()) { throw runtime_error ( \"No times in buffer\" ); } real tbb0 = times [ 0 ] -> GetTimeStamp (); // In the following the current abbreviations are used: // B: Buffer time // R: Requested time // I: Time included by this part of the code if ( mDoExtrapolate ) { //------------------------------------------------------------------------- // B tbb0|-------tbe0|tbb1------|tbe1 // R+I trb|---|tre //------------------------------------------------------------------------- if ( tre <= tbb0 ) { if ( size >= 2 && mRelaxationFactor != 1 ) { // Linear interpolation real tbe0 = ExtensionMethods :: End ( times [ 0 ]) -> GetTimeStamp (); // real tbb1 = times[1]->GetTimeStamp(); real tbe1 = ExtensionMethods :: End ( times [ 1 ]) -> GetTimeStamp (); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); real sbi1 = any_cast < real > ( mValues -> GetValue ({ 1 , i })); vr [ i ] = sbi0 - ( 1 - mRelaxationFactor ) * ( sbi1 - sbi0 ) * ( tbe0 + tbb0 - tre - trb ) / ( tbe1 - tbb0 ); } } else { // Nearest value interpolation for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); vr [ i ] = sbi0 ; } } return vr ; } //------------------------------------------------------------------------- // B tbb0|--------|---------|--------| // R trb|----------------|tre // I |-----| //------------------------------------------------------------------------- if ( trb < tbb0 ) // && tre > tbb0 { real tbe0 = ExtensionMethods :: End ( times [ 0 ]) -> GetTimeStamp (); if ( size >= 2 && mRelaxationFactor != 1 ) { real tbe1 = ExtensionMethods :: End ( times [ 1 ]) -> GetTimeStamp (); // Linear interpolation, use tbb0 as \"endpoint\" of interval for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); real sbi1 = any_cast < real > ( mValues -> GetValue ({ 1 , i })); vr [ i ] += (( tbb0 - trb ) / trl ) * ( sbi0 - ( 1 - mRelaxationFactor ) * ( sbi1 - sbi0 ) * ( tbe0 - trb ) / ( tbe1 - tbb0 )); } } else { // Nearest value interpolation for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); vr [ i ] += sbi0 * ( tbb0 - trb ) / trl ; } } } real tbeN0 = ExtensionMethods :: End ( times . back ()) -> GetTimeStamp (); //-------------------------------------------------------------------------- // B tbb0|---?----|-------|tbeN0 // R+I trb|---|tre //-------------------------------------------------------------------------- if ( tbeN0 < trb ) { if ( size >= 2 && mRelaxationFactor != 1 ) { // Linear interpolation real tbeN1 = ExtensionMethods :: End ( times [ size - 2 ]) -> GetTimeStamp (); real tbbN1 = times [ size - 2 ] -> GetTimeStamp (); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN0 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); real sbiN1 = any_cast < real > ( mValues -> GetValue ({ size - 2 , i })); ; vr [ i ] = sbiN0 + ( 1 - mRelaxationFactor ) * ( sbiN0 - sbiN1 ) * ( trb + tre - tbeN0 - tbeN1 ) / ( tbeN0 - tbbN1 ); } } else { // Nearest value interpolation for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN0 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); vr [ i ] = sbiN0 ; } } return vr ; } //-------------------------------------------------------------------------- // B |---?----|-------|tbeN0 // R trb|-------|tre // I |---| //-------------------------------------------------------------------------- if ( tbeN0 < tre ) { if ( size >= 2 && mRelaxationFactor != 1 ) { real tbeN1 = ExtensionMethods :: End ( times [ size - 2 ]) -> GetTimeStamp (); real tbbN1 = times [ size - 2 ] -> GetTimeStamp (); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN0 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); real sbiN1 = any_cast < real > ( mValues -> GetValue ({ size - 2 , i })); vr [ i ] += (( tre - tbeN0 ) / ( tre - trb )) * ( sbiN0 + ( 1 - mRelaxationFactor ) * ( sbiN0 - sbiN1 ) * ( tre - tbeN1 ) / ( tbeN0 - tbbN1 )); } } else { for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN0 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); vr [ i ] += sbiN0 * (( tre - tbeN0 ) / ( tre - trb )); } } } } int nstart = 0 ; int nend = size - 1 ; // Narrow down the number of spans to investigate, based on the requested span. if ( nend > 10 ) { // Assuming 4 spans in the buffer, use end-time in GetIntrval // will provide the right indices // spans |-0-|-1-|-2-|-3-| // endStamp intervals 0 | 1 | 2 | 3 | 4 const auto & iter1 = find_if ( begin ( times ), end ( times ), [ & trb ]( const auto & t ) { return t -> GetTimeStamp () >= trb ; }); nstart = distance ( begin ( times ), iter1 ); const auto & iter2 = find_if ( begin ( times ), end ( times ), [ & tre ]( const auto & t ) { return ExtensionMethods :: End ( t ) -> GetTimeStamp () >= tre ; }); nend = distance ( begin ( times ), iter2 ); nend = min ( nend , size - 1 ); } for ( int n = nstart ; n <= nend ; n ++ ) { real tbbn = times [ n ] -> GetTimeStamp (); real tben = ExtensionMethods :: End ( times [ n ]) -> GetTimeStamp (); //--------------------------------------------------------------------------- // B: tbbn|--------------------------|tben // R: trb|-------------------------------------|tre // I: |--------------------------| //--------------------------------------------------------------------------- if ( trb <= tbbn && tre >= tben ) { for ( int i = 0 ; i < elementCount ; i ++ ) { real sbin = any_cast < real > ( mValues -> GetValue ({ n , i })); vr [ i ] += sbin * ( tben - tbbn ) / ( tre - trb ); } } //--------------------------------------------------------------------------- // B: tbbn|-----------------------|tben // R+I: trb|--------------|tre // -------------------------------------------------------------------------- else if ( tbbn <= trb && tre <= tben ) // cover all { for ( int i = 0 ; i < elementCount ; i ++ ) { vr [ i ] += any_cast < real > ( mValues -> GetValue ({ n , i })); } } //--------------------------------------------------------------------------- // B: tbbn|-----------------|tben // R: trb|--------------|tre // I: |------| // -------------------------------------------------------------------------- else if ( tbbn < trb && trb < tben && tre > tben ) { for ( int i = 0 ; i < elementCount ; i ++ ) { real sbin = any_cast < real > ( mValues -> GetValue ({ n , i })); vr [ i ] += sbin * ( tben - trb ) / ( tre - trb ); } } //--------------------------------------------------------------------------- // B: tbbn|-----------------|tben // R: trb|--------------|tre // I: |--------| // -------------------------------------------------------------------------- else if ( trb < tbbn && tre > tbbn && tre < tben ) { for ( int i = 0 ; i < elementCount ; i ++ ) { real sbin = any_cast < real > ( mValues -> GetValue ({ n , i })); vr [ i ] += sbin * ( tre - tbbn ) / ( tre - trb ); } } } return vr ; } catch ( const runtime_error & e ) { throw runtime_error ( \"MapFromTimeSpansToTimeSpan Failed\" ); } } vector < real > TimeBuffer :: MapFromTimeStampsToTimeSpan ( const shared_ptr < ITime > & requestedTime ) { try { int elementCount = mValues -> GetIndexCount ({ 0 , 0 }); vector < real > vr ( elementCount ); // Values to return // Begin time in requester time interval real trb = requestedTime -> GetTimeStamp (); // End time in requester time interval real tre = requestedTime -> GetTimeStamp () + requestedTime -> GetDurationInDays (); // length of requested time interval // real trl = tre - trb; const auto & times = mTimes -> GetTimes (); int size = ( int ) times . size (); //----------------------------------------------------------------------------- // This handles values within the time horizon of the buffer, i.e. // there must be at least two values in the buffer. int nstart = 1 ; int nend = size - 1 ; // Narrow down the number of intervals to investigate, // based on the requested span. if ( nend > 4 ) { const auto & iter1 = find_if ( begin ( times ), end ( times ), [ & trb ]( const auto & t ) { return t -> GetTimeStamp () >= trb ; }); nstart = distance ( begin ( times ), iter1 ); nstart = max ( nstart , 1 ); const auto & iter2 = find_if ( begin ( times ), end ( times ), [ & tre ]( const auto & t ) { return ExtensionMethods :: End ( t ) -> GetTimeStamp () >= tre ; }); nend = distance ( begin ( times ), iter2 ); nend = min ( nend , size - 1 ); } // n corresponds to the n'th interval between the time stamps. for ( int n = nstart ; n <= nend ; n ++ ) { real tbn = times [ n - 1 ] -> GetTimeStamp (); real tbnp1 = times [ n ] -> GetTimeStamp (); //------------------------------------------------------------------------- // B: tbn|--------------------------|tbnp1 // R: trb|-------------------------------------|tre // I: |--------------------------| // ------------------------------------------------------------------------ if ( trb <= tbn && tre >= tbnp1 ) { real factor = ( tbnp1 - tbn ) / ( tre - trb ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbin = any_cast < real > ( mValues -> GetValue ({ n - 1 , i })); real sbinp1 = any_cast < real > ( mValues -> GetValue ({ n , i })); vr [ i ] += 0.5 * ( sbin + sbinp1 ) * factor ; } } //------------------------------------------------------------------------- // B: tbn|-----------------------|tbnp1 // R+I: trb|--------------|tre // ------------------------------------------------------------------------ else if ( tbn <= trb && tre <= tbnp1 ) // cover all { real fraction = (( tre + trb ) / 2 - tbn ) / ( tbnp1 - tbn ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbin = any_cast < real > ( mValues -> GetValue ({ n - 1 , i })); real sbinp1 = any_cast < real > ( mValues -> GetValue ({ n , i })); vr [ i ] += sbin + ( sbinp1 - sbin ) * fraction ; } } //------------------------------------------------------------------------- // B: tbn|-----------------|tbnp1 // R: trb|--------------|tre // I: |------| // ------------------------------------------------------------------------ else if ( tbn < trb && trb < tbnp1 && tre > tbnp1 ) { real fraction = (( tbnp1 - trb ) / 2 ) / ( tbnp1 - tbn ); real factor = ( tbnp1 - trb ) / ( tre - trb ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbin = any_cast < real > ( mValues -> GetValue ({ n - 1 , i })); real sbinp1 = any_cast < real > ( mValues -> GetValue ({ n , i })); vr [ i ] += ( sbinp1 - ( sbinp1 - sbin ) * fraction ) * factor ; } } //------------------------------------------------------------------------- // B: tbn|-----------------|tbnp1 // R: trb|--------------|tre // I: |--------| // ------------------------------------------------------------------------ else if ( trb < tbn && tre > tbn && tre < tbnp1 ) { real fraction = (( tre - tbn ) / 2 ) / ( tbnp1 - tbn ); real factor = ( tre - tbn ) / ( tre - trb ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbin = any_cast < real > ( mValues -> GetValue ({ n - 1 , i })); real sbinp1 = any_cast < real > ( mValues -> GetValue ({ n , i })); vr [ i ] += ( sbin + ( sbinp1 - sbin ) * fraction ) * factor ; } } } //----------------------------------------------------------------------------- // This handles values outside the time horizon of the buffer. //----------------------------------------------------------------------------- // In case of only one value in the buffer, regardless of its position relative // to R // | or | or | B // |----------------| R //----------------------------------------------------------------------------- if ( size == 1 ) { // TODO: Test if extrapolation is ok. for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); vr [ i ] = sbi0 ; } } else { // At least two stamp values in the buffer, so we can do extrapolation //------------------------------------------------------------------------- // B: tb0|-----tb1|---------|--------| // R: trb|----------------|tre // I: |-----| //------------------------------------------------------------------------- real tb0 = times [ 0 ] -> GetTimeStamp (); real tb1 = times [ 1 ] -> GetTimeStamp (); real tbN_1 = times [ size - 1 ] -> GetTimeStamp (); real tbN_2 = times [ size - 2 ] -> GetTimeStamp (); if ( trb < tb0 && tre > tb0 ) { real fraction = ( 1 - mRelaxationFactor ) * 0.5 * ( tb0 - trb ) / ( tb1 - tb0 ); real factor = (( tb0 - trb ) / ( tre - trb )); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); real sbi1 = any_cast < real > ( mValues -> GetValue ({ 1 , i })); vr [ i ] += factor * ( sbi0 - fraction * ( sbi1 - sbi0 )); } } //------------------------------------------------------------------------- // B |--------|---------|tbn_2---|tbn_1 // R trb|----------------|tre // I |----------| //------------------------------------------------------------------------- if ( tre > tbN_1 && trb < tbN_1 ) { real factor = (( tre - tbN_1 ) / ( tre - trb )); real fraction = ( 1 - mRelaxationFactor ) * 0.5 * ( tre - tbN_1 ) / ( tbN_1 - tbN_2 ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN_1 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); real sbiN_2 = any_cast < real > ( mValues -> GetValue ({ size - 2 , i })); vr [ i ] += factor * ( sbiN_1 + fraction * ( sbiN_1 - sbiN_2 )); } } //------------------------------------------------------------------------- // B : |--------|---------|tbn_2---|tbn_1 // R+I : trb|----------------|tre //------------------------------------------------------------------------- if ( trb >= tbN_1 ) { real fraction = ( 1 - mRelaxationFactor ) * ( 0.5 * ( trb + tre ) - tbN_1 ) / ( tbN_1 - tbN_2 ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN_1 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); real sbiN_2 = any_cast < real > ( mValues -> GetValue ({ size - 2 , i })); vr [ i ] = sbiN_1 + ( sbiN_1 - sbiN_2 ) * fraction ; } } //------------------------------------------------------------------------- // B : tb0|-----tb1|---------|--------| B // R+I : trb|-------|tre //------------------------------------------------------------------------- if ( tre <= tb0 ) { real fraction = ( 1 - mRelaxationFactor ) / ( tb1 - tb0 ) * ( tb0 - 0.5 * ( trb + tre )); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); real sbi1 = any_cast < real > ( mValues -> GetValue ({ 1 , i })); vr [ i ] = sbi0 - ( sbi1 - sbi0 ) * fraction ; } } } return vr ; } catch ( const runtime_error & e ) { throw runtime_error ( \"MapFromTimeStampsToTimeSpan Failed\" ); } } vector < real > TimeBuffer :: MapFromTimeSpansToTimeStamp ( const shared_ptr < ITime > & requestedTimeStamp ) { try { int elementCount = mValues -> GetIndexCount ({ 0 , 0 }); vector < real > vr ( elementCount ); // Values to return const auto & times = mTimes -> GetTimes (); int size = ( int ) times . size (); real tr = requestedTimeStamp -> GetTimeStamp (); // Requested TimeStamp if ( size == 1 ) { //------------------------------------------------------------------------- // Buffered TimesSpans: | |------| // Requested TimeStamp: | >tr< // or Requested TimeStamp: | >tr< // or Requested TimeStamp: | >tr< // -----------------------------------------> t // ------------------------------------------------------------------------ // Check if tr is inside span if ( ! mDoExtrapolate ) { if ( times [ 0 ] -> GetTimeStamp () - Time :: EpsilonForTimeCompare > tr || tr > ExtensionMethods :: End ( times . back ()) -> GetTimeStamp () + Time :: EpsilonForTimeCompare ) { throw runtime_error ( \"Extrapolation not allowed\" ); } } for ( int i = 0 ; i < elementCount ; i ++ ) // For each element { vr [ i ] = any_cast < real > ( mValues -> GetValue ({ 0 , i })); } } //----------------------------------------------------------------------------- // Buffered TimesSpans: | >tbb0< .......... >tbbN< // Requested TimeStamp: | >tr< // -----------------------------------------> t // ---------------------------------------------------------------------------- else if ( tr <= times [ 0 ] -> GetTimeStamp ()) { // Check if we are allowed to extrapolate if ( ! mDoExtrapolate ) { if ( tr < times [ 0 ] -> GetTimeStamp () - Time :: EpsilonForTimeCompare ) { throw runtime_error ( \"Extrapolation not allowed\" ); } // Very close to the first point, just provide that value for ( int i = 0 ; i < elementCount ; i ++ ) // For each element { vr [ i ] = any_cast < real > ( mValues -> GetValue ({ 0 , i })); } } else { // Extrapolate from the first two values real tbb0 = times [ 0 ] -> GetTimeStamp (); real tbb1 = times [ 1 ] -> GetTimeStamp (); real fraction = ( tr - tbb0 ) / ( tbb0 - tbb1 ) * ( 1 - mRelaxationFactor ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); real sbi1 = any_cast < real > ( mValues -> GetValue ({ 1 , i })); vr [ i ] = ( sbi0 - sbi1 ) * fraction + sbi0 ; } } } //----------------------------------------------------------------------------- // Buffered TimesSpans: | >tbb0< ................. >tbbN_1< // Requested TimeStamp: | >tr< // -------------------------------------------------> t // ---------------------------------------------------------------------------- else if ( tr >= ExtensionMethods :: End ( times . back ()) -> GetTimeStamp ()) { // Check if we are allowed to extrapolate if ( ! mDoExtrapolate ) { if ( tr > times . back () -> GetTimeStamp () + Time :: EpsilonForTimeCompare ) { throw runtime_error ( \"Extrapolation not allowed\" ); } // Very close to the last point, just provide that value for ( int i = 0 ; i < elementCount ; i ++ ) { vr [ i ] = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); } } else { // Extrapolate from the last two values real tbeN_2 = ExtensionMethods :: End ( times [ size - 2 ]) -> GetTimeStamp (); real tbeN_1 = ExtensionMethods :: End ( times [ size - 1 ]) -> GetTimeStamp (); real fraction = ( tr - tbeN_1 ) / ( tbeN_1 - tbeN_2 ) * ( 1 - mRelaxationFactor ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN_2 = any_cast < real > ( mValues -> GetValue ({ size - 2 , i })); real sbiN_1 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); vr [ i ] = ( sbiN_1 - sbiN_2 ) * fraction + sbiN_1 ; } } } //----------------------------------------------------------------------------- // Availeble TimesSpans: | >tbb0< ...................... >tbbN_1< // Requested TimeStamp: | >tr< // -------------------------------------------------> t // ---------------------------------------------------------------------------- else { // Using end-time will provide the right indices // Example: assuming 4 spans in the buffer, // spans |-0-|-1-|-2-|-3-| // endStamp intervals 0 | 1 | 2 | 3 | 4 const auto & iter = find_if ( begin ( times ), end ( times ), [ tr ]( const auto & t ) { return t -> GetTimeStamp () <= tr && t -> GetTimeStamp () + t -> GetDurationInDays () >= tr ; }); int interval = distance ( begin ( times ), iter ); for ( int i = 0 ; i < elementCount ; i ++ ) { vr [ i ] = any_cast < real > ( mValues -> GetValue ({ interval , i })); } } return vr ; } catch ( const runtime_error & e ) { throw runtime_error ( \"MapFromTimeSpansToTimeStamp Failed\" ); } } int TimeBuffer :: GetTimesCount () const { return mTimes -> GetCount (); } int TimeBuffer :: GetValuesCount () const { return mValues -> GetIndexCount ({ 0 , 0 }); } void TimeBuffer :: ClearAfter ( shared_ptr < ITime > time ) { real clearTimestamp = ExtensionMethods :: Start ( time ) -> GetTimeStamp (); for ( int i = 0 ; i < mTimes -> GetCount (); i ++ ) { if ( clearTimestamp <= ( * mTimes )[ i ] -> GetTimeStamp ()) { // clear after current time. int numberOfValuesToRemove = mTimes -> GetCount () - i ; mTimes -> RemoveTimeRange ( i , numberOfValuesToRemove ); for ( int j = numberOfValuesToRemove ; j >= 0 ; -- j ) mValues -> RemoveValue ({ j + i }); } } } void TimeBuffer :: ClearBefore ( shared_ptr < ITime > time ) { real clearTimestamp = ExtensionMethods :: Start ( time ) -> GetTimeStamp (); while ( ! mTimes -> GetTimes (). empty ()) { if ( mTimes -> GetTimes (). front () -> GetTimeStamp () < clearTimestamp ) { // Remove the expired time and values synchronously. mTimes -> RemoveTime ( 0 ); mValues -> RemoveValue ({ 0 }); } else { break ; } } } void TimeBuffer :: Reset () { mDoExtrapolate = true ; mRelaxationFactor = 0 ; mLastBufferSizeMessageCounter = 0 ; mDoExtendedDataVerification = false ; mValues . reset (); mTimes . reset (); } vector < vector < real >> TimeBuffer :: GetAllValues () { vector < vector < real >> returnValues ; for ( int i = 0 ; i < mValues -> GetIndexCount ({ 0 }); ++ i ) { vector < real > values ; for ( int j = 0 ; j < mValues -> GetIndexCount ({ 0 , i }); ++ j ) { values . push_back ( any_cast < real > ( mValues -> GetValue ({ i , j }))); } returnValues . push_back ( values ); } return returnValues ; } void TimeBuffer :: SetOrAddValues ( shared_ptr < ITime > time , vector < real > values ) { const auto & times = mTimes -> GetTimes (); const auto & iter = find_if ( begin ( times ), end ( times ), [ & time ]( const auto & t ) { return abs ( t -> GetTimeStamp () - time -> GetTimeStamp ()) <= Time :: EpsilonForTimeCompare ; }); int index = ( iter != times . end ()) ? -1 : distance ( begin ( times ), iter ); if ( index < 0 ) { AddValues ( time , values ); // add new time-values. } else { mValues -> SetOrAddValue ({ index }, values ); // set existed values. } } shared_ptr < TimeSet > TimeBuffer :: GetTimeSet () const { return mTimes ; } shared_ptr < ValueSet2D > TimeBuffer :: GetValueSet () const { return mValues ; } bool TimeBuffer :: GetDoExtendedDataVerification () const { return mDoExtendedDataVerification ; } void TimeBuffer :: SetDoExtendedDataVerification ( bool value ) { mDoExtendedDataVerification = value ; } } // namespace OpenOasis::CommImp::Temporal","title":"File TimeBuffer.cpp"},{"location":"models/_time_buffer_8cpp_source/#file-timebuffercpp","text":"File List > CommImp > Temporal > TimeBuffer.cpp Go to the documentation of this file #include \"TimeBuffer.h\" #include \"Models/CommImp/Time.h\" #include \"Models/CommImp/DevSupports/ExtensionMethods.h\" #include \"Models/Utils/Exception.h\" namespace OpenOasis :: CommImp :: Temporal { using namespace DevSupports ; using namespace Utils ; using namespace std ; TimeBuffer :: TimeBuffer () { SetDoExtrapolate ( true ); Create (); } TimeBuffer :: TimeBuffer ( const TimeBuffer & TimeBuffer ) { SetDoExtrapolate ( true ); Create (); } void TimeBuffer :: SetDoExtrapolate ( bool value ) { mDoExtrapolate = value ; } bool TimeBuffer :: GetDoExtrapolate () const { return mDoExtrapolate ; } void TimeBuffer :: Create () { mDoExtendedDataVerification = true ; mRelaxationFactor = 1.0 ; mTimes = make_shared < TimeSet > (); mValues = make_shared < ValueSet2D > (); } void TimeBuffer :: AddValues ( const shared_ptr < ITime > & time , const vector < real > & values ) { AddValuesToBuffer ( time , values ); } void TimeBuffer :: AddValuesToBuffer ( const shared_ptr < ITime > & time , const vector < real > & values ) { // Check if we can add the values if ( mTimes -> HasDurations ()) { if ( time -> GetDurationInDays () <= 0 ) { throw runtime_error ( \"Time without duration added to time set with durations.\" ); } // Order of times: The end time is allowed to overlap with at most // Time::EpsilonForTimeCompare with the new time. if ( mTimes -> GetTimes (). size () > 0 && time -> GetTimeStamp () + Time :: EpsilonForTimeCompare < ExtensionMethods :: EndTimeStamp ( mTimes -> GetTimeHorizon ())) { return ; // throw runtime_error(\"Overlapping times out of order times in time // buffer.\"); } } else { if ( time -> GetDurationInDays () > 0 ) { throw runtime_error ( \"Time with duration added to time set without durations.\" ); } // Order of times: There must at least be a difference of // Time.EpsilonForTimeCompare between two stamps. if ( mTimes -> GetCount () > 0 && time -> GetTimeStamp () - Time :: EpsilonForTimeCompare < mTimes -> GetTimeHorizon () -> GetTimeStamp ()) { return ; // throw runtime_error(\"Overlapping times out of order times in time // buffer.\"); } } mTimes -> AddTime ( make_shared < Time > ( time )); // save a copy of time for ( int i = 0 ; i < ( int ) values . size (); ++ i ) { mValues -> SetOrAddValue ({ mTimes -> GetCount () - 1 , i }, values [ i ]); } } real TimeBuffer :: GetRelaxationFactor () const { return mRelaxationFactor ; } void TimeBuffer :: SetRelaxationFactor ( real value ) { mRelaxationFactor = value ; if ( mRelaxationFactor < 0 || mRelaxationFactor > 1 ) { throw runtime_error ( \"ReleaxationFactor is out of range\" ); } } shared_ptr < ITime > TimeBuffer :: GetTimeAt ( int timeStep ) const { if ( mDoExtendedDataVerification ) { CheckBuffer (); } return ( * mTimes )[ timeStep ]; } void TimeBuffer :: CheckBuffer () const { if ( mTimes -> GetCount () != mValues -> GetIndexCount ({ 0 })) { throw runtime_error ( \"Different numbers of values and times in buffer\" ); } if ( mTimes -> GetCount () == 0 ) { throw runtime_error ( \"Buffer is empty\" ); } } vector < real > TimeBuffer :: GetValuesAt ( int timeStep ) const { if ( mDoExtendedDataVerification ) { CheckBuffer (); } vector < real > values ; for ( const auto & val : mValues -> GetElementValuesForTime ( timeStep )) { values . push_back ( any_cast < real > ( val )); } return values ; } vector < real > TimeBuffer :: GetValues ( const shared_ptr < ITime > & requestedTime ) { if ( mDoExtendedDataVerification ) { CheckBuffer (); } if ( ! mDoExtrapolate ) { if ( ExtensionMethods :: End ( requestedTime ) -> GetTimeStamp () > ExtensionMethods :: End ( mTimes -> GetTimeHorizon ()) -> GetTimeStamp () + Time :: EpsilonForTimeCompare || ExtensionMethods :: Start ( requestedTime ) -> GetTimeStamp () < ExtensionMethods :: Start ( mTimes -> GetTimeHorizon ()) -> GetTimeStamp () - Time :: EpsilonForTimeCompare ) { throw runtime_error ( \"Extrapolation not allowed for this buffer\" ); } } vector < real > returnValues ; if ( mValues -> GetIndexCount ({ 0 }) != 0 ) { if ( mTimes -> HasDurations () && requestedTime -> GetDurationInDays () > 0 ) { returnValues = MapFromTimeSpansToTimeSpan ( requestedTime ); } else if ( mTimes -> HasDurations () && requestedTime -> GetDurationInDays () <= Time :: EpsilonForTimeCompare ) { returnValues = MapFromTimeSpansToTimeStamp ( requestedTime ); } else if ( ! mTimes -> HasDurations () && requestedTime -> GetDurationInDays () > 0 ) { returnValues = MapFromTimeStampsToTimeSpan ( requestedTime ); } else // time stamps { returnValues = MapFromTimeStampsToTimeStamp ( requestedTime ); } } return returnValues ; } vector < real > TimeBuffer :: MapFromTimeStampsToTimeStamp ( const shared_ptr < ITime > & requestedTimeStamp ) { try { int elementCount = mValues -> GetIndexCount ({ 0 , 0 }); real tr = requestedTimeStamp -> GetTimeStamp (); // Requested TimeStamp vector < real > vr ( elementCount ); // Values to return const auto & times = mTimes -> GetTimes (); if ( times . size () == 1 ) { //------------------------------------------------------------------------- // Buffered TimesStamps:| >tb0< // Requested TimeStamp: | >tr< // or Requested TimeStamp: | >tr< // or Requested TimeStamp: | >tr< // -------------------------------------------> t // ------------------------------------------------------------------------ if ( tr > ( times . front () -> GetTimeStamp () + Time :: EpsilonForTimeCompare ) && ! mDoExtrapolate ) { throw runtime_error ( \"Extrapolation not allowed\" ); } for ( int i = 0 ; i < elementCount ; i ++ ) { vr [ i ] = any_cast < real > ( mValues -> GetValue ({ 0 , i })); } } else if ( tr <= times . front () -> GetTimeStamp ()) { //------------------------------------------------------------------------- // Buffered TimesStamps:| >tb0< >tb1< >tb2< >tbN< // Requested TimeStamp: | >tr< // ---------------------------------------------> t // ------------------------------------------------------------------------ real tb0 = times [ 0 ] -> GetTimeStamp (); real tb1 = times [ 1 ] -> GetTimeStamp (); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); real sbi1 = any_cast < real > ( mValues -> GetValue ({ i , i })); vr [ i ] = (( sbi0 - sbi1 ) / ( tb0 - tb1 )) * ( tr - tb0 ) * ( 1 - mRelaxationFactor ) + sbi0 ; } } else if ( tr > times . back () -> GetTimeStamp ()) { //------------------------------------------------------------------------- // Buffered TimesStamps:| >tb0< >tb1< >tb2< >tbN_2< >tbN_1< // Requested TimeStamp: | >tr< // ---------------------------------------------> t // ------------------------------------------------------------------------ int size = times . size (); real tbN_2 = times [ size - 2 ] -> GetTimeStamp (); real tbN_1 = times [ size - 1 ] -> GetTimeStamp (); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN_2 = any_cast < real > ( mValues -> GetValue ({ size - 2 , i })); real sbiN_1 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); vr [ i ] = (( sbiN_1 - sbiN_2 ) / ( tbN_1 - tbN_2 )) * ( tr - tbN_1 ) * ( 1 - mRelaxationFactor ) + sbiN_1 ; } } else { //------------------------------------------------------------------------- // Available TimesStamps: | >tb0< >tb1< >tbna< >tnb< >tbN_1< >tbN_2< // Requested TimeStamp: | >tr< // ---------------------------------------------> t // ------------------------------------------------------------------------ const auto & iter = find_if ( begin ( times ), end ( times ), [ & tr ]( const auto & t ) { return t -> GetTimeStamp () >= tr ; }); int iHigh = distance ( begin ( times ), iter ); real fraction = ( tr - times [ iHigh - 1 ] -> GetTimeStamp ()) / ( times [ iHigh ] -> GetTimeStamp () - times [ iHigh - 1 ] -> GetTimeStamp ()); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbinA = any_cast < real > ( mValues -> GetValue ({ iHigh - 1 , i })); real sbinB = any_cast < real > ( mValues -> GetValue ({ iHigh , i })); vr [ i ] = sbinA + fraction * ( sbinB - sbinA ); } } return vr ; } catch ( const runtime_error & e ) { throw runtime_error ( \"MapFromTimeStampsToTimeStamp Failed\" ); } } vector < real > TimeBuffer :: MapFromTimeSpansToTimeSpan ( const shared_ptr < ITime > & requestedTime ) { try { int elementCount = mValues -> GetIndexCount ({ 0 , 0 }); vector < real > vr ( elementCount ); // Values to return // Begin time in requester time interval real trb = requestedTime -> GetTimeStamp (); // End time in requester time interval real tre = requestedTime -> GetTimeStamp () + requestedTime -> GetDurationInDays (); // length of requested time interval real trl = tre - trb ; const auto & times = mTimes -> GetTimes (); int size = ( int ) times . size (); if ( times . empty ()) { throw runtime_error ( \"No times in buffer\" ); } real tbb0 = times [ 0 ] -> GetTimeStamp (); // In the following the current abbreviations are used: // B: Buffer time // R: Requested time // I: Time included by this part of the code if ( mDoExtrapolate ) { //------------------------------------------------------------------------- // B tbb0|-------tbe0|tbb1------|tbe1 // R+I trb|---|tre //------------------------------------------------------------------------- if ( tre <= tbb0 ) { if ( size >= 2 && mRelaxationFactor != 1 ) { // Linear interpolation real tbe0 = ExtensionMethods :: End ( times [ 0 ]) -> GetTimeStamp (); // real tbb1 = times[1]->GetTimeStamp(); real tbe1 = ExtensionMethods :: End ( times [ 1 ]) -> GetTimeStamp (); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); real sbi1 = any_cast < real > ( mValues -> GetValue ({ 1 , i })); vr [ i ] = sbi0 - ( 1 - mRelaxationFactor ) * ( sbi1 - sbi0 ) * ( tbe0 + tbb0 - tre - trb ) / ( tbe1 - tbb0 ); } } else { // Nearest value interpolation for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); vr [ i ] = sbi0 ; } } return vr ; } //------------------------------------------------------------------------- // B tbb0|--------|---------|--------| // R trb|----------------|tre // I |-----| //------------------------------------------------------------------------- if ( trb < tbb0 ) // && tre > tbb0 { real tbe0 = ExtensionMethods :: End ( times [ 0 ]) -> GetTimeStamp (); if ( size >= 2 && mRelaxationFactor != 1 ) { real tbe1 = ExtensionMethods :: End ( times [ 1 ]) -> GetTimeStamp (); // Linear interpolation, use tbb0 as \"endpoint\" of interval for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); real sbi1 = any_cast < real > ( mValues -> GetValue ({ 1 , i })); vr [ i ] += (( tbb0 - trb ) / trl ) * ( sbi0 - ( 1 - mRelaxationFactor ) * ( sbi1 - sbi0 ) * ( tbe0 - trb ) / ( tbe1 - tbb0 )); } } else { // Nearest value interpolation for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); vr [ i ] += sbi0 * ( tbb0 - trb ) / trl ; } } } real tbeN0 = ExtensionMethods :: End ( times . back ()) -> GetTimeStamp (); //-------------------------------------------------------------------------- // B tbb0|---?----|-------|tbeN0 // R+I trb|---|tre //-------------------------------------------------------------------------- if ( tbeN0 < trb ) { if ( size >= 2 && mRelaxationFactor != 1 ) { // Linear interpolation real tbeN1 = ExtensionMethods :: End ( times [ size - 2 ]) -> GetTimeStamp (); real tbbN1 = times [ size - 2 ] -> GetTimeStamp (); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN0 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); real sbiN1 = any_cast < real > ( mValues -> GetValue ({ size - 2 , i })); ; vr [ i ] = sbiN0 + ( 1 - mRelaxationFactor ) * ( sbiN0 - sbiN1 ) * ( trb + tre - tbeN0 - tbeN1 ) / ( tbeN0 - tbbN1 ); } } else { // Nearest value interpolation for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN0 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); vr [ i ] = sbiN0 ; } } return vr ; } //-------------------------------------------------------------------------- // B |---?----|-------|tbeN0 // R trb|-------|tre // I |---| //-------------------------------------------------------------------------- if ( tbeN0 < tre ) { if ( size >= 2 && mRelaxationFactor != 1 ) { real tbeN1 = ExtensionMethods :: End ( times [ size - 2 ]) -> GetTimeStamp (); real tbbN1 = times [ size - 2 ] -> GetTimeStamp (); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN0 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); real sbiN1 = any_cast < real > ( mValues -> GetValue ({ size - 2 , i })); vr [ i ] += (( tre - tbeN0 ) / ( tre - trb )) * ( sbiN0 + ( 1 - mRelaxationFactor ) * ( sbiN0 - sbiN1 ) * ( tre - tbeN1 ) / ( tbeN0 - tbbN1 )); } } else { for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN0 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); vr [ i ] += sbiN0 * (( tre - tbeN0 ) / ( tre - trb )); } } } } int nstart = 0 ; int nend = size - 1 ; // Narrow down the number of spans to investigate, based on the requested span. if ( nend > 10 ) { // Assuming 4 spans in the buffer, use end-time in GetIntrval // will provide the right indices // spans |-0-|-1-|-2-|-3-| // endStamp intervals 0 | 1 | 2 | 3 | 4 const auto & iter1 = find_if ( begin ( times ), end ( times ), [ & trb ]( const auto & t ) { return t -> GetTimeStamp () >= trb ; }); nstart = distance ( begin ( times ), iter1 ); const auto & iter2 = find_if ( begin ( times ), end ( times ), [ & tre ]( const auto & t ) { return ExtensionMethods :: End ( t ) -> GetTimeStamp () >= tre ; }); nend = distance ( begin ( times ), iter2 ); nend = min ( nend , size - 1 ); } for ( int n = nstart ; n <= nend ; n ++ ) { real tbbn = times [ n ] -> GetTimeStamp (); real tben = ExtensionMethods :: End ( times [ n ]) -> GetTimeStamp (); //--------------------------------------------------------------------------- // B: tbbn|--------------------------|tben // R: trb|-------------------------------------|tre // I: |--------------------------| //--------------------------------------------------------------------------- if ( trb <= tbbn && tre >= tben ) { for ( int i = 0 ; i < elementCount ; i ++ ) { real sbin = any_cast < real > ( mValues -> GetValue ({ n , i })); vr [ i ] += sbin * ( tben - tbbn ) / ( tre - trb ); } } //--------------------------------------------------------------------------- // B: tbbn|-----------------------|tben // R+I: trb|--------------|tre // -------------------------------------------------------------------------- else if ( tbbn <= trb && tre <= tben ) // cover all { for ( int i = 0 ; i < elementCount ; i ++ ) { vr [ i ] += any_cast < real > ( mValues -> GetValue ({ n , i })); } } //--------------------------------------------------------------------------- // B: tbbn|-----------------|tben // R: trb|--------------|tre // I: |------| // -------------------------------------------------------------------------- else if ( tbbn < trb && trb < tben && tre > tben ) { for ( int i = 0 ; i < elementCount ; i ++ ) { real sbin = any_cast < real > ( mValues -> GetValue ({ n , i })); vr [ i ] += sbin * ( tben - trb ) / ( tre - trb ); } } //--------------------------------------------------------------------------- // B: tbbn|-----------------|tben // R: trb|--------------|tre // I: |--------| // -------------------------------------------------------------------------- else if ( trb < tbbn && tre > tbbn && tre < tben ) { for ( int i = 0 ; i < elementCount ; i ++ ) { real sbin = any_cast < real > ( mValues -> GetValue ({ n , i })); vr [ i ] += sbin * ( tre - tbbn ) / ( tre - trb ); } } } return vr ; } catch ( const runtime_error & e ) { throw runtime_error ( \"MapFromTimeSpansToTimeSpan Failed\" ); } } vector < real > TimeBuffer :: MapFromTimeStampsToTimeSpan ( const shared_ptr < ITime > & requestedTime ) { try { int elementCount = mValues -> GetIndexCount ({ 0 , 0 }); vector < real > vr ( elementCount ); // Values to return // Begin time in requester time interval real trb = requestedTime -> GetTimeStamp (); // End time in requester time interval real tre = requestedTime -> GetTimeStamp () + requestedTime -> GetDurationInDays (); // length of requested time interval // real trl = tre - trb; const auto & times = mTimes -> GetTimes (); int size = ( int ) times . size (); //----------------------------------------------------------------------------- // This handles values within the time horizon of the buffer, i.e. // there must be at least two values in the buffer. int nstart = 1 ; int nend = size - 1 ; // Narrow down the number of intervals to investigate, // based on the requested span. if ( nend > 4 ) { const auto & iter1 = find_if ( begin ( times ), end ( times ), [ & trb ]( const auto & t ) { return t -> GetTimeStamp () >= trb ; }); nstart = distance ( begin ( times ), iter1 ); nstart = max ( nstart , 1 ); const auto & iter2 = find_if ( begin ( times ), end ( times ), [ & tre ]( const auto & t ) { return ExtensionMethods :: End ( t ) -> GetTimeStamp () >= tre ; }); nend = distance ( begin ( times ), iter2 ); nend = min ( nend , size - 1 ); } // n corresponds to the n'th interval between the time stamps. for ( int n = nstart ; n <= nend ; n ++ ) { real tbn = times [ n - 1 ] -> GetTimeStamp (); real tbnp1 = times [ n ] -> GetTimeStamp (); //------------------------------------------------------------------------- // B: tbn|--------------------------|tbnp1 // R: trb|-------------------------------------|tre // I: |--------------------------| // ------------------------------------------------------------------------ if ( trb <= tbn && tre >= tbnp1 ) { real factor = ( tbnp1 - tbn ) / ( tre - trb ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbin = any_cast < real > ( mValues -> GetValue ({ n - 1 , i })); real sbinp1 = any_cast < real > ( mValues -> GetValue ({ n , i })); vr [ i ] += 0.5 * ( sbin + sbinp1 ) * factor ; } } //------------------------------------------------------------------------- // B: tbn|-----------------------|tbnp1 // R+I: trb|--------------|tre // ------------------------------------------------------------------------ else if ( tbn <= trb && tre <= tbnp1 ) // cover all { real fraction = (( tre + trb ) / 2 - tbn ) / ( tbnp1 - tbn ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbin = any_cast < real > ( mValues -> GetValue ({ n - 1 , i })); real sbinp1 = any_cast < real > ( mValues -> GetValue ({ n , i })); vr [ i ] += sbin + ( sbinp1 - sbin ) * fraction ; } } //------------------------------------------------------------------------- // B: tbn|-----------------|tbnp1 // R: trb|--------------|tre // I: |------| // ------------------------------------------------------------------------ else if ( tbn < trb && trb < tbnp1 && tre > tbnp1 ) { real fraction = (( tbnp1 - trb ) / 2 ) / ( tbnp1 - tbn ); real factor = ( tbnp1 - trb ) / ( tre - trb ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbin = any_cast < real > ( mValues -> GetValue ({ n - 1 , i })); real sbinp1 = any_cast < real > ( mValues -> GetValue ({ n , i })); vr [ i ] += ( sbinp1 - ( sbinp1 - sbin ) * fraction ) * factor ; } } //------------------------------------------------------------------------- // B: tbn|-----------------|tbnp1 // R: trb|--------------|tre // I: |--------| // ------------------------------------------------------------------------ else if ( trb < tbn && tre > tbn && tre < tbnp1 ) { real fraction = (( tre - tbn ) / 2 ) / ( tbnp1 - tbn ); real factor = ( tre - tbn ) / ( tre - trb ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbin = any_cast < real > ( mValues -> GetValue ({ n - 1 , i })); real sbinp1 = any_cast < real > ( mValues -> GetValue ({ n , i })); vr [ i ] += ( sbin + ( sbinp1 - sbin ) * fraction ) * factor ; } } } //----------------------------------------------------------------------------- // This handles values outside the time horizon of the buffer. //----------------------------------------------------------------------------- // In case of only one value in the buffer, regardless of its position relative // to R // | or | or | B // |----------------| R //----------------------------------------------------------------------------- if ( size == 1 ) { // TODO: Test if extrapolation is ok. for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); vr [ i ] = sbi0 ; } } else { // At least two stamp values in the buffer, so we can do extrapolation //------------------------------------------------------------------------- // B: tb0|-----tb1|---------|--------| // R: trb|----------------|tre // I: |-----| //------------------------------------------------------------------------- real tb0 = times [ 0 ] -> GetTimeStamp (); real tb1 = times [ 1 ] -> GetTimeStamp (); real tbN_1 = times [ size - 1 ] -> GetTimeStamp (); real tbN_2 = times [ size - 2 ] -> GetTimeStamp (); if ( trb < tb0 && tre > tb0 ) { real fraction = ( 1 - mRelaxationFactor ) * 0.5 * ( tb0 - trb ) / ( tb1 - tb0 ); real factor = (( tb0 - trb ) / ( tre - trb )); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); real sbi1 = any_cast < real > ( mValues -> GetValue ({ 1 , i })); vr [ i ] += factor * ( sbi0 - fraction * ( sbi1 - sbi0 )); } } //------------------------------------------------------------------------- // B |--------|---------|tbn_2---|tbn_1 // R trb|----------------|tre // I |----------| //------------------------------------------------------------------------- if ( tre > tbN_1 && trb < tbN_1 ) { real factor = (( tre - tbN_1 ) / ( tre - trb )); real fraction = ( 1 - mRelaxationFactor ) * 0.5 * ( tre - tbN_1 ) / ( tbN_1 - tbN_2 ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN_1 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); real sbiN_2 = any_cast < real > ( mValues -> GetValue ({ size - 2 , i })); vr [ i ] += factor * ( sbiN_1 + fraction * ( sbiN_1 - sbiN_2 )); } } //------------------------------------------------------------------------- // B : |--------|---------|tbn_2---|tbn_1 // R+I : trb|----------------|tre //------------------------------------------------------------------------- if ( trb >= tbN_1 ) { real fraction = ( 1 - mRelaxationFactor ) * ( 0.5 * ( trb + tre ) - tbN_1 ) / ( tbN_1 - tbN_2 ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN_1 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); real sbiN_2 = any_cast < real > ( mValues -> GetValue ({ size - 2 , i })); vr [ i ] = sbiN_1 + ( sbiN_1 - sbiN_2 ) * fraction ; } } //------------------------------------------------------------------------- // B : tb0|-----tb1|---------|--------| B // R+I : trb|-------|tre //------------------------------------------------------------------------- if ( tre <= tb0 ) { real fraction = ( 1 - mRelaxationFactor ) / ( tb1 - tb0 ) * ( tb0 - 0.5 * ( trb + tre )); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); real sbi1 = any_cast < real > ( mValues -> GetValue ({ 1 , i })); vr [ i ] = sbi0 - ( sbi1 - sbi0 ) * fraction ; } } } return vr ; } catch ( const runtime_error & e ) { throw runtime_error ( \"MapFromTimeStampsToTimeSpan Failed\" ); } } vector < real > TimeBuffer :: MapFromTimeSpansToTimeStamp ( const shared_ptr < ITime > & requestedTimeStamp ) { try { int elementCount = mValues -> GetIndexCount ({ 0 , 0 }); vector < real > vr ( elementCount ); // Values to return const auto & times = mTimes -> GetTimes (); int size = ( int ) times . size (); real tr = requestedTimeStamp -> GetTimeStamp (); // Requested TimeStamp if ( size == 1 ) { //------------------------------------------------------------------------- // Buffered TimesSpans: | |------| // Requested TimeStamp: | >tr< // or Requested TimeStamp: | >tr< // or Requested TimeStamp: | >tr< // -----------------------------------------> t // ------------------------------------------------------------------------ // Check if tr is inside span if ( ! mDoExtrapolate ) { if ( times [ 0 ] -> GetTimeStamp () - Time :: EpsilonForTimeCompare > tr || tr > ExtensionMethods :: End ( times . back ()) -> GetTimeStamp () + Time :: EpsilonForTimeCompare ) { throw runtime_error ( \"Extrapolation not allowed\" ); } } for ( int i = 0 ; i < elementCount ; i ++ ) // For each element { vr [ i ] = any_cast < real > ( mValues -> GetValue ({ 0 , i })); } } //----------------------------------------------------------------------------- // Buffered TimesSpans: | >tbb0< .......... >tbbN< // Requested TimeStamp: | >tr< // -----------------------------------------> t // ---------------------------------------------------------------------------- else if ( tr <= times [ 0 ] -> GetTimeStamp ()) { // Check if we are allowed to extrapolate if ( ! mDoExtrapolate ) { if ( tr < times [ 0 ] -> GetTimeStamp () - Time :: EpsilonForTimeCompare ) { throw runtime_error ( \"Extrapolation not allowed\" ); } // Very close to the first point, just provide that value for ( int i = 0 ; i < elementCount ; i ++ ) // For each element { vr [ i ] = any_cast < real > ( mValues -> GetValue ({ 0 , i })); } } else { // Extrapolate from the first two values real tbb0 = times [ 0 ] -> GetTimeStamp (); real tbb1 = times [ 1 ] -> GetTimeStamp (); real fraction = ( tr - tbb0 ) / ( tbb0 - tbb1 ) * ( 1 - mRelaxationFactor ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbi0 = any_cast < real > ( mValues -> GetValue ({ 0 , i })); real sbi1 = any_cast < real > ( mValues -> GetValue ({ 1 , i })); vr [ i ] = ( sbi0 - sbi1 ) * fraction + sbi0 ; } } } //----------------------------------------------------------------------------- // Buffered TimesSpans: | >tbb0< ................. >tbbN_1< // Requested TimeStamp: | >tr< // -------------------------------------------------> t // ---------------------------------------------------------------------------- else if ( tr >= ExtensionMethods :: End ( times . back ()) -> GetTimeStamp ()) { // Check if we are allowed to extrapolate if ( ! mDoExtrapolate ) { if ( tr > times . back () -> GetTimeStamp () + Time :: EpsilonForTimeCompare ) { throw runtime_error ( \"Extrapolation not allowed\" ); } // Very close to the last point, just provide that value for ( int i = 0 ; i < elementCount ; i ++ ) { vr [ i ] = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); } } else { // Extrapolate from the last two values real tbeN_2 = ExtensionMethods :: End ( times [ size - 2 ]) -> GetTimeStamp (); real tbeN_1 = ExtensionMethods :: End ( times [ size - 1 ]) -> GetTimeStamp (); real fraction = ( tr - tbeN_1 ) / ( tbeN_1 - tbeN_2 ) * ( 1 - mRelaxationFactor ); for ( int i = 0 ; i < elementCount ; i ++ ) { real sbiN_2 = any_cast < real > ( mValues -> GetValue ({ size - 2 , i })); real sbiN_1 = any_cast < real > ( mValues -> GetValue ({ size - 1 , i })); vr [ i ] = ( sbiN_1 - sbiN_2 ) * fraction + sbiN_1 ; } } } //----------------------------------------------------------------------------- // Availeble TimesSpans: | >tbb0< ...................... >tbbN_1< // Requested TimeStamp: | >tr< // -------------------------------------------------> t // ---------------------------------------------------------------------------- else { // Using end-time will provide the right indices // Example: assuming 4 spans in the buffer, // spans |-0-|-1-|-2-|-3-| // endStamp intervals 0 | 1 | 2 | 3 | 4 const auto & iter = find_if ( begin ( times ), end ( times ), [ tr ]( const auto & t ) { return t -> GetTimeStamp () <= tr && t -> GetTimeStamp () + t -> GetDurationInDays () >= tr ; }); int interval = distance ( begin ( times ), iter ); for ( int i = 0 ; i < elementCount ; i ++ ) { vr [ i ] = any_cast < real > ( mValues -> GetValue ({ interval , i })); } } return vr ; } catch ( const runtime_error & e ) { throw runtime_error ( \"MapFromTimeSpansToTimeStamp Failed\" ); } } int TimeBuffer :: GetTimesCount () const { return mTimes -> GetCount (); } int TimeBuffer :: GetValuesCount () const { return mValues -> GetIndexCount ({ 0 , 0 }); } void TimeBuffer :: ClearAfter ( shared_ptr < ITime > time ) { real clearTimestamp = ExtensionMethods :: Start ( time ) -> GetTimeStamp (); for ( int i = 0 ; i < mTimes -> GetCount (); i ++ ) { if ( clearTimestamp <= ( * mTimes )[ i ] -> GetTimeStamp ()) { // clear after current time. int numberOfValuesToRemove = mTimes -> GetCount () - i ; mTimes -> RemoveTimeRange ( i , numberOfValuesToRemove ); for ( int j = numberOfValuesToRemove ; j >= 0 ; -- j ) mValues -> RemoveValue ({ j + i }); } } } void TimeBuffer :: ClearBefore ( shared_ptr < ITime > time ) { real clearTimestamp = ExtensionMethods :: Start ( time ) -> GetTimeStamp (); while ( ! mTimes -> GetTimes (). empty ()) { if ( mTimes -> GetTimes (). front () -> GetTimeStamp () < clearTimestamp ) { // Remove the expired time and values synchronously. mTimes -> RemoveTime ( 0 ); mValues -> RemoveValue ({ 0 }); } else { break ; } } } void TimeBuffer :: Reset () { mDoExtrapolate = true ; mRelaxationFactor = 0 ; mLastBufferSizeMessageCounter = 0 ; mDoExtendedDataVerification = false ; mValues . reset (); mTimes . reset (); } vector < vector < real >> TimeBuffer :: GetAllValues () { vector < vector < real >> returnValues ; for ( int i = 0 ; i < mValues -> GetIndexCount ({ 0 }); ++ i ) { vector < real > values ; for ( int j = 0 ; j < mValues -> GetIndexCount ({ 0 , i }); ++ j ) { values . push_back ( any_cast < real > ( mValues -> GetValue ({ i , j }))); } returnValues . push_back ( values ); } return returnValues ; } void TimeBuffer :: SetOrAddValues ( shared_ptr < ITime > time , vector < real > values ) { const auto & times = mTimes -> GetTimes (); const auto & iter = find_if ( begin ( times ), end ( times ), [ & time ]( const auto & t ) { return abs ( t -> GetTimeStamp () - time -> GetTimeStamp ()) <= Time :: EpsilonForTimeCompare ; }); int index = ( iter != times . end ()) ? -1 : distance ( begin ( times ), iter ); if ( index < 0 ) { AddValues ( time , values ); // add new time-values. } else { mValues -> SetOrAddValue ({ index }, values ); // set existed values. } } shared_ptr < TimeSet > TimeBuffer :: GetTimeSet () const { return mTimes ; } shared_ptr < ValueSet2D > TimeBuffer :: GetValueSet () const { return mValues ; } bool TimeBuffer :: GetDoExtendedDataVerification () const { return mDoExtendedDataVerification ; } void TimeBuffer :: SetDoExtendedDataVerification ( bool value ) { mDoExtendedDataVerification = value ; } } // namespace OpenOasis::CommImp::Temporal","title":"File TimeBuffer.cpp"},{"location":"models/_time_buffer_8h/","text":"File TimeBuffer.h \u00b6 FileList > CommImp > Temporal > TimeBuffer.h Go to the source code of this file #include \"Models/CommImp/TimeSet.h\" #include \"Models/CommImp/ValueSet2D.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace CommImp namespace Temporal Classes \u00b6 Type Name class TimeBuffer The TimeBuffer class provides temporal buffering functionality. The documentation for this class was generated from the following file Models/CommImp/Temporal/TimeBuffer.h","title":"File TimeBuffer.h"},{"location":"models/_time_buffer_8h/#file-timebufferh","text":"FileList > CommImp > Temporal > TimeBuffer.h Go to the source code of this file #include \"Models/CommImp/TimeSet.h\" #include \"Models/CommImp/ValueSet2D.h\"","title":"File TimeBuffer.h"},{"location":"models/_time_buffer_8h/#namespaces","text":"Type Name namespace OpenOasis namespace CommImp namespace Temporal","title":"Namespaces"},{"location":"models/_time_buffer_8h/#classes","text":"Type Name class TimeBuffer The TimeBuffer class provides temporal buffering functionality. The documentation for this class was generated from the following file Models/CommImp/Temporal/TimeBuffer.h","title":"Classes"},{"location":"models/_time_buffer_8h_source/","text":"File TimeBuffer.h \u00b6 File List > CommImp > Temporal > TimeBuffer.h Go to the documentation of this file #pragma once #include \"Models/CommImp/TimeSet.h\" #include \"Models/CommImp/ValueSet2D.h\" namespace OpenOasis { namespace CommImp { namespace Temporal { using Utils :: real ; class TimeBuffer { protected : bool mDoExtrapolate = true ; std :: shared_ptr < ValueSet2D > mValues = nullptr ; std :: shared_ptr < TimeSet > mTimes = nullptr ; real mRelaxationFactor = 0 ; int mLastBufferSizeMessageCounter = 0 ; bool mDoExtendedDataVerification = false ; public : virtual ~ TimeBuffer () {} TimeBuffer (); TimeBuffer ( const TimeBuffer & TimeBuffer ); // Methods for getting and setting the buffer extrapolation flag. // // Default is true. If false and a requested time is outside the available spans, // an exception is thrown. void SetDoExtrapolate ( bool value ); bool GetDoExtrapolate () const ; void AddValues ( const std :: shared_ptr < ITime > & time , const std :: vector < real > & values ); // Methods for getting and setting the relaxation factor(must be in [0, 1]). // // Relaxation parameter is used when doing extrapolation. // A value of 1 results in nearest extrapolation whereas // a value 0 results in linear extrapolation. std :: vector < real > GetValues ( const std :: shared_ptr < ITime > & requestedTime ); void SetRelaxationFactor ( real value ); real GetRelaxationFactor () const ; std :: shared_ptr < ITime > GetTimeAt ( int timeStep ) const ; std :: vector < real > GetValuesAt ( int timeStep ) const ; std :: shared_ptr < TimeSet > GetTimeSet () const ; std :: shared_ptr < ValueSet2D > GetValueSet () const ; // Methods for getting and setting the data extension flag. // bool GetDoExtendedDataVerification () const ; void SetDoExtendedDataVerification ( bool value ); void CheckBuffer () const ; void ClearBefore ( std :: shared_ptr < ITime > time ); void ClearAfter ( std :: shared_ptr < ITime > time ); void Reset (); std :: vector < std :: vector < real >> GetAllValues (); void SetOrAddValues ( std :: shared_ptr < ITime > time , std :: vector < real > values ); int GetTimesCount () const ; int GetValuesCount () const ; protected : void AddValuesToBuffer ( const std :: shared_ptr < ITime > & time , const std :: vector < real > & values ); void Create (); std :: vector < real > MapFromTimeStampsToTimeSpan ( const std :: shared_ptr < ITime > & requestedTime ); std :: vector < real > MapFromTimeSpansToTimeStamp ( const std :: shared_ptr < ITime > & requestedTimeStamp ); std :: vector < real > MapFromTimeSpansToTimeSpan ( const std :: shared_ptr < ITime > & requestedTime ); std :: vector < real > MapFromTimeStampsToTimeStamp ( const std :: shared_ptr < ITime > & requestedTimeStamp ); }; } // namespace Temporal } // namespace CommImp } // namespace OpenOasis","title":"File TimeBuffer.h"},{"location":"models/_time_buffer_8h_source/#file-timebufferh","text":"File List > CommImp > Temporal > TimeBuffer.h Go to the documentation of this file #pragma once #include \"Models/CommImp/TimeSet.h\" #include \"Models/CommImp/ValueSet2D.h\" namespace OpenOasis { namespace CommImp { namespace Temporal { using Utils :: real ; class TimeBuffer { protected : bool mDoExtrapolate = true ; std :: shared_ptr < ValueSet2D > mValues = nullptr ; std :: shared_ptr < TimeSet > mTimes = nullptr ; real mRelaxationFactor = 0 ; int mLastBufferSizeMessageCounter = 0 ; bool mDoExtendedDataVerification = false ; public : virtual ~ TimeBuffer () {} TimeBuffer (); TimeBuffer ( const TimeBuffer & TimeBuffer ); // Methods for getting and setting the buffer extrapolation flag. // // Default is true. If false and a requested time is outside the available spans, // an exception is thrown. void SetDoExtrapolate ( bool value ); bool GetDoExtrapolate () const ; void AddValues ( const std :: shared_ptr < ITime > & time , const std :: vector < real > & values ); // Methods for getting and setting the relaxation factor(must be in [0, 1]). // // Relaxation parameter is used when doing extrapolation. // A value of 1 results in nearest extrapolation whereas // a value 0 results in linear extrapolation. std :: vector < real > GetValues ( const std :: shared_ptr < ITime > & requestedTime ); void SetRelaxationFactor ( real value ); real GetRelaxationFactor () const ; std :: shared_ptr < ITime > GetTimeAt ( int timeStep ) const ; std :: vector < real > GetValuesAt ( int timeStep ) const ; std :: shared_ptr < TimeSet > GetTimeSet () const ; std :: shared_ptr < ValueSet2D > GetValueSet () const ; // Methods for getting and setting the data extension flag. // bool GetDoExtendedDataVerification () const ; void SetDoExtendedDataVerification ( bool value ); void CheckBuffer () const ; void ClearBefore ( std :: shared_ptr < ITime > time ); void ClearAfter ( std :: shared_ptr < ITime > time ); void Reset (); std :: vector < std :: vector < real >> GetAllValues (); void SetOrAddValues ( std :: shared_ptr < ITime > time , std :: vector < real > values ); int GetTimesCount () const ; int GetValuesCount () const ; protected : void AddValuesToBuffer ( const std :: shared_ptr < ITime > & time , const std :: vector < real > & values ); void Create (); std :: vector < real > MapFromTimeStampsToTimeSpan ( const std :: shared_ptr < ITime > & requestedTime ); std :: vector < real > MapFromTimeSpansToTimeStamp ( const std :: shared_ptr < ITime > & requestedTimeStamp ); std :: vector < real > MapFromTimeSpansToTimeSpan ( const std :: shared_ptr < ITime > & requestedTime ); std :: vector < real > MapFromTimeStampsToTimeStamp ( const std :: shared_ptr < ITime > & requestedTimeStamp ); }; } // namespace Temporal } // namespace CommImp } // namespace OpenOasis","title":"File TimeBuffer.h"},{"location":"models/dir_e48a3e9a07fc2444cdac51c67822643f/","text":"Dir Models/Inc \u00b6 FileList > Inc Files \u00b6 Type Name file ExchangeItemChangeEventArgs.h file IAdaptedOutput.h file IAdaptedOutputFactory.h file IArgument.h file IBaseExchangeItem.h file IByteStateConverter.h file ICategory.h file IDescribable.h file IDimension.h file IElementSet.h file IIdentifiable.h file IInput.h file ILinkableComponent.h file IManageState.h file IOutput.h file IQuality.h file IQuantity.h file ISpatialDefinition.h file ITime.h file ITimeSet.h file IUnit.h file IValueDefinition.h file IValueSet.h file LinkableComponentStatus.h file LinkableComponentStatusChangeEventArgs.h Directories \u00b6 Type Name dir AdditionalControl The documentation for this class was generated from the following file Models/Inc/","title":"Dir Models/Inc"},{"location":"models/dir_e48a3e9a07fc2444cdac51c67822643f/#dir-modelsinc","text":"FileList > Inc","title":"Dir Models/Inc"},{"location":"models/dir_e48a3e9a07fc2444cdac51c67822643f/#files","text":"Type Name file ExchangeItemChangeEventArgs.h file IAdaptedOutput.h file IAdaptedOutputFactory.h file IArgument.h file IBaseExchangeItem.h file IByteStateConverter.h file ICategory.h file IDescribable.h file IDimension.h file IElementSet.h file IIdentifiable.h file IInput.h file ILinkableComponent.h file IManageState.h file IOutput.h file IQuality.h file IQuantity.h file ISpatialDefinition.h file ITime.h file ITimeSet.h file IUnit.h file IValueDefinition.h file IValueSet.h file LinkableComponentStatus.h file LinkableComponentStatusChangeEventArgs.h","title":"Files"},{"location":"models/dir_e48a3e9a07fc2444cdac51c67822643f/#directories","text":"Type Name dir AdditionalControl The documentation for this class was generated from the following file Models/Inc/","title":"Directories"},{"location":"models/_exchange_item_change_event_args_8h/","text":"File ExchangeItemChangeEventArgs.h \u00b6 FileList > Inc > ExchangeItemChangeEventArgs.h Go to the source code of this file #include <memory> #include <string> Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class ExchangeItemChangeEventArgs Class containing the information that will be passed when firing an ExchangeItemValueChanged event. The documentation for this class was generated from the following file Models/Inc/ExchangeItemChangeEventArgs.h","title":"File ExchangeItemChangeEventArgs.h"},{"location":"models/_exchange_item_change_event_args_8h/#file-exchangeitemchangeeventargsh","text":"FileList > Inc > ExchangeItemChangeEventArgs.h Go to the source code of this file #include <memory> #include <string>","title":"File ExchangeItemChangeEventArgs.h"},{"location":"models/_exchange_item_change_event_args_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_exchange_item_change_event_args_8h/#classes","text":"Type Name class ExchangeItemChangeEventArgs Class containing the information that will be passed when firing an ExchangeItemValueChanged event. The documentation for this class was generated from the following file Models/Inc/ExchangeItemChangeEventArgs.h","title":"Classes"},{"location":"models/_exchange_item_change_event_args_8h_source/","text":"File ExchangeItemChangeEventArgs.h \u00b6 File List > Inc > ExchangeItemChangeEventArgs.h Go to the documentation of this file #pragma once #include <memory> #include <string> namespace OpenOasis { class IBaseExchangeItem ; class ExchangeItemChangeEventArgs { public : // To deal with the exchange item of which the status has been changed. // virtual std :: shared_ptr < IBaseExchangeItem > GetExchangeItem () const = 0 ; virtual void SetExchangeItem ( std :: shared_ptr < IBaseExchangeItem > obj ) = 0 ; // To deal with the message that describes the way in which the status // of the exchange item has been changed. // virtual std :: string GetMessages () const = 0 ; virtual void SetMessages ( const std :: string & value ) = 0 ; }; } // namespace OpenOasis","title":"File ExchangeItemChangeEventArgs.h"},{"location":"models/_exchange_item_change_event_args_8h_source/#file-exchangeitemchangeeventargsh","text":"File List > Inc > ExchangeItemChangeEventArgs.h Go to the documentation of this file #pragma once #include <memory> #include <string> namespace OpenOasis { class IBaseExchangeItem ; class ExchangeItemChangeEventArgs { public : // To deal with the exchange item of which the status has been changed. // virtual std :: shared_ptr < IBaseExchangeItem > GetExchangeItem () const = 0 ; virtual void SetExchangeItem ( std :: shared_ptr < IBaseExchangeItem > obj ) = 0 ; // To deal with the message that describes the way in which the status // of the exchange item has been changed. // virtual std :: string GetMessages () const = 0 ; virtual void SetMessages ( const std :: string & value ) = 0 ; }; } // namespace OpenOasis","title":"File ExchangeItemChangeEventArgs.h"},{"location":"models/_i_adapted_output_8h/","text":"File IAdaptedOutput.h \u00b6 FileList > Inc > IAdaptedOutput.h Go to the source code of this file #include \"IArgument.h\" #include \"IOutput.h\" Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IAdaptedOutput Extension class for adding data operations on top of an output item. The documentation for this class was generated from the following file Models/Inc/IAdaptedOutput.h","title":"File IAdaptedOutput.h"},{"location":"models/_i_adapted_output_8h/#file-iadaptedoutputh","text":"FileList > Inc > IAdaptedOutput.h Go to the source code of this file #include \"IArgument.h\" #include \"IOutput.h\"","title":"File IAdaptedOutput.h"},{"location":"models/_i_adapted_output_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_adapted_output_8h/#classes","text":"Type Name class IAdaptedOutput Extension class for adding data operations on top of an output item. The documentation for this class was generated from the following file Models/Inc/IAdaptedOutput.h","title":"Classes"},{"location":"models/_i_adapted_output_8h_source/","text":"File IAdaptedOutput.h \u00b6 File List > Inc > IAdaptedOutput.h Go to the documentation of this file #pragma once #include \"IArgument.h\" #include \"IOutput.h\" namespace OpenOasis { class IAdaptedOutput : public IOutput { public : virtual std :: vector < std :: shared_ptr < IArgument >> GetArguments () const = 0 ; virtual void Initialize () = 0 ; virtual std :: weak_ptr < IOutput > GetAdaptee () const = 0 ; virtual void SetAdaptee ( std :: shared_ptr < IOutput > adaptee ) = 0 ; virtual void Refresh () = 0 ; }; } // namespace OpenOasis","title":"File IAdaptedOutput.h"},{"location":"models/_i_adapted_output_8h_source/#file-iadaptedoutputh","text":"File List > Inc > IAdaptedOutput.h Go to the documentation of this file #pragma once #include \"IArgument.h\" #include \"IOutput.h\" namespace OpenOasis { class IAdaptedOutput : public IOutput { public : virtual std :: vector < std :: shared_ptr < IArgument >> GetArguments () const = 0 ; virtual void Initialize () = 0 ; virtual std :: weak_ptr < IOutput > GetAdaptee () const = 0 ; virtual void SetAdaptee ( std :: shared_ptr < IOutput > adaptee ) = 0 ; virtual void Refresh () = 0 ; }; } // namespace OpenOasis","title":"File IAdaptedOutput.h"},{"location":"models/_i_adapted_output_factory_8h/","text":"File IAdaptedOutputFactory.h \u00b6 FileList > Inc > IAdaptedOutputFactory.h Go to the source code of this file #include \"IAdaptedOutput.h\" #include \"IOutput.h\" Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IAdaptedOutputFactory Factory class for creating instances of IAdaptedOutput items. The documentation for this class was generated from the following file Models/Inc/IAdaptedOutputFactory.h","title":"File IAdaptedOutputFactory.h"},{"location":"models/_i_adapted_output_factory_8h/#file-iadaptedoutputfactoryh","text":"FileList > Inc > IAdaptedOutputFactory.h Go to the source code of this file #include \"IAdaptedOutput.h\" #include \"IOutput.h\"","title":"File IAdaptedOutputFactory.h"},{"location":"models/_i_adapted_output_factory_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_adapted_output_factory_8h/#classes","text":"Type Name class IAdaptedOutputFactory Factory class for creating instances of IAdaptedOutput items. The documentation for this class was generated from the following file Models/Inc/IAdaptedOutputFactory.h","title":"Classes"},{"location":"models/_i_adapted_output_factory_8h_source/","text":"File IAdaptedOutputFactory.h \u00b6 File List > Inc > IAdaptedOutputFactory.h Go to the documentation of this file #pragma once #include \"IAdaptedOutput.h\" #include \"IOutput.h\" namespace OpenOasis { class IAdaptedOutputFactory : public IIdentifiable { public : virtual std :: vector < std :: shared_ptr < IIdentifiable >> GetAvailableAdaptedOutputIds ( const std :: shared_ptr < IOutput > & adaptee , const std :: shared_ptr < IInput > & target ) = 0 ; virtual std :: shared_ptr < IAdaptedOutput > CreateAdaptedOutput ( const std :: shared_ptr < IIdentifiable > & adaptedOutputId , const std :: shared_ptr < IOutput > & adaptee , const std :: shared_ptr < IInput > & target ) = 0 ; }; } // namespace OpenOasis","title":"File IAdaptedOutputFactory.h"},{"location":"models/_i_adapted_output_factory_8h_source/#file-iadaptedoutputfactoryh","text":"File List > Inc > IAdaptedOutputFactory.h Go to the documentation of this file #pragma once #include \"IAdaptedOutput.h\" #include \"IOutput.h\" namespace OpenOasis { class IAdaptedOutputFactory : public IIdentifiable { public : virtual std :: vector < std :: shared_ptr < IIdentifiable >> GetAvailableAdaptedOutputIds ( const std :: shared_ptr < IOutput > & adaptee , const std :: shared_ptr < IInput > & target ) = 0 ; virtual std :: shared_ptr < IAdaptedOutput > CreateAdaptedOutput ( const std :: shared_ptr < IIdentifiable > & adaptedOutputId , const std :: shared_ptr < IOutput > & adaptee , const std :: shared_ptr < IInput > & target ) = 0 ; }; } // namespace OpenOasis","title":"File IAdaptedOutputFactory.h"},{"location":"models/_i_argument_8h/","text":"File IArgument.h \u00b6 FileList > Inc > IArgument.h Go to the source code of this file #include \"IIdentifiable.h\" #include <any> #include <vector> #include <typeinfo> Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IArgument Class for providing arguments for an ILinkableComponent and others. The documentation for this class was generated from the following file Models/Inc/IArgument.h","title":"File IArgument.h"},{"location":"models/_i_argument_8h/#file-iargumenth","text":"FileList > Inc > IArgument.h Go to the source code of this file #include \"IIdentifiable.h\" #include <any> #include <vector> #include <typeinfo>","title":"File IArgument.h"},{"location":"models/_i_argument_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_argument_8h/#classes","text":"Type Name class IArgument Class for providing arguments for an ILinkableComponent and others. The documentation for this class was generated from the following file Models/Inc/IArgument.h","title":"Classes"},{"location":"models/_i_argument_8h_source/","text":"File IArgument.h \u00b6 File List > Inc > IArgument.h Go to the documentation of this file #pragma once #include \"IIdentifiable.h\" #include <any> #include <vector> #include <typeinfo> namespace OpenOasis { class IArgument : public IIdentifiable { public : virtual const std :: type_info & GetValueType () const = 0 ; virtual bool IsOptional () const = 0 ; virtual bool IsReadOnly () const = 0 ; virtual std :: any GetValue () const = 0 ; virtual void SetValue ( std :: any value ) = 0 ; virtual std :: any GetDefaultValue () const = 0 ; virtual std :: vector < std :: any > GetPossibleValues () const = 0 ; }; } // namespace OpenOasis","title":"File IArgument.h"},{"location":"models/_i_argument_8h_source/#file-iargumenth","text":"File List > Inc > IArgument.h Go to the documentation of this file #pragma once #include \"IIdentifiable.h\" #include <any> #include <vector> #include <typeinfo> namespace OpenOasis { class IArgument : public IIdentifiable { public : virtual const std :: type_info & GetValueType () const = 0 ; virtual bool IsOptional () const = 0 ; virtual bool IsReadOnly () const = 0 ; virtual std :: any GetValue () const = 0 ; virtual void SetValue ( std :: any value ) = 0 ; virtual std :: any GetDefaultValue () const = 0 ; virtual std :: vector < std :: any > GetPossibleValues () const = 0 ; }; } // namespace OpenOasis","title":"File IArgument.h"},{"location":"models/_i_base_exchange_item_8h/","text":"File IBaseExchangeItem.h \u00b6 FileList > Inc > IBaseExchangeItem.h Go to the source code of this file #include \"IValueDefinition.h\" #include \"IValueSet.h\" #include \"IIdentifiable.h\" #include \"ITimeSet.h\" #include \"IElementSet.h\" #include \"ExchangeItemChangeEventArgs.h\" #include <functional> Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IBaseExchangeItem Class presenting a item that can be exchanged, either as an input or output. The documentation for this class was generated from the following file Models/Inc/IBaseExchangeItem.h","title":"File IBaseExchangeItem.h"},{"location":"models/_i_base_exchange_item_8h/#file-ibaseexchangeitemh","text":"FileList > Inc > IBaseExchangeItem.h Go to the source code of this file #include \"IValueDefinition.h\" #include \"IValueSet.h\" #include \"IIdentifiable.h\" #include \"ITimeSet.h\" #include \"IElementSet.h\" #include \"ExchangeItemChangeEventArgs.h\" #include <functional>","title":"File IBaseExchangeItem.h"},{"location":"models/_i_base_exchange_item_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_base_exchange_item_8h/#classes","text":"Type Name class IBaseExchangeItem Class presenting a item that can be exchanged, either as an input or output. The documentation for this class was generated from the following file Models/Inc/IBaseExchangeItem.h","title":"Classes"},{"location":"models/_i_base_exchange_item_8h_source/","text":"File IBaseExchangeItem.h \u00b6 File List > Inc > IBaseExchangeItem.h Go to the documentation of this file #pragma once #include \"IValueDefinition.h\" #include \"IValueSet.h\" #include \"IIdentifiable.h\" #include \"ITimeSet.h\" #include \"IElementSet.h\" #include \"ExchangeItemChangeEventArgs.h\" #include <functional> namespace OpenOasis { class ILinkableComponent ; class IBaseExchangeItem : public IIdentifiable { public : using ListenFunc = std :: function < void ( std :: shared_ptr < ExchangeItemChangeEventArgs > ) > ; public : virtual std :: shared_ptr < IValueDefinition > GetValueDefinition () const = 0 ; virtual void Reset () = 0 ; virtual std :: shared_ptr < IValueSet > GetValues () = 0 ; virtual std :: shared_ptr < IElementSet > GetElementSet () const = 0 ; virtual void SetValues ( std :: shared_ptr < IValueSet > value ) = 0 ; virtual std :: shared_ptr < ITimeSet > GetTimeSet () const = 0 ; virtual void SetTimeSet ( std :: shared_ptr < ITimeSet > times ) = 0 ; virtual void SetElementSet ( std :: shared_ptr < IElementSet > elements ) = 0 ; virtual std :: weak_ptr < ILinkableComponent > GetComponent () const = 0 ; virtual void AddListener ( const ListenFunc & func ) = 0 ; virtual void RemoveListener ( const ListenFunc & func ) = 0 ; }; } // namespace OpenOasis","title":"File IBaseExchangeItem.h"},{"location":"models/_i_base_exchange_item_8h_source/#file-ibaseexchangeitemh","text":"File List > Inc > IBaseExchangeItem.h Go to the documentation of this file #pragma once #include \"IValueDefinition.h\" #include \"IValueSet.h\" #include \"IIdentifiable.h\" #include \"ITimeSet.h\" #include \"IElementSet.h\" #include \"ExchangeItemChangeEventArgs.h\" #include <functional> namespace OpenOasis { class ILinkableComponent ; class IBaseExchangeItem : public IIdentifiable { public : using ListenFunc = std :: function < void ( std :: shared_ptr < ExchangeItemChangeEventArgs > ) > ; public : virtual std :: shared_ptr < IValueDefinition > GetValueDefinition () const = 0 ; virtual void Reset () = 0 ; virtual std :: shared_ptr < IValueSet > GetValues () = 0 ; virtual std :: shared_ptr < IElementSet > GetElementSet () const = 0 ; virtual void SetValues ( std :: shared_ptr < IValueSet > value ) = 0 ; virtual std :: shared_ptr < ITimeSet > GetTimeSet () const = 0 ; virtual void SetTimeSet ( std :: shared_ptr < ITimeSet > times ) = 0 ; virtual void SetElementSet ( std :: shared_ptr < IElementSet > elements ) = 0 ; virtual std :: weak_ptr < ILinkableComponent > GetComponent () const = 0 ; virtual void AddListener ( const ListenFunc & func ) = 0 ; virtual void RemoveListener ( const ListenFunc & func ) = 0 ; }; } // namespace OpenOasis","title":"File IBaseExchangeItem.h"},{"location":"models/_i_byte_state_converter_8h/","text":"File IByteStateConverter.h \u00b6 FileList > Inc > IByteStateConverter.h Go to the source code of this file #include \"IIdentifiable.h\" #include <vector> #include <memory> Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IByteStateConverter An optional interface to save and transform the model state. The documentation for this class was generated from the following file Models/Inc/IByteStateConverter.h","title":"File IByteStateConverter.h"},{"location":"models/_i_byte_state_converter_8h/#file-ibytestateconverterh","text":"FileList > Inc > IByteStateConverter.h Go to the source code of this file #include \"IIdentifiable.h\" #include <vector> #include <memory>","title":"File IByteStateConverter.h"},{"location":"models/_i_byte_state_converter_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_byte_state_converter_8h/#classes","text":"Type Name class IByteStateConverter An optional interface to save and transform the model state. The documentation for this class was generated from the following file Models/Inc/IByteStateConverter.h","title":"Classes"},{"location":"models/_i_byte_state_converter_8h_source/","text":"File IByteStateConverter.h \u00b6 File List > Inc > IByteStateConverter.h Go to the documentation of this file #pragma once #include \"IIdentifiable.h\" #include <vector> #include <memory> namespace OpenOasis { class IByteStateConverter { public : virtual std :: stringstream ConvertToByteStream ( const std :: shared_ptr < IIdentifiable > & stateId ) = 0 ; virtual std :: shared_ptr < IIdentifiable > ConvertFromByteStream ( const std :: stringstream & byteStream ) = 0 ; }; } // namespace OpenOasis","title":"File IByteStateConverter.h"},{"location":"models/_i_byte_state_converter_8h_source/#file-ibytestateconverterh","text":"File List > Inc > IByteStateConverter.h Go to the documentation of this file #pragma once #include \"IIdentifiable.h\" #include <vector> #include <memory> namespace OpenOasis { class IByteStateConverter { public : virtual std :: stringstream ConvertToByteStream ( const std :: shared_ptr < IIdentifiable > & stateId ) = 0 ; virtual std :: shared_ptr < IIdentifiable > ConvertFromByteStream ( const std :: stringstream & byteStream ) = 0 ; }; } // namespace OpenOasis","title":"File IByteStateConverter.h"},{"location":"models/_i_category_8h/","text":"File ICategory.h \u00b6 FileList > Inc > ICategory.h Go to the source code of this file #include \"IDescribable.h\" #include <any> Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class ICategory Class describes one item of a possible categorization. The documentation for this class was generated from the following file Models/Inc/ICategory.h","title":"File ICategory.h"},{"location":"models/_i_category_8h/#file-icategoryh","text":"FileList > Inc > ICategory.h Go to the source code of this file #include \"IDescribable.h\" #include <any>","title":"File ICategory.h"},{"location":"models/_i_category_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_category_8h/#classes","text":"Type Name class ICategory Class describes one item of a possible categorization. The documentation for this class was generated from the following file Models/Inc/ICategory.h","title":"Classes"},{"location":"models/_i_category_8h_source/","text":"File ICategory.h \u00b6 File List > Inc > ICategory.h Go to the documentation of this file #pragma once #include \"IDescribable.h\" #include <any> namespace OpenOasis { class ICategory : public IDescribable { public : virtual std :: any GetValue () const = 0 ; }; } // namespace OpenOasis","title":"File ICategory.h"},{"location":"models/_i_category_8h_source/#file-icategoryh","text":"File List > Inc > ICategory.h Go to the documentation of this file #pragma once #include \"IDescribable.h\" #include <any> namespace OpenOasis { class ICategory : public IDescribable { public : virtual std :: any GetValue () const = 0 ; }; } // namespace OpenOasis","title":"File ICategory.h"},{"location":"models/_i_describable_8h/","text":"File IDescribable.h \u00b6 FileList > Inc > IDescribable.h Go to the source code of this file #include <string> Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IDescribable An entity that is describable has a caption (title or heading) and a description. These are not to be used for identification. The documentation for this class was generated from the following file Models/Inc/IDescribable.h","title":"File IDescribable.h"},{"location":"models/_i_describable_8h/#file-idescribableh","text":"FileList > Inc > IDescribable.h Go to the source code of this file #include <string>","title":"File IDescribable.h"},{"location":"models/_i_describable_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_describable_8h/#classes","text":"Type Name class IDescribable An entity that is describable has a caption (title or heading) and a description. These are not to be used for identification. The documentation for this class was generated from the following file Models/Inc/IDescribable.h","title":"Classes"},{"location":"models/_i_describable_8h_source/","text":"File IDescribable.h \u00b6 File List > Inc > IDescribable.h Go to the documentation of this file #pragma once #include <string> namespace OpenOasis { class IDescribable { public : // Caption string. // virtual std :: string GetCaption () const = 0 ; virtual void SetCaption ( const std :: string & value ) = 0 ; // Additional descriptive information about the entity. // virtual std :: string GetDescription () const = 0 ; virtual void SetDescription ( const std :: string & value ) = 0 ; }; } // namespace OpenOasis","title":"File IDescribable.h"},{"location":"models/_i_describable_8h_source/#file-idescribableh","text":"File List > Inc > IDescribable.h Go to the documentation of this file #pragma once #include <string> namespace OpenOasis { class IDescribable { public : // Caption string. // virtual std :: string GetCaption () const = 0 ; virtual void SetCaption ( const std :: string & value ) = 0 ; // Additional descriptive information about the entity. // virtual std :: string GetDescription () const = 0 ; virtual void SetDescription ( const std :: string & value ) = 0 ; }; } // namespace OpenOasis","title":"File IDescribable.h"},{"location":"models/_i_dimension_8h/","text":"File IDimension.h \u00b6 FileList > Inc > IDimension.h Go to the source code of this file Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IDimension Define the order of each dimension in DimensionBase for a unit. The documentation for this class was generated from the following file Models/Inc/IDimension.h","title":"File IDimension.h"},{"location":"models/_i_dimension_8h/#file-idimensionh","text":"FileList > Inc > IDimension.h Go to the source code of this file","title":"File IDimension.h"},{"location":"models/_i_dimension_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_dimension_8h/#classes","text":"Type Name class IDimension Define the order of each dimension in DimensionBase for a unit. The documentation for this class was generated from the following file Models/Inc/IDimension.h","title":"Classes"},{"location":"models/_i_dimension_8h_source/","text":"File IDimension.h \u00b6 File List > Inc > IDimension.h Go to the documentation of this file #pragma once namespace OpenOasis { enum class DimensionBase { Length , // Base dimension length. Mass , // Base dimension mass. Time , // Base dimension time. ElectricCurrent , // Base dimension electric current. Temperature , // Base dimension temperature. AmountOfSubstance , // Base dimension amount of substance. LuminousIntensity , // Base dimension luminous intensity. Currency // Base dimension currency. }; class IDimension { public : virtual double GetPower ( DimensionBase baseQuantity ) const = 0 ; virtual void SetPower ( DimensionBase baseQuantity , double power ) = 0 ; }; } // namespace OpenOasis","title":"File IDimension.h"},{"location":"models/_i_dimension_8h_source/#file-idimensionh","text":"File List > Inc > IDimension.h Go to the documentation of this file #pragma once namespace OpenOasis { enum class DimensionBase { Length , // Base dimension length. Mass , // Base dimension mass. Time , // Base dimension time. ElectricCurrent , // Base dimension electric current. Temperature , // Base dimension temperature. AmountOfSubstance , // Base dimension amount of substance. LuminousIntensity , // Base dimension luminous intensity. Currency // Base dimension currency. }; class IDimension { public : virtual double GetPower ( DimensionBase baseQuantity ) const = 0 ; virtual void SetPower ( DimensionBase baseQuantity , double power ) = 0 ; }; } // namespace OpenOasis","title":"File IDimension.h"},{"location":"models/_i_element_set_8h/","text":"File IElementSet.h \u00b6 FileList > Inc > IElementSet.h Go to the source code of this file #include \"ISpatialDefinition.h\" #include <vector> Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IElementSet An list of elements having a common type. The documentation for this class was generated from the following file Models/Inc/IElementSet.h","title":"File IElementSet.h"},{"location":"models/_i_element_set_8h/#file-ielementseth","text":"FileList > Inc > IElementSet.h Go to the source code of this file #include \"ISpatialDefinition.h\" #include <vector>","title":"File IElementSet.h"},{"location":"models/_i_element_set_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_element_set_8h/#classes","text":"Type Name class IElementSet An list of elements having a common type. The documentation for this class was generated from the following file Models/Inc/IElementSet.h","title":"Classes"},{"location":"models/_i_element_set_8h_source/","text":"File IElementSet.h \u00b6 File List > Inc > IElementSet.h Go to the documentation of this file #pragma once #include \"ISpatialDefinition.h\" #include <vector> namespace OpenOasis { enum class ElementType { IdBased , // Identifiable based Point , // Points Polyline , // Lines / Polylines Polygon , // Polygons Polyhedron // Polyhedrons }; class IElementSet : public ISpatialDefinition { public : virtual ElementType GetElementType () const = 0 ; virtual int GetElementIndex ( const std :: string & elementId ) = 0 ; virtual std :: string GetElementId ( int index ) = 0 ; virtual int GetFaceCount ( int elementIndex ) = 0 ; virtual int GetNodeCount ( int elementIndex ) = 0 ; virtual std :: vector < int > GetFaceNodeIndices ( int elementIndex , int faceIndex ) = 0 ; virtual double GetNodeXCoordinate ( int elementIndex , int nodeIndex ) = 0 ; virtual double GetNodeYCoordinate ( int elementIndex , int nodeIndex ) = 0 ; virtual double GetNodeZCoordinate ( int elementIndex , int nodeIndex ) = 0 ; }; } // namespace OpenOasis","title":"File IElementSet.h"},{"location":"models/_i_element_set_8h_source/#file-ielementseth","text":"File List > Inc > IElementSet.h Go to the documentation of this file #pragma once #include \"ISpatialDefinition.h\" #include <vector> namespace OpenOasis { enum class ElementType { IdBased , // Identifiable based Point , // Points Polyline , // Lines / Polylines Polygon , // Polygons Polyhedron // Polyhedrons }; class IElementSet : public ISpatialDefinition { public : virtual ElementType GetElementType () const = 0 ; virtual int GetElementIndex ( const std :: string & elementId ) = 0 ; virtual std :: string GetElementId ( int index ) = 0 ; virtual int GetFaceCount ( int elementIndex ) = 0 ; virtual int GetNodeCount ( int elementIndex ) = 0 ; virtual std :: vector < int > GetFaceNodeIndices ( int elementIndex , int faceIndex ) = 0 ; virtual double GetNodeXCoordinate ( int elementIndex , int nodeIndex ) = 0 ; virtual double GetNodeYCoordinate ( int elementIndex , int nodeIndex ) = 0 ; virtual double GetNodeZCoordinate ( int elementIndex , int nodeIndex ) = 0 ; }; } // namespace OpenOasis","title":"File IElementSet.h"},{"location":"models/_i_identifiable_8h/","text":"File IIdentifiable.h \u00b6 FileList > Inc > IIdentifiable.h Go to the source code of this file #include \"IDescribable.h\" #include <string> Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IIdentifiable To define a method to get the Id of an OpenOasis entity. The documentation for this class was generated from the following file Models/Inc/IIdentifiable.h","title":"File IIdentifiable.h"},{"location":"models/_i_identifiable_8h/#file-iidentifiableh","text":"FileList > Inc > IIdentifiable.h Go to the source code of this file #include \"IDescribable.h\" #include <string>","title":"File IIdentifiable.h"},{"location":"models/_i_identifiable_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_identifiable_8h/#classes","text":"Type Name class IIdentifiable To define a method to get the Id of an OpenOasis entity. The documentation for this class was generated from the following file Models/Inc/IIdentifiable.h","title":"Classes"},{"location":"models/_i_identifiable_8h_source/","text":"File IIdentifiable.h \u00b6 File List > Inc > IIdentifiable.h Go to the documentation of this file #pragma once #include \"IDescribable.h\" #include <string> namespace OpenOasis { class IIdentifiable : public IDescribable { public : virtual std :: string GetId () const = 0 ; }; } // namespace OpenOasis","title":"File IIdentifiable.h"},{"location":"models/_i_identifiable_8h_source/#file-iidentifiableh","text":"File List > Inc > IIdentifiable.h Go to the documentation of this file #pragma once #include \"IDescribable.h\" #include <string> namespace OpenOasis { class IIdentifiable : public IDescribable { public : virtual std :: string GetId () const = 0 ; }; } // namespace OpenOasis","title":"File IIdentifiable.h"},{"location":"models/_i_input_8h/","text":"File IInput.h \u00b6 FileList > Inc > IInput.h Go to the source code of this file #include \"IBaseExchangeItem.h\" #include \"IValueSet.h\" #include \"ITimeSet.h\" Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IInput An input item that can accept values for an ILinkableComponent . The input item may have multiple providers. The documentation for this class was generated from the following file Models/Inc/IInput.h","title":"File IInput.h"},{"location":"models/_i_input_8h/#file-iinputh","text":"FileList > Inc > IInput.h Go to the source code of this file #include \"IBaseExchangeItem.h\" #include \"IValueSet.h\" #include \"ITimeSet.h\"","title":"File IInput.h"},{"location":"models/_i_input_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_input_8h/#classes","text":"Type Name class IInput An input item that can accept values for an ILinkableComponent . The input item may have multiple providers. The documentation for this class was generated from the following file Models/Inc/IInput.h","title":"Classes"},{"location":"models/_i_input_8h_source/","text":"File IInput.h \u00b6 File List > Inc > IInput.h Go to the documentation of this file #pragma once #include \"IBaseExchangeItem.h\" #include \"IValueSet.h\" #include \"ITimeSet.h\" namespace OpenOasis { class IOutput ; class IInput : public IBaseExchangeItem { public : virtual std :: vector < std :: weak_ptr < IOutput >> GetProviders () const = 0 ; virtual void AddProvider ( std :: shared_ptr < IOutput > provider ) = 0 ; virtual void RemoveProvider ( const std :: shared_ptr < IOutput > & provider ) = 0 ; }; } // namespace OpenOasis","title":"File IInput.h"},{"location":"models/_i_input_8h_source/#file-iinputh","text":"File List > Inc > IInput.h Go to the documentation of this file #pragma once #include \"IBaseExchangeItem.h\" #include \"IValueSet.h\" #include \"ITimeSet.h\" namespace OpenOasis { class IOutput ; class IInput : public IBaseExchangeItem { public : virtual std :: vector < std :: weak_ptr < IOutput >> GetProviders () const = 0 ; virtual void AddProvider ( std :: shared_ptr < IOutput > provider ) = 0 ; virtual void RemoveProvider ( const std :: shared_ptr < IOutput > & provider ) = 0 ; }; } // namespace OpenOasis","title":"File IInput.h"},{"location":"models/_i_linkable_component_8h/","text":"File ILinkableComponent.h \u00b6 FileList > Inc > ILinkableComponent.h Go to the source code of this file #include \"IAdaptedOutputFactory.h\" #include \"LinkableComponentStatus.h\" #include \"LinkableComponentStatusChangeEventArgs.h\" Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class ILinkableComponent The key interface class for linkable modules connection and data transfer. The documentation for this class was generated from the following file Models/Inc/ILinkableComponent.h","title":"File ILinkableComponent.h"},{"location":"models/_i_linkable_component_8h/#file-ilinkablecomponenth","text":"FileList > Inc > ILinkableComponent.h Go to the source code of this file #include \"IAdaptedOutputFactory.h\" #include \"LinkableComponentStatus.h\" #include \"LinkableComponentStatusChangeEventArgs.h\"","title":"File ILinkableComponent.h"},{"location":"models/_i_linkable_component_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_linkable_component_8h/#classes","text":"Type Name class ILinkableComponent The key interface class for linkable modules connection and data transfer. The documentation for this class was generated from the following file Models/Inc/ILinkableComponent.h","title":"Classes"},{"location":"models/_i_linkable_component_8h_source/","text":"File ILinkableComponent.h \u00b6 File List > Inc > ILinkableComponent.h Go to the documentation of this file #pragma once #include \"IAdaptedOutputFactory.h\" #include \"LinkableComponentStatus.h\" #include \"LinkableComponentStatusChangeEventArgs.h\" namespace OpenOasis { class ILinkableComponent : public IIdentifiable { public : using ListenFunc = std :: function < void ( std :: shared_ptr < LinkableComponentStatusChangeEventArgs > ) > ; public : virtual std :: vector < std :: shared_ptr < IArgument >> GetArguments () const = 0 ; virtual LinkableComponentStatus GetStatus () const = 0 ; virtual std :: vector < std :: shared_ptr < IInput >> GetInputs () const = 0 ; virtual std :: vector < std :: shared_ptr < IOutput >> GetOutputs () const = 0 ; virtual std :: vector < std :: shared_ptr < IAdaptedOutputFactory >> GetAdaptedOutputFactories () const = 0 ; virtual void Initialize () = 0 ; virtual std :: vector < std :: string > Validate () = 0 ; virtual void Prepare () = 0 ; virtual void Update () = 0 ; virtual void Finish () = 0 ; virtual void RemoveListener ( const ListenFunc & func ) = 0 ; virtual void AddListener ( const ListenFunc & func ) = 0 ; }; } // namespace OpenOasis","title":"File ILinkableComponent.h"},{"location":"models/_i_linkable_component_8h_source/#file-ilinkablecomponenth","text":"File List > Inc > ILinkableComponent.h Go to the documentation of this file #pragma once #include \"IAdaptedOutputFactory.h\" #include \"LinkableComponentStatus.h\" #include \"LinkableComponentStatusChangeEventArgs.h\" namespace OpenOasis { class ILinkableComponent : public IIdentifiable { public : using ListenFunc = std :: function < void ( std :: shared_ptr < LinkableComponentStatusChangeEventArgs > ) > ; public : virtual std :: vector < std :: shared_ptr < IArgument >> GetArguments () const = 0 ; virtual LinkableComponentStatus GetStatus () const = 0 ; virtual std :: vector < std :: shared_ptr < IInput >> GetInputs () const = 0 ; virtual std :: vector < std :: shared_ptr < IOutput >> GetOutputs () const = 0 ; virtual std :: vector < std :: shared_ptr < IAdaptedOutputFactory >> GetAdaptedOutputFactories () const = 0 ; virtual void Initialize () = 0 ; virtual std :: vector < std :: string > Validate () = 0 ; virtual void Prepare () = 0 ; virtual void Update () = 0 ; virtual void Finish () = 0 ; virtual void RemoveListener ( const ListenFunc & func ) = 0 ; virtual void AddListener ( const ListenFunc & func ) = 0 ; }; } // namespace OpenOasis","title":"File ILinkableComponent.h"},{"location":"models/_i_manage_state_8h/","text":"File IManageState.h \u00b6 FileList > Inc > IManageState.h Go to the source code of this file #include \"IIdentifiable.h\" #include <memory> Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IManageState It provides additional methods for handling component state so it can be saved, restored and cleared. The documentation for this class was generated from the following file Models/Inc/IManageState.h","title":"File IManageState.h"},{"location":"models/_i_manage_state_8h/#file-imanagestateh","text":"FileList > Inc > IManageState.h Go to the source code of this file #include \"IIdentifiable.h\" #include <memory>","title":"File IManageState.h"},{"location":"models/_i_manage_state_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_manage_state_8h/#classes","text":"Type Name class IManageState It provides additional methods for handling component state so it can be saved, restored and cleared. The documentation for this class was generated from the following file Models/Inc/IManageState.h","title":"Classes"},{"location":"models/_i_manage_state_8h_source/","text":"File IManageState.h \u00b6 File List > Inc > IManageState.h Go to the documentation of this file #pragma once #include \"IIdentifiable.h\" #include <memory> namespace OpenOasis { class IManageState { public : virtual std :: shared_ptr < IIdentifiable > KeepCurrentState () = 0 ; virtual void RestoreState ( const std :: shared_ptr < IIdentifiable > & stateId ) = 0 ; virtual void ClearState ( const std :: shared_ptr < IIdentifiable > & stateId ) = 0 ; }; } // namespace OpenOasis","title":"File IManageState.h"},{"location":"models/_i_manage_state_8h_source/#file-imanagestateh","text":"File List > Inc > IManageState.h Go to the documentation of this file #pragma once #include \"IIdentifiable.h\" #include <memory> namespace OpenOasis { class IManageState { public : virtual std :: shared_ptr < IIdentifiable > KeepCurrentState () = 0 ; virtual void RestoreState ( const std :: shared_ptr < IIdentifiable > & stateId ) = 0 ; virtual void ClearState ( const std :: shared_ptr < IIdentifiable > & stateId ) = 0 ; }; } // namespace OpenOasis","title":"File IManageState.h"},{"location":"models/_i_output_8h/","text":"File IOutput.h \u00b6 FileList > Inc > IOutput.h Go to the source code of this file #include \"IBaseExchangeItem.h\" #include \"IInput.h\" #include \"IValueSet.h\" Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IOutput Output exchange item that can deliver values from an ILinkableComponent . The documentation for this class was generated from the following file Models/Inc/IOutput.h","title":"File IOutput.h"},{"location":"models/_i_output_8h/#file-ioutputh","text":"FileList > Inc > IOutput.h Go to the source code of this file #include \"IBaseExchangeItem.h\" #include \"IInput.h\" #include \"IValueSet.h\"","title":"File IOutput.h"},{"location":"models/_i_output_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_output_8h/#classes","text":"Type Name class IOutput Output exchange item that can deliver values from an ILinkableComponent . The documentation for this class was generated from the following file Models/Inc/IOutput.h","title":"Classes"},{"location":"models/_i_output_8h_source/","text":"File IOutput.h \u00b6 File List > Inc > IOutput.h Go to the documentation of this file #pragma once #include \"IBaseExchangeItem.h\" #include \"IInput.h\" #include \"IValueSet.h\" namespace OpenOasis { class IAdaptedOutput ; class IOutput : public IBaseExchangeItem { public : virtual std :: vector < std :: weak_ptr < IInput >> GetConsumers () const = 0 ; virtual void AddConsumer ( std :: shared_ptr < IInput > consumer ) = 0 ; virtual void RemoveConsumer ( const std :: shared_ptr < IInput > & consumer ) = 0 ; virtual std :: vector < std :: shared_ptr < IAdaptedOutput >> GetAdaptedOutputs () const = 0 ; virtual void RemoveAdaptedOutput ( const std :: shared_ptr < IAdaptedOutput > & adaptedOutput ) = 0 ; virtual void AddAdaptedOutput ( std :: shared_ptr < IAdaptedOutput > adaptedOutput ) = 0 ; }; } // namespace OpenOasis","title":"File IOutput.h"},{"location":"models/_i_output_8h_source/#file-ioutputh","text":"File List > Inc > IOutput.h Go to the documentation of this file #pragma once #include \"IBaseExchangeItem.h\" #include \"IInput.h\" #include \"IValueSet.h\" namespace OpenOasis { class IAdaptedOutput ; class IOutput : public IBaseExchangeItem { public : virtual std :: vector < std :: weak_ptr < IInput >> GetConsumers () const = 0 ; virtual void AddConsumer ( std :: shared_ptr < IInput > consumer ) = 0 ; virtual void RemoveConsumer ( const std :: shared_ptr < IInput > & consumer ) = 0 ; virtual std :: vector < std :: shared_ptr < IAdaptedOutput >> GetAdaptedOutputs () const = 0 ; virtual void RemoveAdaptedOutput ( const std :: shared_ptr < IAdaptedOutput > & adaptedOutput ) = 0 ; virtual void AddAdaptedOutput ( std :: shared_ptr < IAdaptedOutput > adaptedOutput ) = 0 ; }; } // namespace OpenOasis","title":"File IOutput.h"},{"location":"models/_i_quality_8h/","text":"File IQuality.h \u00b6 FileList > Inc > IQuality.h Go to the source code of this file #include \"IValueDefinition.h\" #include \"ICategory.h\" #include <vector> #include <memory> Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IQuality Class describes qualitative data, where a value is specified as one category within a number of predefined (possible) categories. The documentation for this class was generated from the following file Models/Inc/IQuality.h","title":"File IQuality.h"},{"location":"models/_i_quality_8h/#file-iqualityh","text":"FileList > Inc > IQuality.h Go to the source code of this file #include \"IValueDefinition.h\" #include \"ICategory.h\" #include <vector> #include <memory>","title":"File IQuality.h"},{"location":"models/_i_quality_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_quality_8h/#classes","text":"Type Name class IQuality Class describes qualitative data, where a value is specified as one category within a number of predefined (possible) categories. The documentation for this class was generated from the following file Models/Inc/IQuality.h","title":"Classes"},{"location":"models/_i_quality_8h_source/","text":"File IQuality.h \u00b6 File List > Inc > IQuality.h Go to the documentation of this file #pragma once #include \"IValueDefinition.h\" #include \"ICategory.h\" #include <vector> #include <memory> namespace OpenOasis { class IQuality : public IValueDefinition { public : virtual std :: vector < std :: shared_ptr < ICategory >> GetCategories () const = 0 ; virtual bool IsOrdered () const = 0 ; }; } // namespace OpenOasis","title":"File IQuality.h"},{"location":"models/_i_quality_8h_source/#file-iqualityh","text":"File List > Inc > IQuality.h Go to the documentation of this file #pragma once #include \"IValueDefinition.h\" #include \"ICategory.h\" #include <vector> #include <memory> namespace OpenOasis { class IQuality : public IValueDefinition { public : virtual std :: vector < std :: shared_ptr < ICategory >> GetCategories () const = 0 ; virtual bool IsOrdered () const = 0 ; }; } // namespace OpenOasis","title":"File IQuality.h"},{"location":"models/_i_quantity_8h/","text":"File IQuantity.h \u00b6 FileList > Inc > IQuantity.h Go to the source code of this file #include \"IUnit.h\" #include \"IValueDefinition.h\" Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IQuantity Class specifies values as an amount of some unit. The documentation for this class was generated from the following file Models/Inc/IQuantity.h","title":"File IQuantity.h"},{"location":"models/_i_quantity_8h/#file-iquantityh","text":"FileList > Inc > IQuantity.h Go to the source code of this file #include \"IUnit.h\" #include \"IValueDefinition.h\"","title":"File IQuantity.h"},{"location":"models/_i_quantity_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_quantity_8h/#classes","text":"Type Name class IQuantity Class specifies values as an amount of some unit. The documentation for this class was generated from the following file Models/Inc/IQuantity.h","title":"Classes"},{"location":"models/_i_quantity_8h_source/","text":"File IQuantity.h \u00b6 File List > Inc > IQuantity.h Go to the documentation of this file #pragma once #include \"IUnit.h\" #include \"IValueDefinition.h\" namespace OpenOasis { class IQuantity : public IValueDefinition { public : virtual std :: shared_ptr < IUnit > GetUnit () const = 0 ; }; } // namespace OpenOasis","title":"File IQuantity.h"},{"location":"models/_i_quantity_8h_source/#file-iquantityh","text":"File List > Inc > IQuantity.h Go to the documentation of this file #pragma once #include \"IUnit.h\" #include \"IValueDefinition.h\" namespace OpenOasis { class IQuantity : public IValueDefinition { public : virtual std :: shared_ptr < IUnit > GetUnit () const = 0 ; }; } // namespace OpenOasis","title":"File IQuantity.h"},{"location":"models/_i_spatial_definition_8h/","text":"File ISpatialDefinition.h \u00b6 FileList > Inc > ISpatialDefinition.h Go to the source code of this file #include \"IDescribable.h\" Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class ISpatialDefinition General spatial construct that all other spatial constructions extend from. The documentation for this class was generated from the following file Models/Inc/ISpatialDefinition.h","title":"File ISpatialDefinition.h"},{"location":"models/_i_spatial_definition_8h/#file-ispatialdefinitionh","text":"FileList > Inc > ISpatialDefinition.h Go to the source code of this file #include \"IDescribable.h\"","title":"File ISpatialDefinition.h"},{"location":"models/_i_spatial_definition_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_spatial_definition_8h/#classes","text":"Type Name class ISpatialDefinition General spatial construct that all other spatial constructions extend from. The documentation for this class was generated from the following file Models/Inc/ISpatialDefinition.h","title":"Classes"},{"location":"models/_i_spatial_definition_8h_source/","text":"File ISpatialDefinition.h \u00b6 File List > Inc > ISpatialDefinition.h Go to the documentation of this file #pragma once #include \"IDescribable.h\" namespace OpenOasis { class ISpatialDefinition : public IDescribable { public : virtual std :: string GetSpatialReferenceSystem () const = 0 ; virtual int GetElementCount () const = 0 ; virtual int GetVersion () const = 0 ; }; } // namespace OpenOasis","title":"File ISpatialDefinition.h"},{"location":"models/_i_spatial_definition_8h_source/#file-ispatialdefinitionh","text":"File List > Inc > ISpatialDefinition.h Go to the documentation of this file #pragma once #include \"IDescribable.h\" namespace OpenOasis { class ISpatialDefinition : public IDescribable { public : virtual std :: string GetSpatialReferenceSystem () const = 0 ; virtual int GetElementCount () const = 0 ; virtual int GetVersion () const = 0 ; }; } // namespace OpenOasis","title":"File ISpatialDefinition.h"},{"location":"models/_i_time_8h/","text":"File ITime.h \u00b6 FileList > Inc > ITime.h Go to the source code of this file Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class ITime Time interface to support a time stamp as well as a time interval. The documentation for this class was generated from the following file Models/Inc/ITime.h","title":"File ITime.h"},{"location":"models/_i_time_8h/#file-itimeh","text":"FileList > Inc > ITime.h Go to the source code of this file","title":"File ITime.h"},{"location":"models/_i_time_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_time_8h/#classes","text":"Type Name class ITime Time interface to support a time stamp as well as a time interval. The documentation for this class was generated from the following file Models/Inc/ITime.h","title":"Classes"},{"location":"models/_i_time_8h_source/","text":"File ITime.h \u00b6 File List > Inc > ITime.h Go to the documentation of this file #pragma once namespace OpenOasis { class ITime { public : virtual double GetTimeStamp () const = 0 ; virtual double GetDurationInDays () const = 0 ; }; } // namespace OpenOasis","title":"File ITime.h"},{"location":"models/_i_time_8h_source/#file-itimeh","text":"File List > Inc > ITime.h Go to the documentation of this file #pragma once namespace OpenOasis { class ITime { public : virtual double GetTimeStamp () const = 0 ; virtual double GetDurationInDays () const = 0 ; }; } // namespace OpenOasis","title":"File ITime.h"},{"location":"models/_i_time_set_8h/","text":"File ITimeSet.h \u00b6 FileList > Inc > ITimeSet.h Go to the source code of this file #include \"ITime.h\" #include <vector> #include <memory> Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class ITimeSet Set of time stamps or time intervals, used to indicate when an output has and can provide values, and when an input item does or may require values. The documentation for this class was generated from the following file Models/Inc/ITimeSet.h","title":"File ITimeSet.h"},{"location":"models/_i_time_set_8h/#file-itimeseth","text":"FileList > Inc > ITimeSet.h Go to the source code of this file #include \"ITime.h\" #include <vector> #include <memory>","title":"File ITimeSet.h"},{"location":"models/_i_time_set_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_time_set_8h/#classes","text":"Type Name class ITimeSet Set of time stamps or time intervals, used to indicate when an output has and can provide values, and when an input item does or may require values. The documentation for this class was generated from the following file Models/Inc/ITimeSet.h","title":"Classes"},{"location":"models/_i_time_set_8h_source/","text":"File ITimeSet.h \u00b6 File List > Inc > ITimeSet.h Go to the documentation of this file #pragma once #include \"ITime.h\" #include <vector> #include <memory> namespace OpenOasis { class ITimeSet { public : virtual std :: vector < std :: shared_ptr < ITime >> GetTimes () const = 0 ; virtual void RemoveTime ( int index ) = 0 ; virtual void AddTime ( std :: shared_ptr < ITime > time ) = 0 ; virtual bool HasDurations () const = 0 ; virtual double GetOffsetFromUtcInHours () const = 0 ; virtual std :: shared_ptr < ITime > GetTimeHorizon () const = 0 ; }; } // namespace OpenOasis","title":"File ITimeSet.h"},{"location":"models/_i_time_set_8h_source/#file-itimeseth","text":"File List > Inc > ITimeSet.h Go to the documentation of this file #pragma once #include \"ITime.h\" #include <vector> #include <memory> namespace OpenOasis { class ITimeSet { public : virtual std :: vector < std :: shared_ptr < ITime >> GetTimes () const = 0 ; virtual void RemoveTime ( int index ) = 0 ; virtual void AddTime ( std :: shared_ptr < ITime > time ) = 0 ; virtual bool HasDurations () const = 0 ; virtual double GetOffsetFromUtcInHours () const = 0 ; virtual std :: shared_ptr < ITime > GetTimeHorizon () const = 0 ; }; } // namespace OpenOasis","title":"File ITimeSet.h"},{"location":"models/_i_unit_8h/","text":"File IUnit.h \u00b6 FileList > Inc > IUnit.h Go to the source code of this file #include \"IDescribable.h\" #include \"IDimension.h\" #include <memory> Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IUnit Unit interface describes the physical unit. The documentation for this class was generated from the following file Models/Inc/IUnit.h","title":"File IUnit.h"},{"location":"models/_i_unit_8h/#file-iunith","text":"FileList > Inc > IUnit.h Go to the source code of this file #include \"IDescribable.h\" #include \"IDimension.h\" #include <memory>","title":"File IUnit.h"},{"location":"models/_i_unit_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_unit_8h/#classes","text":"Type Name class IUnit Unit interface describes the physical unit. The documentation for this class was generated from the following file Models/Inc/IUnit.h","title":"Classes"},{"location":"models/_i_unit_8h_source/","text":"File IUnit.h \u00b6 File List > Inc > IUnit.h Go to the documentation of this file #pragma once #include \"IDescribable.h\" #include \"IDimension.h\" #include <memory> namespace OpenOasis { class IUnit : public IDescribable { public : virtual std :: shared_ptr < IDimension > GetDimension () const = 0 ; virtual double GetConversionFactorToSI () const = 0 ; virtual double GetOffSetToSI () const = 0 ; }; } // namespace OpenOasis","title":"File IUnit.h"},{"location":"models/_i_unit_8h_source/#file-iunith","text":"File List > Inc > IUnit.h Go to the documentation of this file #pragma once #include \"IDescribable.h\" #include \"IDimension.h\" #include <memory> namespace OpenOasis { class IUnit : public IDescribable { public : virtual std :: shared_ptr < IDimension > GetDimension () const = 0 ; virtual double GetConversionFactorToSI () const = 0 ; virtual double GetOffSetToSI () const = 0 ; }; } // namespace OpenOasis","title":"File IUnit.h"},{"location":"models/_i_value_definition_8h/","text":"File IValueDefinition.h \u00b6 FileList > Inc > IValueDefinition.h Go to the source code of this file #include \"IDescribable.h\" #include <any> #include <typeinfo> Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IValueDefinition Class describes value definition. The documentation for this class was generated from the following file Models/Inc/IValueDefinition.h","title":"File IValueDefinition.h"},{"location":"models/_i_value_definition_8h/#file-ivaluedefinitionh","text":"FileList > Inc > IValueDefinition.h Go to the source code of this file #include \"IDescribable.h\" #include <any> #include <typeinfo>","title":"File IValueDefinition.h"},{"location":"models/_i_value_definition_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_value_definition_8h/#classes","text":"Type Name class IValueDefinition Class describes value definition. The documentation for this class was generated from the following file Models/Inc/IValueDefinition.h","title":"Classes"},{"location":"models/_i_value_definition_8h_source/","text":"File IValueDefinition.h \u00b6 File List > Inc > IValueDefinition.h Go to the documentation of this file #pragma once #include \"IDescribable.h\" #include <any> #include <typeinfo> namespace OpenOasis { class IValueDefinition : public IDescribable { public : virtual const std :: type_info & GetValueType () const = 0 ; virtual std :: any GetMissingDataValue () const = 0 ; }; } // namespace OpenOasis","title":"File IValueDefinition.h"},{"location":"models/_i_value_definition_8h_source/#file-ivaluedefinitionh","text":"File List > Inc > IValueDefinition.h Go to the documentation of this file #pragma once #include \"IDescribable.h\" #include <any> #include <typeinfo> namespace OpenOasis { class IValueDefinition : public IDescribable { public : virtual const std :: type_info & GetValueType () const = 0 ; virtual std :: any GetMissingDataValue () const = 0 ; }; } // namespace OpenOasis","title":"File IValueDefinition.h"},{"location":"models/_i_value_set_8h/","text":"File IValueSet.h \u00b6 FileList > Inc > IValueSet.h Go to the source code of this file #include \"IValueDefinition.h\" #include <any> #include <typeinfo> #include <vector> #include <memory> Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class IValueSet Class represents a general(ordered) multi-dimensional set of values. The documentation for this class was generated from the following file Models/Inc/IValueSet.h","title":"File IValueSet.h"},{"location":"models/_i_value_set_8h/#file-ivalueseth","text":"FileList > Inc > IValueSet.h Go to the source code of this file #include \"IValueDefinition.h\" #include <any> #include <typeinfo> #include <vector> #include <memory>","title":"File IValueSet.h"},{"location":"models/_i_value_set_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_i_value_set_8h/#classes","text":"Type Name class IValueSet Class represents a general(ordered) multi-dimensional set of values. The documentation for this class was generated from the following file Models/Inc/IValueSet.h","title":"Classes"},{"location":"models/_i_value_set_8h_source/","text":"File IValueSet.h \u00b6 File List > Inc > IValueSet.h Go to the documentation of this file #pragma once #include \"IValueDefinition.h\" #include <any> #include <typeinfo> #include <vector> #include <memory> namespace OpenOasis { class IValueSet { public : // Generic value set with multi-dimensional. // virtual std :: shared_ptr < IValueDefinition > GetValueDefinition () const = 0 ; virtual int GetNumberOfIndices () const = 0 ; virtual int GetIndexCount ( const std :: vector < int > & indices ) const = 0 ; virtual std :: any GetValue ( const std :: vector < int > & indices ) const = 0 ; virtual void RemoveValue ( const std :: vector < int > & indices ) = 0 ; virtual void SetOrAddValue ( const std :: vector < int > & indices , const std :: any & value ) = 0 ; // Two-dimensional list of values. // // The first dimension represents time corresponding to the `ITimeSet`, // the second contains each elements value corresponding to the `IElementSet`. // virtual bool IsValues2D () const = 0 ; virtual std :: vector < std :: any > GetTimeSeriesValuesForElement ( int elementIndex ) const = 0 ; virtual void SetTimeSeriesValuesForElement ( int elementIndex , const std :: vector < std :: any > & values ) = 0 ; virtual void SetElementValuesForTime ( int timeIndex , const std :: vector < std :: any > & values ) = 0 ; virtual std :: vector < std :: any > GetElementValuesForTime ( int timeIndex ) const = 0 ; }; } // namespace OpenOasis","title":"File IValueSet.h"},{"location":"models/_i_value_set_8h_source/#file-ivalueseth","text":"File List > Inc > IValueSet.h Go to the documentation of this file #pragma once #include \"IValueDefinition.h\" #include <any> #include <typeinfo> #include <vector> #include <memory> namespace OpenOasis { class IValueSet { public : // Generic value set with multi-dimensional. // virtual std :: shared_ptr < IValueDefinition > GetValueDefinition () const = 0 ; virtual int GetNumberOfIndices () const = 0 ; virtual int GetIndexCount ( const std :: vector < int > & indices ) const = 0 ; virtual std :: any GetValue ( const std :: vector < int > & indices ) const = 0 ; virtual void RemoveValue ( const std :: vector < int > & indices ) = 0 ; virtual void SetOrAddValue ( const std :: vector < int > & indices , const std :: any & value ) = 0 ; // Two-dimensional list of values. // // The first dimension represents time corresponding to the `ITimeSet`, // the second contains each elements value corresponding to the `IElementSet`. // virtual bool IsValues2D () const = 0 ; virtual std :: vector < std :: any > GetTimeSeriesValuesForElement ( int elementIndex ) const = 0 ; virtual void SetTimeSeriesValuesForElement ( int elementIndex , const std :: vector < std :: any > & values ) = 0 ; virtual void SetElementValuesForTime ( int timeIndex , const std :: vector < std :: any > & values ) = 0 ; virtual std :: vector < std :: any > GetElementValuesForTime ( int timeIndex ) const = 0 ; }; } // namespace OpenOasis","title":"File IValueSet.h"},{"location":"models/_linkable_component_status_8h/","text":"File LinkableComponentStatus.h \u00b6 FileList > Inc > LinkableComponentStatus.h Go to the source code of this file Namespaces \u00b6 Type Name namespace OpenOasis The documentation for this class was generated from the following file Models/Inc/LinkableComponentStatus.h","title":"File LinkableComponentStatus.h"},{"location":"models/_linkable_component_status_8h/#file-linkablecomponentstatush","text":"FileList > Inc > LinkableComponentStatus.h Go to the source code of this file","title":"File LinkableComponentStatus.h"},{"location":"models/_linkable_component_status_8h/#namespaces","text":"Type Name namespace OpenOasis The documentation for this class was generated from the following file Models/Inc/LinkableComponentStatus.h","title":"Namespaces"},{"location":"models/_linkable_component_status_8h_source/","text":"File LinkableComponentStatus.h \u00b6 File List > Inc > LinkableComponentStatus.h Go to the documentation of this file #pragma once namespace OpenOasis { enum class LinkableComponentStatus { Created , Initializing , Initialized , Validating , Valid , WaitingForData , Invalid , Preparing , Updating , Updated , Done , Finishing , Finished , Failed }; } // namespace OpenOasis","title":"File LinkableComponentStatus.h"},{"location":"models/_linkable_component_status_8h_source/#file-linkablecomponentstatush","text":"File List > Inc > LinkableComponentStatus.h Go to the documentation of this file #pragma once namespace OpenOasis { enum class LinkableComponentStatus { Created , Initializing , Initialized , Validating , Valid , WaitingForData , Invalid , Preparing , Updating , Updated , Done , Finishing , Finished , Failed }; } // namespace OpenOasis","title":"File LinkableComponentStatus.h"},{"location":"models/_linkable_component_status_change_event_args_8h/","text":"File LinkableComponentStatusChangeEventArgs.h \u00b6 FileList > Inc > LinkableComponentStatusChangeEventArgs.h Go to the source code of this file #include <memory> #include <string> #include \"LinkableComponentStatus.h\" Namespaces \u00b6 Type Name namespace OpenOasis Classes \u00b6 Type Name class LinkableComponentStatusChangeEventArgs Class contains the information that will be passed when the ILinkableComponent fires the StatusChanged event. The documentation for this class was generated from the following file Models/Inc/LinkableComponentStatusChangeEventArgs.h","title":"File LinkableComponentStatusChangeEventArgs.h"},{"location":"models/_linkable_component_status_change_event_args_8h/#file-linkablecomponentstatuschangeeventargsh","text":"FileList > Inc > LinkableComponentStatusChangeEventArgs.h Go to the source code of this file #include <memory> #include <string> #include \"LinkableComponentStatus.h\"","title":"File LinkableComponentStatusChangeEventArgs.h"},{"location":"models/_linkable_component_status_change_event_args_8h/#namespaces","text":"Type Name namespace OpenOasis","title":"Namespaces"},{"location":"models/_linkable_component_status_change_event_args_8h/#classes","text":"Type Name class LinkableComponentStatusChangeEventArgs Class contains the information that will be passed when the ILinkableComponent fires the StatusChanged event. The documentation for this class was generated from the following file Models/Inc/LinkableComponentStatusChangeEventArgs.h","title":"Classes"},{"location":"models/_linkable_component_status_change_event_args_8h_source/","text":"File LinkableComponentStatusChangeEventArgs.h \u00b6 File List > Inc > LinkableComponentStatusChangeEventArgs.h Go to the documentation of this file #pragma once #include <memory> #include <string> #include \"LinkableComponentStatus.h\" namespace OpenOasis { class ILinkableComponent ; class LinkableComponentStatusChangeEventArgs { public : // The linkable component that fired the status change event. // virtual std :: shared_ptr < ILinkableComponent > GetLinkableComponent () const = 0 ; virtual void SetLinkableComponent ( std :: shared_ptr < ILinkableComponent > obj ) = 0 ; // The linkable component's status before the status change. // virtual LinkableComponentStatus GetOldStatus () const = 0 ; virtual void SetOldStatus ( LinkableComponentStatus value ) = 0 ; // The linkable component's status after the status change. // virtual LinkableComponentStatus GetNewStatus () const = 0 ; virtual void SetNewStatus ( LinkableComponentStatus value ) = 0 ; // Message providing additional information on the status change. // virtual std :: string GetMessages () const = 0 ; virtual void SetMessages ( const std :: string & msg ) = 0 ; }; } // namespace OpenOasis","title":"File LinkableComponentStatusChangeEventArgs.h"},{"location":"models/_linkable_component_status_change_event_args_8h_source/#file-linkablecomponentstatuschangeeventargsh","text":"File List > Inc > LinkableComponentStatusChangeEventArgs.h Go to the documentation of this file #pragma once #include <memory> #include <string> #include \"LinkableComponentStatus.h\" namespace OpenOasis { class ILinkableComponent ; class LinkableComponentStatusChangeEventArgs { public : // The linkable component that fired the status change event. // virtual std :: shared_ptr < ILinkableComponent > GetLinkableComponent () const = 0 ; virtual void SetLinkableComponent ( std :: shared_ptr < ILinkableComponent > obj ) = 0 ; // The linkable component's status before the status change. // virtual LinkableComponentStatus GetOldStatus () const = 0 ; virtual void SetOldStatus ( LinkableComponentStatus value ) = 0 ; // The linkable component's status after the status change. // virtual LinkableComponentStatus GetNewStatus () const = 0 ; virtual void SetNewStatus ( LinkableComponentStatus value ) = 0 ; // Message providing additional information on the status change. // virtual std :: string GetMessages () const = 0 ; virtual void SetMessages ( const std :: string & msg ) = 0 ; }; } // namespace OpenOasis","title":"File LinkableComponentStatusChangeEventArgs.h"},{"location":"models/dir_f42854fb7a47e961c6b84a97d295c858/","text":"Dir Models/Inc/AdditionalControl \u00b6 FileList > AdditionalControl Files \u00b6 Type Name file IComparable.h file ISpaceExtension.h file ITimeExtension.h The documentation for this class was generated from the following file Models/Inc/AdditionalControl/","title":"Dir Models/Inc/AdditionalControl"},{"location":"models/dir_f42854fb7a47e961c6b84a97d295c858/#dir-modelsincadditionalcontrol","text":"FileList > AdditionalControl","title":"Dir Models/Inc/AdditionalControl"},{"location":"models/dir_f42854fb7a47e961c6b84a97d295c858/#files","text":"Type Name file IComparable.h file ISpaceExtension.h file ITimeExtension.h The documentation for this class was generated from the following file Models/Inc/AdditionalControl/","title":"Files"},{"location":"models/_i_comparable_8h/","text":"File IComparable.h \u00b6 FileList > AdditionalControl > IComparable.h Go to the source code of this file #include <memory> Namespaces \u00b6 Type Name namespace OpenOasis namespace AdditionalControl Classes \u00b6 Type Name class IComparable Interface class provides a unified interface for object comparison. The documentation for this class was generated from the following file Models/Inc/AdditionalControl/IComparable.h","title":"File IComparable.h"},{"location":"models/_i_comparable_8h/#file-icomparableh","text":"FileList > AdditionalControl > IComparable.h Go to the source code of this file #include <memory>","title":"File IComparable.h"},{"location":"models/_i_comparable_8h/#namespaces","text":"Type Name namespace OpenOasis namespace AdditionalControl","title":"Namespaces"},{"location":"models/_i_comparable_8h/#classes","text":"Type Name class IComparable Interface class provides a unified interface for object comparison. The documentation for this class was generated from the following file Models/Inc/AdditionalControl/IComparable.h","title":"Classes"},{"location":"models/_i_comparable_8h_source/","text":"File IComparable.h \u00b6 File List > AdditionalControl > IComparable.h Go to the documentation of this file #pragma once #include <memory> namespace OpenOasis { namespace AdditionalControl { class IComparable { public : virtual int CompareTo ( const std :: shared_ptr < IComparable > & obj ) const = 0 ; }; } // namespace AdditionalControl } // namespace OpenOasis","title":"File IComparable.h"},{"location":"models/_i_comparable_8h_source/#file-icomparableh","text":"File List > AdditionalControl > IComparable.h Go to the documentation of this file #pragma once #include <memory> namespace OpenOasis { namespace AdditionalControl { class IComparable { public : virtual int CompareTo ( const std :: shared_ptr < IComparable > & obj ) const = 0 ; }; } // namespace AdditionalControl } // namespace OpenOasis","title":"File IComparable.h"},{"location":"models/_i_space_extension_8h/","text":"File ISpaceExtension.h \u00b6 FileList > AdditionalControl > ISpaceExtension.h Go to the source code of this file #include \"Models/Inc/ISpatialDefinition.h\" #include <memory> Namespaces \u00b6 Type Name namespace OpenOasis namespace AdditionalControl Classes \u00b6 Type Name class ISpaceExtension The documentation for this class was generated from the following file Models/Inc/AdditionalControl/ISpaceExtension.h","title":"File ISpaceExtension.h"},{"location":"models/_i_space_extension_8h/#file-ispaceextensionh","text":"FileList > AdditionalControl > ISpaceExtension.h Go to the source code of this file #include \"Models/Inc/ISpatialDefinition.h\" #include <memory>","title":"File ISpaceExtension.h"},{"location":"models/_i_space_extension_8h/#namespaces","text":"Type Name namespace OpenOasis namespace AdditionalControl","title":"Namespaces"},{"location":"models/_i_space_extension_8h/#classes","text":"Type Name class ISpaceExtension The documentation for this class was generated from the following file Models/Inc/AdditionalControl/ISpaceExtension.h","title":"Classes"},{"location":"models/_i_space_extension_8h_source/","text":"File ISpaceExtension.h \u00b6 File List > AdditionalControl > ISpaceExtension.h Go to the documentation of this file #pragma once #include \"Models/Inc/ISpatialDefinition.h\" #include <memory> namespace OpenOasis { namespace AdditionalControl { class ISpaceExtension { public : virtual std :: shared_ptr < ISpatialDefinition > GetSpatialDefinition () const = 0 ; }; } // namespace AdditionalControl } // namespace OpenOasis","title":"File ISpaceExtension.h"},{"location":"models/_i_space_extension_8h_source/#file-ispaceextensionh","text":"File List > AdditionalControl > ISpaceExtension.h Go to the documentation of this file #pragma once #include \"Models/Inc/ISpatialDefinition.h\" #include <memory> namespace OpenOasis { namespace AdditionalControl { class ISpaceExtension { public : virtual std :: shared_ptr < ISpatialDefinition > GetSpatialDefinition () const = 0 ; }; } // namespace AdditionalControl } // namespace OpenOasis","title":"File ISpaceExtension.h"},{"location":"models/_i_time_extension_8h/","text":"File ITimeExtension.h \u00b6 FileList > AdditionalControl > ITimeExtension.h Go to the source code of this file #include \"Models/Inc/ITimeSet.h\" #include <memory> Namespaces \u00b6 Type Name namespace OpenOasis namespace AdditionalControl Classes \u00b6 Type Name class ITimeExtension Methods that are specific for a time-space component. The documentation for this class was generated from the following file Models/Inc/AdditionalControl/ITimeExtension.h","title":"File ITimeExtension.h"},{"location":"models/_i_time_extension_8h/#file-itimeextensionh","text":"FileList > AdditionalControl > ITimeExtension.h Go to the source code of this file #include \"Models/Inc/ITimeSet.h\" #include <memory>","title":"File ITimeExtension.h"},{"location":"models/_i_time_extension_8h/#namespaces","text":"Type Name namespace OpenOasis namespace AdditionalControl","title":"Namespaces"},{"location":"models/_i_time_extension_8h/#classes","text":"Type Name class ITimeExtension Methods that are specific for a time-space component. The documentation for this class was generated from the following file Models/Inc/AdditionalControl/ITimeExtension.h","title":"Classes"},{"location":"models/_i_time_extension_8h_source/","text":"File ITimeExtension.h \u00b6 File List > AdditionalControl > ITimeExtension.h Go to the documentation of this file #pragma once #include \"Models/Inc/ITimeSet.h\" #include <memory> namespace OpenOasis { namespace AdditionalControl { class ITimeExtension { public : virtual std :: shared_ptr < ITimeSet > GetTimeExtent () const = 0 ; virtual std :: shared_ptr < ITime > GetCurrTime () const = 0 ; }; } // namespace AdditionalControl } // namespace OpenOasis","title":"File ITimeExtension.h"},{"location":"models/_i_time_extension_8h_source/#file-itimeextensionh","text":"File List > AdditionalControl > ITimeExtension.h Go to the documentation of this file #pragma once #include \"Models/Inc/ITimeSet.h\" #include <memory> namespace OpenOasis { namespace AdditionalControl { class ITimeExtension { public : virtual std :: shared_ptr < ITimeSet > GetTimeExtent () const = 0 ; virtual std :: shared_ptr < ITime > GetCurrTime () const = 0 ; }; } // namespace AdditionalControl } // namespace OpenOasis","title":"File ITimeExtension.h"},{"location":"models/dir_a73574e9fd225504e8a3c322dcb45030/","text":"Dir Models/SystHeats \u00b6 FileList > Models > SystHeats Directories \u00b6 Type Name dir HeatConductionModel The documentation for this class was generated from the following file Models/SystHeats/","title":"Dir Models/SystHeats"},{"location":"models/dir_a73574e9fd225504e8a3c322dcb45030/#dir-modelssystheats","text":"FileList > Models > SystHeats","title":"Dir Models/SystHeats"},{"location":"models/dir_a73574e9fd225504e8a3c322dcb45030/#directories","text":"Type Name dir HeatConductionModel The documentation for this class was generated from the following file Models/SystHeats/","title":"Directories"},{"location":"models/dir_598ce1e743ead5e92cc84cac2af27086/","text":"Dir Models/SystHeats/HeatConductionModel \u00b6 FileList > HeatConductionModel Files \u00b6 Type Name file HeatConductionModel.cpp file HeatConductionModel.h The documentation for this class was generated from the following file Models/SystHeats/HeatConductionModel/","title":"Dir Models/SystHeats/HeatConductionModel"},{"location":"models/dir_598ce1e743ead5e92cc84cac2af27086/#dir-modelssystheatsheatconductionmodel","text":"FileList > HeatConductionModel","title":"Dir Models/SystHeats/HeatConductionModel"},{"location":"models/dir_598ce1e743ead5e92cc84cac2af27086/#files","text":"Type Name file HeatConductionModel.cpp file HeatConductionModel.h The documentation for this class was generated from the following file Models/SystHeats/HeatConductionModel/","title":"Files"},{"location":"models/_heat_conduction_model_8cpp/","text":"File HeatConductionModel.cpp \u00b6 FileList > HeatConductionModel > HeatConductionModel.cpp Go to the source code of this file #include \"HeatConductionModel.h\" #include \"Models/CommImp/Arguments.h\" #include \"Models/CommImp/Dimension.h\" #include \"Models/CommImp/Unit.h\" #include \"Models/CommImp/Time.h\" #include \"Models/CommImp/TimeSet.h\" #include \"Models/CommImp/Quantity.h\" #include \"Models/CommImp/ElementSet.h\" #include \"Models/CommImp/ValueSet2D.h\" #include \"Models/CommImp/IO/MeshLoader.h\" #include \"Models/CommImp/Spatial/Grid2D.h\" #include \"Models/CommImp/Numeric/FVM/FvmSolver.h\" #include \"Models/CommImp/Numeric/DirichletBoundary.h\" #include \"Models/Utils/YamlHandler.h\" #include \"Models/Utils/Exception.h\" #include \"Models/Utils/StringHelper.h\" #include \"Models/Utils/FilePathHelper.h\" #include \"Models/Utils/VectorHelper.h\" #include \"Models/Utils/CsvHandler.h\" #include \"ThirdPart/Eigen/IterativeLinearSolvers\" #include <set> Namespaces \u00b6 Type Name namespace OpenOasis namespace SystHeats namespace Utils namespace std The documentation for this class was generated from the following file Models/SystHeats/HeatConductionModel/HeatConductionModel.cpp","title":"File HeatConductionModel.cpp"},{"location":"models/_heat_conduction_model_8cpp/#file-heatconductionmodelcpp","text":"FileList > HeatConductionModel > HeatConductionModel.cpp Go to the source code of this file #include \"HeatConductionModel.h\" #include \"Models/CommImp/Arguments.h\" #include \"Models/CommImp/Dimension.h\" #include \"Models/CommImp/Unit.h\" #include \"Models/CommImp/Time.h\" #include \"Models/CommImp/TimeSet.h\" #include \"Models/CommImp/Quantity.h\" #include \"Models/CommImp/ElementSet.h\" #include \"Models/CommImp/ValueSet2D.h\" #include \"Models/CommImp/IO/MeshLoader.h\" #include \"Models/CommImp/Spatial/Grid2D.h\" #include \"Models/CommImp/Numeric/FVM/FvmSolver.h\" #include \"Models/CommImp/Numeric/DirichletBoundary.h\" #include \"Models/Utils/YamlHandler.h\" #include \"Models/Utils/Exception.h\" #include \"Models/Utils/StringHelper.h\" #include \"Models/Utils/FilePathHelper.h\" #include \"Models/Utils/VectorHelper.h\" #include \"Models/Utils/CsvHandler.h\" #include \"ThirdPart/Eigen/IterativeLinearSolvers\" #include <set>","title":"File HeatConductionModel.cpp"},{"location":"models/_heat_conduction_model_8cpp/#namespaces","text":"Type Name namespace OpenOasis namespace SystHeats namespace Utils namespace std The documentation for this class was generated from the following file Models/SystHeats/HeatConductionModel/HeatConductionModel.cpp","title":"Namespaces"},{"location":"models/_heat_conduction_model_8cpp_source/","text":"File HeatConductionModel.cpp \u00b6 File List > HeatConductionModel > HeatConductionModel.cpp Go to the documentation of this file #include \"HeatConductionModel.h\" #include \"Models/CommImp/Arguments.h\" #include \"Models/CommImp/Dimension.h\" #include \"Models/CommImp/Unit.h\" #include \"Models/CommImp/Time.h\" #include \"Models/CommImp/TimeSet.h\" #include \"Models/CommImp/Quantity.h\" #include \"Models/CommImp/ElementSet.h\" #include \"Models/CommImp/ValueSet2D.h\" #include \"Models/CommImp/IO/MeshLoader.h\" #include \"Models/CommImp/Spatial/Grid2D.h\" #include \"Models/CommImp/Numeric/FVM/FvmSolver.h\" #include \"Models/CommImp/Numeric/DirichletBoundary.h\" #include \"Models/Utils/YamlHandler.h\" #include \"Models/Utils/Exception.h\" #include \"Models/Utils/StringHelper.h\" #include \"Models/Utils/FilePathHelper.h\" #include \"Models/Utils/VectorHelper.h\" #include \"Models/Utils/CsvHandler.h\" #include \"ThirdPart/Eigen/IterativeLinearSolvers\" #include <set> namespace OpenOasis :: SystHeats { using namespace CommImp ; using namespace Spatial ; using namespace Numeric ; using namespace Utils ; using namespace IO ; using namespace std ; const vector < string > HeatConductionModel :: sExchangeableStates = { \"temp\" }; const vector < string > HeatConductionModel :: sExchangeableObj = { \"cell\" }; HeatConductionModel :: HeatConductionModel ( const string & id , const string & taskFile ) : LinkableComponent ( id ) { mCaption = \"2D steady heat conduction module\" ; mDescription = \"(more details)\" ; mTaskFile = FilePathHelper :: GetFullPath ( taskFile ); mRequiredArguments . push_back ( \"TaskFile\" ); mArguments [ \"TaskFile\" ] = make_shared < ArgumentString > ( \"TaskFile\" , mTaskFile ); } void HeatConductionModel :: InitializeArguments () { auto taskDir = FilePathHelper :: GetDirectoryName ( mTaskFile ); YamlLoader yml ; yml . LoadByFile ( mTaskFile ); // Check segments. vector < string > segments = { \"OPTION\" , \"MESH\" , \"EQUATION\" , \"INITIALIZATION\" , \"BOUNDARY\" , \"SOLVER\" , \"OUTPUT\" }; auto sections = yml . MapKeys ({}); for ( const auto & seg : segments ) { if ( sections . count ( seg ) == 0 ) { throw FileLoadException ( StringHelper :: FormatSimple ( \"Heat model [{}] missing section [{}].\" , mId , seg )); } } // Global options. string seg = \"OPTION\" ; mStart = yml . GetMapValueInStr ({ seg }, \"start_dt\" ). value (); mEnd = yml . GetMapValueInStr ({ seg }, \"end_dt\" ). value (); auto inputDir = FilePathHelper :: Combine ( taskDir , \"inputs\" ); auto input = yml . GetMapValueInStr ({ seg }, \"input_dir\" ); if ( input . has_value ()) { inputDir = FilePathHelper :: GetFullPath ( input . value ()); } auto outDir = FilePathHelper :: Combine ( taskDir , \"outputs\" ); auto output = yml . GetMapValueInStr ({ seg }, \"output_dir\" ); if ( output . has_value ()) { outDir = FilePathHelper :: GetFullPath ( output . value ()); } // Mesh. seg = \"MESH\" ; auto meshType = yml . GetMapValueInStr ({ seg }, \"mesh_type\" ). value (); auto meshMode = yml . GetMapValueInStr ({ seg }, \"mesh_mode\" ). value (); auto meshDir = FilePathHelper :: Combine ( inputDir , \"mesh\" ); MeshLoader loader ( meshDir ); loader . Load (); mGrid = make_shared < Grid2D > ( loader . GetNodeCoordinates (), loader . GetFaceCoordinates (), loader . GetCellCoordinates (), loader . GetFaceNodes (), loader . GetCellFaces (), loader . GetPatches (), loader . GetZones ()); mSolver = make_shared < FVM :: FvmSolver > ( mGrid ); // Equation. seg = \"EQUATION\" ; auto cSize = yml . SeqSize ({ seg , \"coefficents\" }); for ( int i = 0 ; i < cSize ; i ++ ) { auto coef = yml . GetMapInSeq ({ seg , \"coefficents\" }, i ); if ( coef [ \"var\" ] == \"k\" && coef [ \"mode\" ] == \"uniform\" ) { mK = stod ( coef [ \"value\" ]); } } // Initialization. seg = \"INITIALIZATION\" ; int globalInitSize = yml . SeqSize ({ seg , \"global_inits\" }); for ( int i = 0 ; i < globalInitSize ; i ++ ) { auto init = yml . GetMapInSeq ({ seg , \"global_inits\" }, i ); if ( init [ \"var\" ] == \"temp\" ) { mT0 = stod ( init [ \"value\" ]); break ; } } int localInitSize = yml . SeqSize ({ seg , \"local_inits\" }); for ( int i = 0 ; i < localInitSize ; i ++ ) { auto init = yml . GetMapInSeq ({ seg , \"local_inits\" }, i ); if ( init [ \"var\" ] == \"temp\" && init [ \"mode\" ] == \"file\" ) { mT0file = FilePathHelper :: Combine ( inputDir , init [ \"file\" ]); break ; } } // Boundaries. seg = \"BOUNDARY\" ; int bSize = yml . SeqSize ({ seg , \"boundaries\" }); for ( int i = 0 ; i < bSize ; i ++ ) { auto bound = yml . GetMapInSeq ({ seg , \"boundaries\" }, i ); if ( bound [ \"var\" ] == \"temp\" && bound [ \"type\" ] == \"first\" && bound [ \"mode\" ] == \"constant\" ) { auto patch = bound [ \"patch\" ]; auto value = stod ( bound [ \"value\" ]); mPatchBounds [ \"temp\" ]. insert ({ patch , value }); } } // Sovler. seg = \"SOLVER\" ; auto solverType = yml . GetMapValueInStr ({ seg }, \"solver\" ). value (); mEigenSolver = yml . GetMapValueInStr ({ seg , \"settings\" }, \"eigen_solver\" ). value (); // Output. seg = \"OUTPUT\" ; int oSize = yml . SeqSize ({ seg , \"outputs\" }); for ( int i = 0 ; i < oSize ; i ++ ) { auto out = yml . GetMapInSeq ({ seg , \"outputs\" }, i ); if ( out [ \"var\" ] == \"temp\" && out [ \"fmt\" ] == \"csv\" ) { mOutputVars [ \"temp\" ] = out [ \"fmt\" ]; } } mOutputDir = outDir ; } void HeatConductionModel :: InitializeSpace () { // Initialize grid. mGrid -> Activate (); // Initialize temperature field. auto size = mGrid -> GetNumCells (); mTempValues = make_shared < ScalarFieldFp > ( size , mT0 ); if ( mT0file . empty ()) return ; CsvLoader loader ( mT0file ); auto ids = loader . GetRowLabels (). value (); for ( const auto & id : ids ) { auto idx = stoi ( id ); auto val = loader . GetCell < double > ( 0 , id ). value (); mTempValues -> SetAt ( idx , val ); } } void HeatConductionModel :: InitializeTime () { // To give a time point. mCurrentTime = make_shared < Time > ( DateTime :: FromString ( mStart )); mTimeExtent = make_shared < TimeSet > (); mTimeExtent -> AddTime ( mCurrentTime ); } void HeatConductionModel :: InitializeInputs () { // Don't accept input currently. } void HeatConductionModel :: InitializeOutputs () { const auto & outputters = any_cast < vector < array < string , 3 >>> ( mArguments [ \"OUTPUTTERS\" ] -> GetValue ()); for ( const auto & output : outputters ) { if ( output [ 0 ] != \"CELL\" || output [ 2 ] != \"T\" ) continue ; mOutputs . push_back ( CreateCellOutput ( stoi ( output [ 1 ]), \"T\" )); } } shared_ptr < IOutput > HeatConductionModel :: CreateCellOutput ( int idx , const string & var ) { if ( idx < 0 || idx > mGrid -> GetNumCells ()) { throw invalid_argument ( \"Cell output item out of range.\" ); } auto comp = dynamic_pointer_cast < HeatConductionModel > ( shared_from_this ()); auto cellId = mId + \"_cell_\" + to_string ( idx ); vector < Coordinate > nodes = NodesInCell ( idx ); Element cell ( cellId , \"cell\" , \"\" , nodes ); auto element = make_shared < ElementSet > ( \"HeatConductionModel face\" , \"\" , ElementType :: Polygon , vector < Element > { cell }); auto outputId = StringHelper :: FormatSimple ( \"{}_output_cell_{}_{}\" , mId , var , idx ); mCellOutputs [ outputId ] = idx ; auto output = make_shared < Output > ( outputId , comp ); output -> SetCaption ( \"HeatConductionModel output item\" ); output -> SetDescription ( \"Output exchange item providing temperature data.\" ); output -> SetElementSet ( element ); mOutputs . push_back ( output ); return output ; } vector < Coordinate > HeatConductionModel :: NodesInCell ( int idx ) { set < int > nodeIdxs ; for ( int faceIdx : mGrid -> GetCell ( idx ). faceIndexes ) { for ( int nodeIdx : mGrid -> GetFace ( faceIdx ). nodeIndexes ) { nodeIdxs . emplace ( nodeIdx ); } } vector < Coordinate > nodes ; for ( int i : nodeIdxs ) nodes . push_back ( mGrid -> GetNode ( i ). coor ); return nodes ; } vector < string > HeatConductionModel :: OnValidate () { // No validation check currently. return {}; } void HeatConductionModel :: PrepareInputs () { // pass. } void HeatConductionModel :: PrepareOutputs () { for ( auto & output : mOutputs ) { output -> SetValues ( make_shared < ValueSetFP > ( vector < vector < real >> {{ FP ( mT0 )}}, GetTempQuantity ())); } } shared_ptr < IQuantity > HeatConductionModel :: GetTempQuantity () { auto dime = make_shared < Dimension > (); dime -> SetPower ( DimensionBase :: Temperature , 1 ); auto unit = make_shared < Unit > ( dime , \"temperature\" , \"centigrade(\u2103)\" , 1. , 273.15 ); auto quan = make_unique < Quantity > ( unit , \"temperature\" , \"centigrade(\u2103)\" , -9999. ); return quan ; } void HeatConductionModel :: PullInputs () { // pass. } void HeatConductionModel :: ApplyInputData ( const shared_ptr < IValueSet > & values ) { // pass. } void HeatConductionModel :: UpdateOutputs ( const vector < shared_ptr < IOutput >> & outputs ) { for ( auto & output : outputs ) { const auto & values = output -> GetValues (); double temp = ( * mTempValues )( mCellOutputs [ output -> GetId ()]); values -> SetTimeSeriesValuesForElement ( 0 , { temp }); } } void HeatConductionModel :: PerformTimestep ( const vector < shared_ptr < IOutput >> & outputs ) { const auto & tempBounds = mPatchBounds [ \"temp\" ]; for ( const auto & b : tempBounds ) { real value = FP ( b . second ); const auto & bound = make_shared < DirichletBoundary > ( value ); for ( int fIdx : mGrid -> GetPatchFaceIndexes ( b . first )) { mSolver -> SetBoundary ( fIdx , bound ); } } mSolver -> SetInitialValue ( \"temp\" , variant < real , Vector < real > , Tensor < real >> ( FP ( mT0 ))); mSolver -> SetCoefficient ( \"temp\" , variant < real , Vector < real > , Tensor < real >> ( FP ( - mK ))); mSolver -> ParseDiffusionTerm (); mSolver -> Solve (); const auto & solution = mSolver -> GetScalarSolutions ( \"temp\" ). value (); for ( int i = 0 ; i < ( int ) solution . Size (); i ++ ) mTempValues -> SetAt ( i , solution ( i )); SaveResult (); } // void HeatConductionModel::PerformTimestep(const vector<shared_ptr<IOutput>> &outputs) // { // vector<double> matrix, source; // tie(matrix, source) = GenerateCoeAndSrcMatrix(); // // int size = sqrt(matrix.size()); // // // Solve Ax=b by Eigen. // Eigen::Map<Eigen::MatrixXd> A(matrix.data(), size, size); // // \u586b\u5145A // Eigen::Map<Eigen::VectorXd> b(source.data(), size); // // // \u586b\u5145b // Eigen::ConjugateGradient<Eigen::MatrixXd> solver; // solver.compute(A); // if (solver.info() != Eigen::Success) // { // // \u5206\u89e3\u5931\u8d25 // throw runtime_error(\"compute failed.\"); // } // Eigen::VectorXd x = solver.solve(b); // if (solver.info() != Eigen::Success) // { // // \u89e3\u51b3\u5931\u8d25 // throw runtime_error(\"Solve failed.\"); // } // // vector<double> solution(&x[0], x.data() + x.cols() * x.rows()); // for (int i = 0; i < size; i++) // mTempValues->SetAt(i, solution[i]); // // SaveResult(); // } tuple < vector < real > , vector < real >> HeatConductionModel :: GenerateCoeAndSrcMatrix () { // -Calculate coefficients. real xCoe , yCoe ; tie ( xCoe , yCoe ) = CalculateUniformCoef (); // -All DIRICHLET boundary conditions, use 1-st precision. int size = mGrid -> GetNumCells (); vector < real > matrix ( static_cast < long > ( size ) * size , 0 ); vector < real > source ( size , 0 ); for ( int i = 0 ; i < size ; i ++ ) { matrix [ i * size + i ] = -2. * ( xCoe + yCoe ); const auto & cell = mGrid -> GetCell ( i ); for ( int j : cell . faceIndexes ) { const auto & face = mGrid -> GetFace ( j ); const auto & normal = face . normal ; const auto & cells = face . cellIndexes ; // Face location. bool isEast = ( abs ( normal [ 0 ] - 1.0 ) < 1. e -9 ) ? true : false ; bool isWest = ( abs ( normal [ 0 ] + 1.0 ) < 1. e -9 ) ? true : false ; // bool isNorth = (abs(normal[1] - 1.0) < 1.e-9) ? true : false; // bool isSouth = (abs(normal[1] + 1.0) < 1.e-9) ? true : false; bool isBound = ( cells . size () == 1 ) ? true : false ; // Boundary conditions. if ( isBound ) { real boundT = 0 ; for ( const auto & bound : mPatchBounds [ \"temp\" ]) { const auto & fIdxs = mGrid -> GetPatchFaceIndexes ( bound . first ); if ( find ( fIdxs . begin (), fIdxs . end (), j ) != fIdxs . end ()) { boundT = bound . second ; break ; } } real coe = ( isEast || isWest ) ? xCoe : yCoe ; matrix [ i * size + i ] -= coe ; source [ i ] -= 2. * coe * boundT ; } // interial cell. else { int cIdx = ( cells [ 0 ] == i ) ? cells [ 1 ] : cells [ 0 ]; matrix [ i * size + cIdx ] = ( isEast || isWest ) ? xCoe : yCoe ; } } } return { matrix , source }; } tuple < real , real > HeatConductionModel :: CalculateUniformCoef () { // A uniform rectangular 2d grid has same cell centroid distance at each // direction. real dx = 0 , dy = 0 ; const auto & cell = mGrid -> GetCell ( 0 ); const auto & coor = cell . centroid ; for ( int i : cell . neighbors ) { const auto & _coor = mGrid -> GetCell ( i ). centroid ; real _dx = abs ( _coor . x - coor . x ); real _dy = abs ( _coor . y - coor . y ); dx = max ( dx , _dx ); dy = max ( dy , _dy ); if ( dx > 1. e -10 && dy > 1. e -10 ) break ; } real xCoe = - mK * dy / dx ; real yCoe = - mK * dx / dy ; return { xCoe , yCoe }; } void HeatConductionModel :: SaveResult () { auto file = FilePathHelper :: Combine ( mOutputDir , \"heat_conduction_result.csv\" ); CsvWriter writer ( file ); writer . InsertColumn < Utils :: real > ( 0 , \"temp\" , mTempValues -> Data ()); writer . SetRowLabel ( -1 , \"id\" ); for ( int i = 0 ; i < ( int ) mTempValues -> Size (); i ++ ) writer . SetRowLabel ( i , to_string ( i )); writer . Save (); } bool HeatConductionModel :: IsIterationConverged () const { return true ; } } // namespace OpenOasis::SystHeats","title":"File HeatConductionModel.cpp"},{"location":"models/_heat_conduction_model_8cpp_source/#file-heatconductionmodelcpp","text":"File List > HeatConductionModel > HeatConductionModel.cpp Go to the documentation of this file #include \"HeatConductionModel.h\" #include \"Models/CommImp/Arguments.h\" #include \"Models/CommImp/Dimension.h\" #include \"Models/CommImp/Unit.h\" #include \"Models/CommImp/Time.h\" #include \"Models/CommImp/TimeSet.h\" #include \"Models/CommImp/Quantity.h\" #include \"Models/CommImp/ElementSet.h\" #include \"Models/CommImp/ValueSet2D.h\" #include \"Models/CommImp/IO/MeshLoader.h\" #include \"Models/CommImp/Spatial/Grid2D.h\" #include \"Models/CommImp/Numeric/FVM/FvmSolver.h\" #include \"Models/CommImp/Numeric/DirichletBoundary.h\" #include \"Models/Utils/YamlHandler.h\" #include \"Models/Utils/Exception.h\" #include \"Models/Utils/StringHelper.h\" #include \"Models/Utils/FilePathHelper.h\" #include \"Models/Utils/VectorHelper.h\" #include \"Models/Utils/CsvHandler.h\" #include \"ThirdPart/Eigen/IterativeLinearSolvers\" #include <set> namespace OpenOasis :: SystHeats { using namespace CommImp ; using namespace Spatial ; using namespace Numeric ; using namespace Utils ; using namespace IO ; using namespace std ; const vector < string > HeatConductionModel :: sExchangeableStates = { \"temp\" }; const vector < string > HeatConductionModel :: sExchangeableObj = { \"cell\" }; HeatConductionModel :: HeatConductionModel ( const string & id , const string & taskFile ) : LinkableComponent ( id ) { mCaption = \"2D steady heat conduction module\" ; mDescription = \"(more details)\" ; mTaskFile = FilePathHelper :: GetFullPath ( taskFile ); mRequiredArguments . push_back ( \"TaskFile\" ); mArguments [ \"TaskFile\" ] = make_shared < ArgumentString > ( \"TaskFile\" , mTaskFile ); } void HeatConductionModel :: InitializeArguments () { auto taskDir = FilePathHelper :: GetDirectoryName ( mTaskFile ); YamlLoader yml ; yml . LoadByFile ( mTaskFile ); // Check segments. vector < string > segments = { \"OPTION\" , \"MESH\" , \"EQUATION\" , \"INITIALIZATION\" , \"BOUNDARY\" , \"SOLVER\" , \"OUTPUT\" }; auto sections = yml . MapKeys ({}); for ( const auto & seg : segments ) { if ( sections . count ( seg ) == 0 ) { throw FileLoadException ( StringHelper :: FormatSimple ( \"Heat model [{}] missing section [{}].\" , mId , seg )); } } // Global options. string seg = \"OPTION\" ; mStart = yml . GetMapValueInStr ({ seg }, \"start_dt\" ). value (); mEnd = yml . GetMapValueInStr ({ seg }, \"end_dt\" ). value (); auto inputDir = FilePathHelper :: Combine ( taskDir , \"inputs\" ); auto input = yml . GetMapValueInStr ({ seg }, \"input_dir\" ); if ( input . has_value ()) { inputDir = FilePathHelper :: GetFullPath ( input . value ()); } auto outDir = FilePathHelper :: Combine ( taskDir , \"outputs\" ); auto output = yml . GetMapValueInStr ({ seg }, \"output_dir\" ); if ( output . has_value ()) { outDir = FilePathHelper :: GetFullPath ( output . value ()); } // Mesh. seg = \"MESH\" ; auto meshType = yml . GetMapValueInStr ({ seg }, \"mesh_type\" ). value (); auto meshMode = yml . GetMapValueInStr ({ seg }, \"mesh_mode\" ). value (); auto meshDir = FilePathHelper :: Combine ( inputDir , \"mesh\" ); MeshLoader loader ( meshDir ); loader . Load (); mGrid = make_shared < Grid2D > ( loader . GetNodeCoordinates (), loader . GetFaceCoordinates (), loader . GetCellCoordinates (), loader . GetFaceNodes (), loader . GetCellFaces (), loader . GetPatches (), loader . GetZones ()); mSolver = make_shared < FVM :: FvmSolver > ( mGrid ); // Equation. seg = \"EQUATION\" ; auto cSize = yml . SeqSize ({ seg , \"coefficents\" }); for ( int i = 0 ; i < cSize ; i ++ ) { auto coef = yml . GetMapInSeq ({ seg , \"coefficents\" }, i ); if ( coef [ \"var\" ] == \"k\" && coef [ \"mode\" ] == \"uniform\" ) { mK = stod ( coef [ \"value\" ]); } } // Initialization. seg = \"INITIALIZATION\" ; int globalInitSize = yml . SeqSize ({ seg , \"global_inits\" }); for ( int i = 0 ; i < globalInitSize ; i ++ ) { auto init = yml . GetMapInSeq ({ seg , \"global_inits\" }, i ); if ( init [ \"var\" ] == \"temp\" ) { mT0 = stod ( init [ \"value\" ]); break ; } } int localInitSize = yml . SeqSize ({ seg , \"local_inits\" }); for ( int i = 0 ; i < localInitSize ; i ++ ) { auto init = yml . GetMapInSeq ({ seg , \"local_inits\" }, i ); if ( init [ \"var\" ] == \"temp\" && init [ \"mode\" ] == \"file\" ) { mT0file = FilePathHelper :: Combine ( inputDir , init [ \"file\" ]); break ; } } // Boundaries. seg = \"BOUNDARY\" ; int bSize = yml . SeqSize ({ seg , \"boundaries\" }); for ( int i = 0 ; i < bSize ; i ++ ) { auto bound = yml . GetMapInSeq ({ seg , \"boundaries\" }, i ); if ( bound [ \"var\" ] == \"temp\" && bound [ \"type\" ] == \"first\" && bound [ \"mode\" ] == \"constant\" ) { auto patch = bound [ \"patch\" ]; auto value = stod ( bound [ \"value\" ]); mPatchBounds [ \"temp\" ]. insert ({ patch , value }); } } // Sovler. seg = \"SOLVER\" ; auto solverType = yml . GetMapValueInStr ({ seg }, \"solver\" ). value (); mEigenSolver = yml . GetMapValueInStr ({ seg , \"settings\" }, \"eigen_solver\" ). value (); // Output. seg = \"OUTPUT\" ; int oSize = yml . SeqSize ({ seg , \"outputs\" }); for ( int i = 0 ; i < oSize ; i ++ ) { auto out = yml . GetMapInSeq ({ seg , \"outputs\" }, i ); if ( out [ \"var\" ] == \"temp\" && out [ \"fmt\" ] == \"csv\" ) { mOutputVars [ \"temp\" ] = out [ \"fmt\" ]; } } mOutputDir = outDir ; } void HeatConductionModel :: InitializeSpace () { // Initialize grid. mGrid -> Activate (); // Initialize temperature field. auto size = mGrid -> GetNumCells (); mTempValues = make_shared < ScalarFieldFp > ( size , mT0 ); if ( mT0file . empty ()) return ; CsvLoader loader ( mT0file ); auto ids = loader . GetRowLabels (). value (); for ( const auto & id : ids ) { auto idx = stoi ( id ); auto val = loader . GetCell < double > ( 0 , id ). value (); mTempValues -> SetAt ( idx , val ); } } void HeatConductionModel :: InitializeTime () { // To give a time point. mCurrentTime = make_shared < Time > ( DateTime :: FromString ( mStart )); mTimeExtent = make_shared < TimeSet > (); mTimeExtent -> AddTime ( mCurrentTime ); } void HeatConductionModel :: InitializeInputs () { // Don't accept input currently. } void HeatConductionModel :: InitializeOutputs () { const auto & outputters = any_cast < vector < array < string , 3 >>> ( mArguments [ \"OUTPUTTERS\" ] -> GetValue ()); for ( const auto & output : outputters ) { if ( output [ 0 ] != \"CELL\" || output [ 2 ] != \"T\" ) continue ; mOutputs . push_back ( CreateCellOutput ( stoi ( output [ 1 ]), \"T\" )); } } shared_ptr < IOutput > HeatConductionModel :: CreateCellOutput ( int idx , const string & var ) { if ( idx < 0 || idx > mGrid -> GetNumCells ()) { throw invalid_argument ( \"Cell output item out of range.\" ); } auto comp = dynamic_pointer_cast < HeatConductionModel > ( shared_from_this ()); auto cellId = mId + \"_cell_\" + to_string ( idx ); vector < Coordinate > nodes = NodesInCell ( idx ); Element cell ( cellId , \"cell\" , \"\" , nodes ); auto element = make_shared < ElementSet > ( \"HeatConductionModel face\" , \"\" , ElementType :: Polygon , vector < Element > { cell }); auto outputId = StringHelper :: FormatSimple ( \"{}_output_cell_{}_{}\" , mId , var , idx ); mCellOutputs [ outputId ] = idx ; auto output = make_shared < Output > ( outputId , comp ); output -> SetCaption ( \"HeatConductionModel output item\" ); output -> SetDescription ( \"Output exchange item providing temperature data.\" ); output -> SetElementSet ( element ); mOutputs . push_back ( output ); return output ; } vector < Coordinate > HeatConductionModel :: NodesInCell ( int idx ) { set < int > nodeIdxs ; for ( int faceIdx : mGrid -> GetCell ( idx ). faceIndexes ) { for ( int nodeIdx : mGrid -> GetFace ( faceIdx ). nodeIndexes ) { nodeIdxs . emplace ( nodeIdx ); } } vector < Coordinate > nodes ; for ( int i : nodeIdxs ) nodes . push_back ( mGrid -> GetNode ( i ). coor ); return nodes ; } vector < string > HeatConductionModel :: OnValidate () { // No validation check currently. return {}; } void HeatConductionModel :: PrepareInputs () { // pass. } void HeatConductionModel :: PrepareOutputs () { for ( auto & output : mOutputs ) { output -> SetValues ( make_shared < ValueSetFP > ( vector < vector < real >> {{ FP ( mT0 )}}, GetTempQuantity ())); } } shared_ptr < IQuantity > HeatConductionModel :: GetTempQuantity () { auto dime = make_shared < Dimension > (); dime -> SetPower ( DimensionBase :: Temperature , 1 ); auto unit = make_shared < Unit > ( dime , \"temperature\" , \"centigrade(\u2103)\" , 1. , 273.15 ); auto quan = make_unique < Quantity > ( unit , \"temperature\" , \"centigrade(\u2103)\" , -9999. ); return quan ; } void HeatConductionModel :: PullInputs () { // pass. } void HeatConductionModel :: ApplyInputData ( const shared_ptr < IValueSet > & values ) { // pass. } void HeatConductionModel :: UpdateOutputs ( const vector < shared_ptr < IOutput >> & outputs ) { for ( auto & output : outputs ) { const auto & values = output -> GetValues (); double temp = ( * mTempValues )( mCellOutputs [ output -> GetId ()]); values -> SetTimeSeriesValuesForElement ( 0 , { temp }); } } void HeatConductionModel :: PerformTimestep ( const vector < shared_ptr < IOutput >> & outputs ) { const auto & tempBounds = mPatchBounds [ \"temp\" ]; for ( const auto & b : tempBounds ) { real value = FP ( b . second ); const auto & bound = make_shared < DirichletBoundary > ( value ); for ( int fIdx : mGrid -> GetPatchFaceIndexes ( b . first )) { mSolver -> SetBoundary ( fIdx , bound ); } } mSolver -> SetInitialValue ( \"temp\" , variant < real , Vector < real > , Tensor < real >> ( FP ( mT0 ))); mSolver -> SetCoefficient ( \"temp\" , variant < real , Vector < real > , Tensor < real >> ( FP ( - mK ))); mSolver -> ParseDiffusionTerm (); mSolver -> Solve (); const auto & solution = mSolver -> GetScalarSolutions ( \"temp\" ). value (); for ( int i = 0 ; i < ( int ) solution . Size (); i ++ ) mTempValues -> SetAt ( i , solution ( i )); SaveResult (); } // void HeatConductionModel::PerformTimestep(const vector<shared_ptr<IOutput>> &outputs) // { // vector<double> matrix, source; // tie(matrix, source) = GenerateCoeAndSrcMatrix(); // // int size = sqrt(matrix.size()); // // // Solve Ax=b by Eigen. // Eigen::Map<Eigen::MatrixXd> A(matrix.data(), size, size); // // \u586b\u5145A // Eigen::Map<Eigen::VectorXd> b(source.data(), size); // // // \u586b\u5145b // Eigen::ConjugateGradient<Eigen::MatrixXd> solver; // solver.compute(A); // if (solver.info() != Eigen::Success) // { // // \u5206\u89e3\u5931\u8d25 // throw runtime_error(\"compute failed.\"); // } // Eigen::VectorXd x = solver.solve(b); // if (solver.info() != Eigen::Success) // { // // \u89e3\u51b3\u5931\u8d25 // throw runtime_error(\"Solve failed.\"); // } // // vector<double> solution(&x[0], x.data() + x.cols() * x.rows()); // for (int i = 0; i < size; i++) // mTempValues->SetAt(i, solution[i]); // // SaveResult(); // } tuple < vector < real > , vector < real >> HeatConductionModel :: GenerateCoeAndSrcMatrix () { // -Calculate coefficients. real xCoe , yCoe ; tie ( xCoe , yCoe ) = CalculateUniformCoef (); // -All DIRICHLET boundary conditions, use 1-st precision. int size = mGrid -> GetNumCells (); vector < real > matrix ( static_cast < long > ( size ) * size , 0 ); vector < real > source ( size , 0 ); for ( int i = 0 ; i < size ; i ++ ) { matrix [ i * size + i ] = -2. * ( xCoe + yCoe ); const auto & cell = mGrid -> GetCell ( i ); for ( int j : cell . faceIndexes ) { const auto & face = mGrid -> GetFace ( j ); const auto & normal = face . normal ; const auto & cells = face . cellIndexes ; // Face location. bool isEast = ( abs ( normal [ 0 ] - 1.0 ) < 1. e -9 ) ? true : false ; bool isWest = ( abs ( normal [ 0 ] + 1.0 ) < 1. e -9 ) ? true : false ; // bool isNorth = (abs(normal[1] - 1.0) < 1.e-9) ? true : false; // bool isSouth = (abs(normal[1] + 1.0) < 1.e-9) ? true : false; bool isBound = ( cells . size () == 1 ) ? true : false ; // Boundary conditions. if ( isBound ) { real boundT = 0 ; for ( const auto & bound : mPatchBounds [ \"temp\" ]) { const auto & fIdxs = mGrid -> GetPatchFaceIndexes ( bound . first ); if ( find ( fIdxs . begin (), fIdxs . end (), j ) != fIdxs . end ()) { boundT = bound . second ; break ; } } real coe = ( isEast || isWest ) ? xCoe : yCoe ; matrix [ i * size + i ] -= coe ; source [ i ] -= 2. * coe * boundT ; } // interial cell. else { int cIdx = ( cells [ 0 ] == i ) ? cells [ 1 ] : cells [ 0 ]; matrix [ i * size + cIdx ] = ( isEast || isWest ) ? xCoe : yCoe ; } } } return { matrix , source }; } tuple < real , real > HeatConductionModel :: CalculateUniformCoef () { // A uniform rectangular 2d grid has same cell centroid distance at each // direction. real dx = 0 , dy = 0 ; const auto & cell = mGrid -> GetCell ( 0 ); const auto & coor = cell . centroid ; for ( int i : cell . neighbors ) { const auto & _coor = mGrid -> GetCell ( i ). centroid ; real _dx = abs ( _coor . x - coor . x ); real _dy = abs ( _coor . y - coor . y ); dx = max ( dx , _dx ); dy = max ( dy , _dy ); if ( dx > 1. e -10 && dy > 1. e -10 ) break ; } real xCoe = - mK * dy / dx ; real yCoe = - mK * dx / dy ; return { xCoe , yCoe }; } void HeatConductionModel :: SaveResult () { auto file = FilePathHelper :: Combine ( mOutputDir , \"heat_conduction_result.csv\" ); CsvWriter writer ( file ); writer . InsertColumn < Utils :: real > ( 0 , \"temp\" , mTempValues -> Data ()); writer . SetRowLabel ( -1 , \"id\" ); for ( int i = 0 ; i < ( int ) mTempValues -> Size (); i ++ ) writer . SetRowLabel ( i , to_string ( i )); writer . Save (); } bool HeatConductionModel :: IsIterationConverged () const { return true ; } } // namespace OpenOasis::SystHeats","title":"File HeatConductionModel.cpp"},{"location":"models/_heat_conduction_model_8h/","text":"File HeatConductionModel.h \u00b6 FileList > HeatConductionModel > HeatConductionModel.h Go to the source code of this file #include \"Models/CommImp/LinkableComponent.h\" #include \"Models/CommImp/Output.h\" #include \"Models/CommImp/Input.h\" #include \"Models/CommImp/Spatial/Grid.h\" #include \"Models/CommImp/Numeric/ScalarField.h\" #include \"Models/CommImp/Numeric/Solver.h\" Namespaces \u00b6 Type Name namespace OpenOasis namespace SystHeats Classes \u00b6 Type Name class HeatConductionModel The documentation for this class was generated from the following file Models/SystHeats/HeatConductionModel/HeatConductionModel.h","title":"File HeatConductionModel.h"},{"location":"models/_heat_conduction_model_8h/#file-heatconductionmodelh","text":"FileList > HeatConductionModel > HeatConductionModel.h Go to the source code of this file #include \"Models/CommImp/LinkableComponent.h\" #include \"Models/CommImp/Output.h\" #include \"Models/CommImp/Input.h\" #include \"Models/CommImp/Spatial/Grid.h\" #include \"Models/CommImp/Numeric/ScalarField.h\" #include \"Models/CommImp/Numeric/Solver.h\"","title":"File HeatConductionModel.h"},{"location":"models/_heat_conduction_model_8h/#namespaces","text":"Type Name namespace OpenOasis namespace SystHeats","title":"Namespaces"},{"location":"models/_heat_conduction_model_8h/#classes","text":"Type Name class HeatConductionModel The documentation for this class was generated from the following file Models/SystHeats/HeatConductionModel/HeatConductionModel.h","title":"Classes"},{"location":"models/_heat_conduction_model_8h_source/","text":"File HeatConductionModel.h \u00b6 File List > HeatConductionModel > HeatConductionModel.h Go to the documentation of this file #pragma once #include \"Models/CommImp/LinkableComponent.h\" #include \"Models/CommImp/Output.h\" #include \"Models/CommImp/Input.h\" #include \"Models/CommImp/Spatial/Grid.h\" #include \"Models/CommImp/Numeric/ScalarField.h\" #include \"Models/CommImp/Numeric/Solver.h\" namespace OpenOasis { namespace SystHeats { using CommImp :: LinkableComponent ; using CommImp :: Numeric :: ScalarFieldFp ; using CommImp :: Numeric :: Solver ; using CommImp :: Spatial :: Grid ; using CommImp :: Spatial :: Coordinate ; using Utils :: real ; class HeatConductionModel : public LinkableComponent { private : std :: string mTaskFile ; std :: string mOutputDir ; std :: shared_ptr < Grid > mGrid ; std :: shared_ptr < ScalarFieldFp > mTempValues ; std :: shared_ptr < Solver > mSolver ; real mT0 ; std :: string mT0file ; real mK ; std :: string mStart , mEnd ; std :: string mEigenSolver ; std :: unordered_map < std :: string , std :: string > mOutputVars ; // Each variable boundary conditions defined at the pathes. std :: unordered_map < std :: string , std :: unordered_map < std :: string , double >> mPatchBounds ; std :: vector < std :: string > mBoundPatches ; std :: unordered_map < std :: string , int > mCellOutputs ; static const std :: vector < std :: string > sExchangeableStates ; static const std :: vector < std :: string > sExchangeableObj ; public : HeatConductionModel ( const std :: string & id , const std :: string & taskFile ); virtual ~ HeatConductionModel () = default ; private : void InitializeArguments () override ; void InitializeSpace () override ; void InitializeTime () override ; void InitializeInputs () override ; void InitializeOutputs () override ; std :: vector < std :: string > OnValidate () override ; void PrepareInputs () override ; void PrepareOutputs () override ; void PullInputs () override ; void ApplyInputData ( const std :: shared_ptr < IValueSet > & values ) override ; void UpdateOutputs ( const std :: vector < std :: shared_ptr < IOutput >> & outputs ) override ; void PerformTimestep ( const std :: vector < std :: shared_ptr < IOutput >> & outputs ) override ; bool IsIterationConverged () const override ; private : std :: shared_ptr < IQuantity > GetTempQuantity (); std :: shared_ptr < IOutput > CreateCellOutput ( int idx , const std :: string & var ); std :: vector < Coordinate > NodesInCell ( int idx ); std :: tuple < std :: vector < real > , std :: vector < real >> GenerateCoeAndSrcMatrix (); std :: tuple < real , real > CalculateUniformCoef (); void SaveResult (); }; } // namespace SystHeats } // namespace OpenOasis","title":"File HeatConductionModel.h"},{"location":"models/_heat_conduction_model_8h_source/#file-heatconductionmodelh","text":"File List > HeatConductionModel > HeatConductionModel.h Go to the documentation of this file #pragma once #include \"Models/CommImp/LinkableComponent.h\" #include \"Models/CommImp/Output.h\" #include \"Models/CommImp/Input.h\" #include \"Models/CommImp/Spatial/Grid.h\" #include \"Models/CommImp/Numeric/ScalarField.h\" #include \"Models/CommImp/Numeric/Solver.h\" namespace OpenOasis { namespace SystHeats { using CommImp :: LinkableComponent ; using CommImp :: Numeric :: ScalarFieldFp ; using CommImp :: Numeric :: Solver ; using CommImp :: Spatial :: Grid ; using CommImp :: Spatial :: Coordinate ; using Utils :: real ; class HeatConductionModel : public LinkableComponent { private : std :: string mTaskFile ; std :: string mOutputDir ; std :: shared_ptr < Grid > mGrid ; std :: shared_ptr < ScalarFieldFp > mTempValues ; std :: shared_ptr < Solver > mSolver ; real mT0 ; std :: string mT0file ; real mK ; std :: string mStart , mEnd ; std :: string mEigenSolver ; std :: unordered_map < std :: string , std :: string > mOutputVars ; // Each variable boundary conditions defined at the pathes. std :: unordered_map < std :: string , std :: unordered_map < std :: string , double >> mPatchBounds ; std :: vector < std :: string > mBoundPatches ; std :: unordered_map < std :: string , int > mCellOutputs ; static const std :: vector < std :: string > sExchangeableStates ; static const std :: vector < std :: string > sExchangeableObj ; public : HeatConductionModel ( const std :: string & id , const std :: string & taskFile ); virtual ~ HeatConductionModel () = default ; private : void InitializeArguments () override ; void InitializeSpace () override ; void InitializeTime () override ; void InitializeInputs () override ; void InitializeOutputs () override ; std :: vector < std :: string > OnValidate () override ; void PrepareInputs () override ; void PrepareOutputs () override ; void PullInputs () override ; void ApplyInputData ( const std :: shared_ptr < IValueSet > & values ) override ; void UpdateOutputs ( const std :: vector < std :: shared_ptr < IOutput >> & outputs ) override ; void PerformTimestep ( const std :: vector < std :: shared_ptr < IOutput >> & outputs ) override ; bool IsIterationConverged () const override ; private : std :: shared_ptr < IQuantity > GetTempQuantity (); std :: shared_ptr < IOutput > CreateCellOutput ( int idx , const std :: string & var ); std :: vector < Coordinate > NodesInCell ( int idx ); std :: tuple < std :: vector < real > , std :: vector < real >> GenerateCoeAndSrcMatrix (); std :: tuple < real , real > CalculateUniformCoef (); void SaveResult (); }; } // namespace SystHeats } // namespace OpenOasis","title":"File HeatConductionModel.h"},{"location":"models/namespaces/","text":"Namespace List \u00b6 Here is a list of all namespaces with brief descriptions: namespace DevSupports namespace OpenOasis namespace AdditionalControl namespace CommImp namespace IO namespace Numeric namespace FVM namespace Spatial namespace Temporal namespace SystHeats namespace Utils namespace std","title":"Namespace List"},{"location":"models/namespaces/#namespace-list","text":"Here is a list of all namespaces with brief descriptions: namespace DevSupports namespace OpenOasis namespace AdditionalControl namespace CommImp namespace IO namespace Numeric namespace FVM namespace Spatial namespace Temporal namespace SystHeats namespace Utils namespace std","title":"Namespace List"},{"location":"models/classes/","text":"Class Index \u00b6 b \u00b6 Boundary ( OpenOasis::CommImp::Numeric ) BoundaryCondition ( OpenOasis::CommImp::Numeric ) c \u00b6 Cell ( OpenOasis::CommImp::Spatial ) Coordinate ( OpenOasis::CommImp::Spatial ) d \u00b6 DirichletBoundary ( OpenOasis::CommImp::Numeric ) DoubleSparseMatrix ( OpenOasis::CommImp::Numeric ) e \u00b6 EqualFunc ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) ExchangeItemChangeEventArgs ( OpenOasis ) f \u00b6 Face ( OpenOasis::CommImp::Spatial ) Field ( OpenOasis::CommImp::Numeric ) FvmSolver ( OpenOasis::CommImp::Numeric::FVM ) g \u00b6 GeoCalculator ( OpenOasis::CommImp::Spatial ) Grid ( OpenOasis::CommImp::Spatial ) Grid1D ( OpenOasis::CommImp::Spatial ) Grid2D ( OpenOasis::CommImp::Spatial ) Grid3D ( OpenOasis::CommImp::Spatial ) h \u00b6 HashFunc ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) HeatConductionModel ( OpenOasis::SystHeats ) i \u00b6 IAdaptedOutput ( OpenOasis ) IAdaptedOutputFactory ( OpenOasis ) IArgument ( OpenOasis ) IBaseExchangeItem ( OpenOasis ) IByteStateConverter ( OpenOasis ) ICategory ( OpenOasis ) IComparable ( OpenOasis::AdditionalControl ) IDescribable ( OpenOasis ) IDimension ( OpenOasis ) IElementSet ( OpenOasis ) IIdentifiable ( OpenOasis ) IInput ( OpenOasis ) ILinkableComponent ( OpenOasis ) IManageState ( OpenOasis ) Index ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) IOutput ( OpenOasis ) IQuality ( OpenOasis ) IQuantity ( OpenOasis ) ISpaceExtension ( OpenOasis::AdditionalControl ) ISpatialDefinition ( OpenOasis ) ITime ( OpenOasis ) ITimeExtension ( OpenOasis::AdditionalControl ) ITimeSet ( OpenOasis ) IUnit ( OpenOasis ) IValueDefinition ( OpenOasis ) IValueSet ( OpenOasis ) l \u00b6 Laplacian ( OpenOasis::CommImp::Numeric ) LinkableComponentStatusChangeEventArgs ( OpenOasis ) LinkLoader ( OpenOasis::CommImp::IO ) m \u00b6 Matrix ( OpenOasis::CommImp::Numeric ) Mesh ( OpenOasis::CommImp::Spatial ) MeshLoader ( OpenOasis::CommImp::IO ) n \u00b6 Node ( OpenOasis::CommImp::Spatial ) o \u00b6 Operator ( OpenOasis::CommImp::Numeric ) s \u00b6 ScalarField ( OpenOasis::CommImp::Numeric ) Solver ( OpenOasis::CommImp::Numeric ) Source ( OpenOasis::CommImp::Numeric ) t \u00b6 TaskLoader ( OpenOasis::CommImp::IO ) Tensor ( OpenOasis::CommImp::Numeric ) TensorField ( OpenOasis::CommImp::Numeric ) TimeBuffer ( OpenOasis::CommImp::Temporal ) v \u00b6 Vector ( OpenOasis::CommImp::Numeric ) VectorField ( OpenOasis::CommImp::Numeric ) x \u00b6 XYExtent ( OpenOasis::CommImp::Spatial ) XYGeoTools ( OpenOasis::CommImp::Spatial ) XYLine ( OpenOasis::CommImp::Spatial ) XYPoint ( OpenOasis::CommImp::Spatial ) XYPolygon ( OpenOasis::CommImp::Spatial ) XYPolyline ( OpenOasis::CommImp::Spatial )","title":"Class Index"},{"location":"models/classes/#class-index","text":"","title":"Class Index"},{"location":"models/classes/#b","text":"Boundary ( OpenOasis::CommImp::Numeric ) BoundaryCondition ( OpenOasis::CommImp::Numeric )","title":"b"},{"location":"models/classes/#c","text":"Cell ( OpenOasis::CommImp::Spatial ) Coordinate ( OpenOasis::CommImp::Spatial )","title":"c"},{"location":"models/classes/#d","text":"DirichletBoundary ( OpenOasis::CommImp::Numeric ) DoubleSparseMatrix ( OpenOasis::CommImp::Numeric )","title":"d"},{"location":"models/classes/#e","text":"EqualFunc ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) ExchangeItemChangeEventArgs ( OpenOasis )","title":"e"},{"location":"models/classes/#f","text":"Face ( OpenOasis::CommImp::Spatial ) Field ( OpenOasis::CommImp::Numeric ) FvmSolver ( OpenOasis::CommImp::Numeric::FVM )","title":"f"},{"location":"models/classes/#g","text":"GeoCalculator ( OpenOasis::CommImp::Spatial ) Grid ( OpenOasis::CommImp::Spatial ) Grid1D ( OpenOasis::CommImp::Spatial ) Grid2D ( OpenOasis::CommImp::Spatial ) Grid3D ( OpenOasis::CommImp::Spatial )","title":"g"},{"location":"models/classes/#h","text":"HashFunc ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) HeatConductionModel ( OpenOasis::SystHeats )","title":"h"},{"location":"models/classes/#i","text":"IAdaptedOutput ( OpenOasis ) IAdaptedOutputFactory ( OpenOasis ) IArgument ( OpenOasis ) IBaseExchangeItem ( OpenOasis ) IByteStateConverter ( OpenOasis ) ICategory ( OpenOasis ) IComparable ( OpenOasis::AdditionalControl ) IDescribable ( OpenOasis ) IDimension ( OpenOasis ) IElementSet ( OpenOasis ) IIdentifiable ( OpenOasis ) IInput ( OpenOasis ) ILinkableComponent ( OpenOasis ) IManageState ( OpenOasis ) Index ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) IOutput ( OpenOasis ) IQuality ( OpenOasis ) IQuantity ( OpenOasis ) ISpaceExtension ( OpenOasis::AdditionalControl ) ISpatialDefinition ( OpenOasis ) ITime ( OpenOasis ) ITimeExtension ( OpenOasis::AdditionalControl ) ITimeSet ( OpenOasis ) IUnit ( OpenOasis ) IValueDefinition ( OpenOasis ) IValueSet ( OpenOasis )","title":"i"},{"location":"models/classes/#l","text":"Laplacian ( OpenOasis::CommImp::Numeric ) LinkableComponentStatusChangeEventArgs ( OpenOasis ) LinkLoader ( OpenOasis::CommImp::IO )","title":"l"},{"location":"models/classes/#m","text":"Matrix ( OpenOasis::CommImp::Numeric ) Mesh ( OpenOasis::CommImp::Spatial ) MeshLoader ( OpenOasis::CommImp::IO )","title":"m"},{"location":"models/classes/#n","text":"Node ( OpenOasis::CommImp::Spatial )","title":"n"},{"location":"models/classes/#o","text":"Operator ( OpenOasis::CommImp::Numeric )","title":"o"},{"location":"models/classes/#s","text":"ScalarField ( OpenOasis::CommImp::Numeric ) Solver ( OpenOasis::CommImp::Numeric ) Source ( OpenOasis::CommImp::Numeric )","title":"s"},{"location":"models/classes/#t","text":"TaskLoader ( OpenOasis::CommImp::IO ) Tensor ( OpenOasis::CommImp::Numeric ) TensorField ( OpenOasis::CommImp::Numeric ) TimeBuffer ( OpenOasis::CommImp::Temporal )","title":"t"},{"location":"models/classes/#v","text":"Vector ( OpenOasis::CommImp::Numeric ) VectorField ( OpenOasis::CommImp::Numeric )","title":"v"},{"location":"models/classes/#x","text":"XYExtent ( OpenOasis::CommImp::Spatial ) XYGeoTools ( OpenOasis::CommImp::Spatial ) XYLine ( OpenOasis::CommImp::Spatial ) XYPoint ( OpenOasis::CommImp::Spatial ) XYPolygon ( OpenOasis::CommImp::Spatial ) XYPolyline ( OpenOasis::CommImp::Spatial )","title":"x"},{"location":"models/hierarchy/","text":"Class Hierarchy \u00b6 This inheritance list is sorted roughly, but not completely, alphabetically: class OpenOasis::AdditionalControl::IComparable Interface class provides a unified interface for object comparison. class OpenOasis::AdditionalControl::ISpaceExtension class OpenOasis::AdditionalControl::ITimeExtension Methods that are specific for a time-space component. class OpenOasis::CommImp::IO::LinkLoader Class forLoading components coupling configurations json file. class OpenOasis::CommImp::IO::MeshLoader Default Mesh data loader. class OpenOasis::CommImp::IO::TaskLoader Loading components task configurations yaml file. class OpenOasis::CommImp::Numeric::Boundary Abstract boundary class. class OpenOasis::CommImp::Numeric::DirichletBoundary Dirichlet boundary. class OpenOasis::CommImp::Numeric::DoubleSparseMatrix Sparse matrix having double elements. class OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index class OpenOasis::CommImp::Numeric::Solver Abstract solver class. class OpenOasis::CommImp::Numeric::FVM::FvmSolver class OpenOasis::CommImp::Numeric::Field The abstract field class used to represent numeric field, such as scalar, vector or tensor data. class OpenOasis::CommImp::Numeric::ScalarField Scaler field. class OpenOasis::CommImp::Numeric::ScalarField Scaler field. class OpenOasis::CommImp::Numeric::VectorField Vector field with default zero vector in 2D or 3D space. class OpenOasis::CommImp::Numeric::Operator Abstract operator class. class OpenOasis::CommImp::Numeric::Laplacian Laplacian operator for the divergence of the gradient of a scalar field. class OpenOasis::CommImp::Numeric::Matrix class OpenOasis::CommImp::Numeric::Source class OpenOasis::CommImp::Numeric::Tensor class OpenOasis::CommImp::Numeric::Vector class OpenOasis::CommImp::Spatial::GeoCalculator The GeoCalculator is a collection of general geometry functions. class OpenOasis::CommImp::Spatial::Grid Grid encapsulate the mesh data for numerical calculation. class OpenOasis::CommImp::Spatial::Grid1D class OpenOasis::CommImp::Spatial::Grid2D Grid formed by flat cells in 2d. class OpenOasis::CommImp::Spatial::Grid3D class OpenOasis::CommImp::Spatial::XYGeoTools The XYGeoTools class is a collection of general geometry functions. class OpenOasis::CommImp::Temporal::TimeBuffer The TimeBuffer class provides temporal buffering functionality. class OpenOasis::ExchangeItemChangeEventArgs Class containing the information that will be passed when firing an ExchangeItemValueChanged event. class OpenOasis::IDescribable An entity that is describable has a caption (title or heading) and a description. These are not to be used for identification. class OpenOasis::ICategory Class describes one item of a possible categorization. class OpenOasis::IIdentifiable To define a method to get the Id of an OpenOasis entity. class OpenOasis::IAdaptedOutputFactory Factory class for creating instances of IAdaptedOutput items. class OpenOasis::IArgument Class for providing arguments for an ILinkableComponent and others. class OpenOasis::IBaseExchangeItem Class presenting a item that can be exchanged, either as an input or output. class OpenOasis::IInput An input item that can accept values for an ILinkableComponent . The input item may have multiple providers. class OpenOasis::IOutput Output exchange item that can deliver values from an ILinkableComponent . class OpenOasis::IAdaptedOutput Extension class for adding data operations on top of an output item. class OpenOasis::ILinkableComponent The key interface class for linkable modules connection and data transfer. class OpenOasis::ISpatialDefinition General spatial construct that all other spatial constructions extend from. class OpenOasis::IElementSet An list of elements having a common type. class OpenOasis::IUnit Unit interface describes the physical unit. class OpenOasis::IValueDefinition Class describes value definition. class OpenOasis::IQuality Class describes qualitative data, where a value is specified as one category within a number of predefined (possible) categories. class OpenOasis::IQuantity Class specifies values as an amount of some unit. class OpenOasis::IByteStateConverter An optional interface to save and transform the model state. class OpenOasis::IDimension Define the order of each dimension in DimensionBase for a unit. class OpenOasis::IManageState It provides additional methods for handling component state so it can be saved, restored and cleared. class OpenOasis::ITime Time interface to support a time stamp as well as a time interval. class OpenOasis::ITimeSet Set of time stamps or time intervals, used to indicate when an output has and can provide values, and when an input item does or may require values. class OpenOasis::IValueSet Class represents a general(ordered) multi-dimensional set of values. class OpenOasis::LinkableComponentStatusChangeEventArgs Class contains the information that will be passed when the ILinkableComponent fires the StatusChanged event. struct OpenOasis::CommImp::Numeric::BoundaryCondition Boundary condition struct. struct OpenOasis::CommImp::Numeric::DoubleSparseMatrix::EqualFunc struct OpenOasis::CommImp::Numeric::DoubleSparseMatrix::HashFunc struct OpenOasis::CommImp::Spatial::Cell Mesh cell data structure. Polygon type for 1D and 2D mesh, Polyhedron type for 3D mesh. struct OpenOasis::CommImp::Spatial::Coordinate The Coordinate struct contains a (x, y, z) coordinate. struct OpenOasis::CommImp::Spatial::Face Mesh face data structure. Polyline type for 1D or 2D mesh, Polygon type for 3D mesh. struct OpenOasis::CommImp::Spatial::Mesh Mesh structure. struct OpenOasis::CommImp::Spatial::Node Mesh node data structure. (Point type). struct OpenOasis::CommImp::Spatial::XYExtent Extent is a rectangle in xy-space. struct OpenOasis::CommImp::Spatial::XYLine The XYline struct is used for representing a line segment. struct OpenOasis::CommImp::Spatial::XYPoint XYPoint is simply a x and y coordinate point (has no z coordinate). struct OpenOasis::CommImp::Spatial::XYPolygon The XYPolygon struct defines a polygon in the XY plane (no z coordinate). struct OpenOasis::CommImp::Spatial::XYPolyline XYPolyline is a collection of points (at least 2) connected with straigth lines. XYPolylines are typically used for presentation of 1D data, river network. class LinkableComponent class OpenOasis::SystHeats::HeatConductionModel","title":"Class Hierarchy"},{"location":"models/hierarchy/#class-hierarchy","text":"This inheritance list is sorted roughly, but not completely, alphabetically: class OpenOasis::AdditionalControl::IComparable Interface class provides a unified interface for object comparison. class OpenOasis::AdditionalControl::ISpaceExtension class OpenOasis::AdditionalControl::ITimeExtension Methods that are specific for a time-space component. class OpenOasis::CommImp::IO::LinkLoader Class forLoading components coupling configurations json file. class OpenOasis::CommImp::IO::MeshLoader Default Mesh data loader. class OpenOasis::CommImp::IO::TaskLoader Loading components task configurations yaml file. class OpenOasis::CommImp::Numeric::Boundary Abstract boundary class. class OpenOasis::CommImp::Numeric::DirichletBoundary Dirichlet boundary. class OpenOasis::CommImp::Numeric::DoubleSparseMatrix Sparse matrix having double elements. class OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index class OpenOasis::CommImp::Numeric::Solver Abstract solver class. class OpenOasis::CommImp::Numeric::FVM::FvmSolver class OpenOasis::CommImp::Numeric::Field The abstract field class used to represent numeric field, such as scalar, vector or tensor data. class OpenOasis::CommImp::Numeric::ScalarField Scaler field. class OpenOasis::CommImp::Numeric::ScalarField Scaler field. class OpenOasis::CommImp::Numeric::VectorField Vector field with default zero vector in 2D or 3D space. class OpenOasis::CommImp::Numeric::Operator Abstract operator class. class OpenOasis::CommImp::Numeric::Laplacian Laplacian operator for the divergence of the gradient of a scalar field. class OpenOasis::CommImp::Numeric::Matrix class OpenOasis::CommImp::Numeric::Source class OpenOasis::CommImp::Numeric::Tensor class OpenOasis::CommImp::Numeric::Vector class OpenOasis::CommImp::Spatial::GeoCalculator The GeoCalculator is a collection of general geometry functions. class OpenOasis::CommImp::Spatial::Grid Grid encapsulate the mesh data for numerical calculation. class OpenOasis::CommImp::Spatial::Grid1D class OpenOasis::CommImp::Spatial::Grid2D Grid formed by flat cells in 2d. class OpenOasis::CommImp::Spatial::Grid3D class OpenOasis::CommImp::Spatial::XYGeoTools The XYGeoTools class is a collection of general geometry functions. class OpenOasis::CommImp::Temporal::TimeBuffer The TimeBuffer class provides temporal buffering functionality. class OpenOasis::ExchangeItemChangeEventArgs Class containing the information that will be passed when firing an ExchangeItemValueChanged event. class OpenOasis::IDescribable An entity that is describable has a caption (title or heading) and a description. These are not to be used for identification. class OpenOasis::ICategory Class describes one item of a possible categorization. class OpenOasis::IIdentifiable To define a method to get the Id of an OpenOasis entity. class OpenOasis::IAdaptedOutputFactory Factory class for creating instances of IAdaptedOutput items. class OpenOasis::IArgument Class for providing arguments for an ILinkableComponent and others. class OpenOasis::IBaseExchangeItem Class presenting a item that can be exchanged, either as an input or output. class OpenOasis::IInput An input item that can accept values for an ILinkableComponent . The input item may have multiple providers. class OpenOasis::IOutput Output exchange item that can deliver values from an ILinkableComponent . class OpenOasis::IAdaptedOutput Extension class for adding data operations on top of an output item. class OpenOasis::ILinkableComponent The key interface class for linkable modules connection and data transfer. class OpenOasis::ISpatialDefinition General spatial construct that all other spatial constructions extend from. class OpenOasis::IElementSet An list of elements having a common type. class OpenOasis::IUnit Unit interface describes the physical unit. class OpenOasis::IValueDefinition Class describes value definition. class OpenOasis::IQuality Class describes qualitative data, where a value is specified as one category within a number of predefined (possible) categories. class OpenOasis::IQuantity Class specifies values as an amount of some unit. class OpenOasis::IByteStateConverter An optional interface to save and transform the model state. class OpenOasis::IDimension Define the order of each dimension in DimensionBase for a unit. class OpenOasis::IManageState It provides additional methods for handling component state so it can be saved, restored and cleared. class OpenOasis::ITime Time interface to support a time stamp as well as a time interval. class OpenOasis::ITimeSet Set of time stamps or time intervals, used to indicate when an output has and can provide values, and when an input item does or may require values. class OpenOasis::IValueSet Class represents a general(ordered) multi-dimensional set of values. class OpenOasis::LinkableComponentStatusChangeEventArgs Class contains the information that will be passed when the ILinkableComponent fires the StatusChanged event. struct OpenOasis::CommImp::Numeric::BoundaryCondition Boundary condition struct. struct OpenOasis::CommImp::Numeric::DoubleSparseMatrix::EqualFunc struct OpenOasis::CommImp::Numeric::DoubleSparseMatrix::HashFunc struct OpenOasis::CommImp::Spatial::Cell Mesh cell data structure. Polygon type for 1D and 2D mesh, Polyhedron type for 3D mesh. struct OpenOasis::CommImp::Spatial::Coordinate The Coordinate struct contains a (x, y, z) coordinate. struct OpenOasis::CommImp::Spatial::Face Mesh face data structure. Polyline type for 1D or 2D mesh, Polygon type for 3D mesh. struct OpenOasis::CommImp::Spatial::Mesh Mesh structure. struct OpenOasis::CommImp::Spatial::Node Mesh node data structure. (Point type). struct OpenOasis::CommImp::Spatial::XYExtent Extent is a rectangle in xy-space. struct OpenOasis::CommImp::Spatial::XYLine The XYline struct is used for representing a line segment. struct OpenOasis::CommImp::Spatial::XYPoint XYPoint is simply a x and y coordinate point (has no z coordinate). struct OpenOasis::CommImp::Spatial::XYPolygon The XYPolygon struct defines a polygon in the XY plane (no z coordinate). struct OpenOasis::CommImp::Spatial::XYPolyline XYPolyline is a collection of points (at least 2) connected with straigth lines. XYPolylines are typically used for presentation of 1D data, river network. class LinkableComponent class OpenOasis::SystHeats::HeatConductionModel","title":"Class Hierarchy"},{"location":"models/modules/","text":"Modules \u00b6 No modules found.","title":"Modules"},{"location":"models/modules/#modules","text":"No modules found.","title":"Modules"},{"location":"models/pages/","text":"Related Pages \u00b6 Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"models/pages/#related-pages","text":"Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"models/class_members/","text":"Class Members \u00b6 a \u00b6 At ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) Add ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Adjoint ( OpenOasis::CommImp::Numeric::Matrix ) AfterScheme ( OpenOasis::CommImp::Numeric::Solver ) AfterSolve ( OpenOasis::CommImp::Numeric::Solver ) AbsMax ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) AbsMin ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Avg ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) area ( OpenOasis::CommImp::Spatial::Face ) Activate ( OpenOasis::CommImp::Spatial::Grid ) AddValues ( OpenOasis::CommImp::Temporal::TimeBuffer ) AddValuesToBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer ) AddListener ( OpenOasis::IBaseExchangeItem , OpenOasis::ILinkableComponent ) AddProvider ( OpenOasis::IInput ) AddAdaptedOutput ( OpenOasis::IOutput ) AddConsumer ( OpenOasis::IOutput ) AddTime ( OpenOasis::ITimeSet ) ApplyInputData ( OpenOasis::SystHeats::HeatConductionModel ) b \u00b6 BeforeScheme ( OpenOasis::CommImp::Numeric::Solver ) BeforeSolve ( OpenOasis::CommImp::Numeric::Solver ) c \u00b6 CompareTo ( OpenOasis::AdditionalControl::IComparable ) CollectExchangeItemMap ( OpenOasis::CommImp::IO::LinkLoader ) CollectIteratorGroups ( OpenOasis::CommImp::IO::LinkLoader ) ComponentInfo ( OpenOasis::CommImp::IO::LinkLoader ) CheckIds ( OpenOasis::CommImp::IO::MeshLoader ) Clean ( OpenOasis::CommImp::Numeric::Field ) Clear ( OpenOasis::CommImp::Numeric::Field ) Cols ( OpenOasis::CommImp::Numeric::Matrix ) Cross ( OpenOasis::CommImp::Numeric::Vector ) centroid ( OpenOasis::CommImp::Spatial::Cell , OpenOasis::CommImp::Spatial::Face ) cellIndexes ( OpenOasis::CommImp::Spatial::Face , OpenOasis::CommImp::Spatial::Node ) cellSides ( OpenOasis::CommImp::Spatial::Face ) CalculateArea ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateCellCentroid ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateCellVolume ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateCentroid ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateFaceArea ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateFaceCentroid ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateFaceNormal ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateFacePerimeter ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateLength ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateNormal ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateVolume ( OpenOasis::CommImp::Spatial::GeoCalculator ) ChooseFoldedAxis ( OpenOasis::CommImp::Spatial::GeoCalculator ) CompareNodeOrder ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateBoundaryCenterDistances ( OpenOasis::CommImp::Spatial::Grid ) CalculateCellDistances ( OpenOasis::CommImp::Spatial::Grid ) CalculateCellSurface ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateDistance ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceCorrectionVector ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceDirector ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceIntersections ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceWeights ( OpenOasis::CommImp::Spatial::Grid ) CheckMesh ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CollectBoundaryFacesAndCells ( OpenOasis::CommImp::Spatial::Grid ) CollectCellNeighbors ( OpenOasis::CommImp::Spatial::Grid ) CollectCellsInZone ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CollectCellsSharedFace ( OpenOasis::CommImp::Spatial::Grid ) CollectCellsSharedNode ( OpenOasis::CommImp::Spatial::Grid ) CollectFacesSharedNode ( OpenOasis::CommImp::Spatial::Grid ) cells ( OpenOasis::CommImp::Spatial::Mesh ) coor ( OpenOasis::CommImp::Spatial::Node ) CalculateIntersectionPoint ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateLengthOfLineInsidePolygon ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateLengthOfPolylineInsidePolygon ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateLineToPointDistance ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateMidpoint ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculatePointToPointDistance ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculatePolylineToPointDistance ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateSharedArea ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateSharedLength ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateTriangleSharedArea ( OpenOasis::CommImp::Spatial::XYGeoTools ) CheckBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer ) ClearAfter ( OpenOasis::CommImp::Temporal::TimeBuffer ) ClearBefore ( OpenOasis::CommImp::Temporal::TimeBuffer ) Create ( OpenOasis::CommImp::Temporal::TimeBuffer ) CreateAdaptedOutput ( OpenOasis::IAdaptedOutputFactory ) ConvertFromByteStream ( OpenOasis::IByteStateConverter ) ConvertToByteStream ( OpenOasis::IByteStateConverter ) ClearState ( OpenOasis::IManageState ) CalculateUniformCoef ( OpenOasis::SystHeats::HeatConductionModel ) CreateCellOutput ( OpenOasis::SystHeats::HeatConductionModel ) d \u00b6 DirichletBoundary ( OpenOasis::CommImp::Numeric::DirichletBoundary ) DoubleSparseMatrix ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) Data ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix ) Discretize ( OpenOasis::CommImp::Numeric::Laplacian , OpenOasis::CommImp::Numeric::Operator ) Determinant ( OpenOasis::CommImp::Numeric::Matrix ) Diagonal ( OpenOasis::CommImp::Numeric::Matrix ) DDot ( OpenOasis::CommImp::Numeric::Tensor ) Div ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Dot ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Dyadic ( OpenOasis::CommImp::Numeric::Vector ) DecrementModula ( OpenOasis::CommImp::Spatial::XYGeoTools ) e \u00b6 ElementInfo ( OpenOasis::CommImp::IO::LinkLoader ) Equals ( OpenOasis::CommImp::Spatial::Coordinate ) EPSILON ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::XYGeoTools ) f \u00b6 flux ( OpenOasis::CommImp::Numeric::BoundaryCondition ) FvmSolver ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) Field ( OpenOasis::CommImp::Numeric::Field ) ForEach ( OpenOasis::CommImp::Numeric::Field ) faceIndexes ( OpenOasis::CommImp::Spatial::Cell , OpenOasis::CommImp::Spatial::Node ) faces ( OpenOasis::CommImp::Spatial::Mesh ) FindTrianglePoints ( OpenOasis::CommImp::Spatial::XYGeoTools ) Finish ( OpenOasis::ILinkableComponent ) g \u00b6 GetSpatialDefinition ( OpenOasis::AdditionalControl::ISpaceExtension ) GetCurrTime ( OpenOasis::AdditionalControl::ITimeExtension ) GetTimeExtent ( OpenOasis::AdditionalControl::ITimeExtension ) GenerateUniqueElementId ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentIds ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentInfo ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentInputs ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentOutputs ( OpenOasis::CommImp::IO::LinkLoader ) GetInputProviders ( OpenOasis::CommImp::IO::LinkLoader ) GetIteratorConfigs ( OpenOasis::CommImp::IO::LinkLoader ) GetIteratorGroups ( OpenOasis::CommImp::IO::LinkLoader ) GetOutputConsumers ( OpenOasis::CommImp::IO::LinkLoader ) GenerateCellCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GenerateFaceCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetCellCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetCellFaces ( OpenOasis::CommImp::IO::MeshLoader ) GetFaceCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetFaceNodes ( OpenOasis::CommImp::IO::MeshLoader ) GetNodeCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetPatches ( OpenOasis::CommImp::IO::MeshLoader ) GetZones ( OpenOasis::CommImp::IO::MeshLoader ) GetBoundaryCondition ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) GetType ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) GetColumnCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) GetRowCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) GetScalarSolutions ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) GetLinearEqs ( OpenOasis::CommImp::Numeric::Solver ) GetTensorSolutions ( OpenOasis::CommImp::Numeric::Solver ) GetVectorSolutions ( OpenOasis::CommImp::Numeric::Solver ) GetSource ( OpenOasis::CommImp::Numeric::Source ) GetCellNodeIndexes ( OpenOasis::CommImp::Spatial::GeoCalculator ) GetBoundaryCellIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetBoundaryCenterDistance ( OpenOasis::CommImp::Spatial::Grid ) GetBoundaryCenterDistances ( OpenOasis::CommImp::Spatial::Grid ) GetBoundaryFaceIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetCell ( OpenOasis::CommImp::Spatial::Grid ) GetCellCenterDistance ( OpenOasis::CommImp::Spatial::Grid ) GetCellCenterDistances ( OpenOasis::CommImp::Spatial::Grid ) GetCellWeightAtFace ( OpenOasis::CommImp::Spatial::Grid ) GetFace ( OpenOasis::CommImp::Spatial::Grid ) GetFaceCorrectionVector ( OpenOasis::CommImp::Spatial::Grid ) GetNode ( OpenOasis::CommImp::Spatial::Grid ) GetNumCells ( OpenOasis::CommImp::Spatial::Grid ) GetNumFaces ( OpenOasis::CommImp::Spatial::Grid ) GetNumNodes ( OpenOasis::CommImp::Spatial::Grid ) GetPatchFaceIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetPatchIds ( OpenOasis::CommImp::Spatial::Grid ) GetRawNumCells ( OpenOasis::CommImp::Spatial::Grid ) GetRawNumFaces ( OpenOasis::CommImp::Spatial::Grid ) GetRawNumNodes ( OpenOasis::CommImp::Spatial::Grid ) GetZoneCellIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetZoneIds ( OpenOasis::CommImp::Spatial::Grid ) Grid ( OpenOasis::CommImp::Spatial::Grid ) Grid1D ( OpenOasis::CommImp::Spatial::Grid1D ) Grid2D ( OpenOasis::CommImp::Spatial::Grid2D ) Grid3D ( OpenOasis::CommImp::Spatial::Grid3D ) GetTriangulations ( OpenOasis::CommImp::Spatial::XYGeoTools ) GetLength ( OpenOasis::CommImp::Spatial::XYLine , OpenOasis::CommImp::Spatial::XYPolyline ) GetArea ( OpenOasis::CommImp::Spatial::XYPolygon ) GetLine ( OpenOasis::CommImp::Spatial::XYPolygon , OpenOasis::CommImp::Spatial::XYPolyline ) GetAllValues ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetDoExtendedDataVerification ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetDoExtrapolate ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetRelaxationFactor ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetTimeAt ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetTimeSet ( OpenOasis::CommImp::Temporal::TimeBuffer , OpenOasis::IBaseExchangeItem ) GetTimesCount ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetValueSet ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetValues ( OpenOasis::CommImp::Temporal::TimeBuffer , OpenOasis::IBaseExchangeItem ) GetValuesAt ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetValuesCount ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetExchangeItem ( OpenOasis::ExchangeItemChangeEventArgs ) GetMessages ( OpenOasis::ExchangeItemChangeEventArgs , OpenOasis::LinkableComponentStatusChangeEventArgs ) GetAdaptee ( OpenOasis::IAdaptedOutput ) GetArguments ( OpenOasis::IAdaptedOutput , OpenOasis::ILinkableComponent ) GetAvailableAdaptedOutputIds ( OpenOasis::IAdaptedOutputFactory ) GetDefaultValue ( OpenOasis::IArgument ) GetPossibleValues ( OpenOasis::IArgument ) GetValue ( OpenOasis::IArgument , OpenOasis::ICategory , OpenOasis::IValueSet ) GetValueType ( OpenOasis::IArgument , OpenOasis::IValueDefinition ) GetComponent ( OpenOasis::IBaseExchangeItem ) GetElementSet ( OpenOasis::IBaseExchangeItem ) GetValueDefinition ( OpenOasis::IBaseExchangeItem , OpenOasis::IValueSet ) GetCaption ( OpenOasis::IDescribable ) GetDescription ( OpenOasis::IDescribable ) GetPower ( OpenOasis::IDimension ) GetElementId ( OpenOasis::IElementSet ) GetElementIndex ( OpenOasis::IElementSet ) GetElementType ( OpenOasis::IElementSet ) GetFaceCount ( OpenOasis::IElementSet ) GetFaceNodeIndices ( OpenOasis::IElementSet ) GetNodeCount ( OpenOasis::IElementSet ) GetNodeXCoordinate ( OpenOasis::IElementSet ) GetNodeYCoordinate ( OpenOasis::IElementSet ) GetNodeZCoordinate ( OpenOasis::IElementSet ) GetId ( OpenOasis::IIdentifiable ) GetProviders ( OpenOasis::IInput ) GetAdaptedOutputFactories ( OpenOasis::ILinkableComponent ) GetInputs ( OpenOasis::ILinkableComponent ) GetOutputs ( OpenOasis::ILinkableComponent ) GetStatus ( OpenOasis::ILinkableComponent ) GetAdaptedOutputs ( OpenOasis::IOutput ) GetConsumers ( OpenOasis::IOutput ) GetCategories ( OpenOasis::IQuality ) GetUnit ( OpenOasis::IQuantity ) GetElementCount ( OpenOasis::ISpatialDefinition ) GetSpatialReferenceSystem ( OpenOasis::ISpatialDefinition ) GetVersion ( OpenOasis::ISpatialDefinition ) GetDurationInDays ( OpenOasis::ITime ) GetTimeStamp ( OpenOasis::ITime ) GetOffsetFromUtcInHours ( OpenOasis::ITimeSet ) GetTimeHorizon ( OpenOasis::ITimeSet ) GetTimes ( OpenOasis::ITimeSet ) GetConversionFactorToSI ( OpenOasis::IUnit ) GetDimension ( OpenOasis::IUnit ) GetOffSetToSI ( OpenOasis::IUnit ) GetMissingDataValue ( OpenOasis::IValueDefinition ) GetElementValuesForTime ( OpenOasis::IValueSet ) GetIndexCount ( OpenOasis::IValueSet ) GetNumberOfIndices ( OpenOasis::IValueSet ) GetTimeSeriesValuesForElement ( OpenOasis::IValueSet ) GetLinkableComponent ( OpenOasis::LinkableComponentStatusChangeEventArgs ) GetNewStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) GetOldStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) GenerateCoeAndSrcMatrix ( OpenOasis::SystHeats::HeatConductionModel ) GetTempQuantity ( OpenOasis::SystHeats::HeatConductionModel ) h \u00b6 HasDurations ( OpenOasis::ITimeSet ) HeatConductionModel ( OpenOasis::SystHeats::HeatConductionModel ) i \u00b6 IsCellEmpty ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) Index ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index ) Initialize ( OpenOasis::CommImp::Numeric::Field , OpenOasis::IAdaptedOutput , OpenOasis::ILinkableComponent ) Invert ( OpenOasis::CommImp::Numeric::Matrix ) IsEqual ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Include ( OpenOasis::CommImp::Spatial::XYExtent ) IsContains ( OpenOasis::CommImp::Spatial::XYExtent ) IsOverlaps ( OpenOasis::CommImp::Spatial::XYExtent ) IncrementModula ( OpenOasis::CommImp::Spatial::XYGeoTools ) Intersect ( OpenOasis::CommImp::Spatial::XYGeoTools ) IntersectionPoint ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsLinesIntersected ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsPointInLine ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsPointInLineInterior ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsPointInPolygon ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsTriangleIntersected ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsConvex ( OpenOasis::CommImp::Spatial::XYPolygon ) IsOptional ( OpenOasis::IArgument ) IsReadOnly ( OpenOasis::IArgument ) IsOrdered ( OpenOasis::IQuality ) IsValues2D ( OpenOasis::IValueSet ) InitializeArguments ( OpenOasis::SystHeats::HeatConductionModel ) InitializeInputs ( OpenOasis::SystHeats::HeatConductionModel ) InitializeOutputs ( OpenOasis::SystHeats::HeatConductionModel ) InitializeSpace ( OpenOasis::SystHeats::HeatConductionModel ) InitializeTime ( OpenOasis::SystHeats::HeatConductionModel ) IsIterationConverged ( OpenOasis::SystHeats::HeatConductionModel ) k \u00b6 KeepCurrentState ( OpenOasis::IManageState ) l \u00b6 LinkLoader ( OpenOasis::CommImp::IO::LinkLoader ) Load ( OpenOasis::CommImp::IO::LinkLoader , OpenOasis::CommImp::IO::MeshLoader ) LoadComponents ( OpenOasis::CommImp::IO::LinkLoader ) LoadLinks ( OpenOasis::CommImp::IO::LinkLoader ) LoadPipeline ( OpenOasis::CommImp::IO::LinkLoader ) LoadCells ( OpenOasis::CommImp::IO::MeshLoader ) LoadFaces ( OpenOasis::CommImp::IO::MeshLoader ) LoadNodes ( OpenOasis::CommImp::IO::MeshLoader ) LoadPatches ( OpenOasis::CommImp::IO::MeshLoader ) LoadZones ( OpenOasis::CommImp::IO::MeshLoader ) Laplacian ( OpenOasis::CommImp::Numeric::Laplacian ) Length ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) ListenFunc ( OpenOasis::IBaseExchangeItem , OpenOasis::ILinkableComponent ) m \u00b6 mComps ( OpenOasis::CommImp::IO::LinkLoader ) mInps ( OpenOasis::CommImp::IO::LinkLoader ) mInputProviders ( OpenOasis::CommImp::IO::LinkLoader ) mIterConfigs ( OpenOasis::CommImp::IO::LinkLoader ) mIterGroups ( OpenOasis::CommImp::IO::LinkLoader ) mLinkFile ( OpenOasis::CommImp::IO::LinkLoader ) mLoader ( OpenOasis::CommImp::IO::LinkLoader ) mOutputConsumers ( OpenOasis::CommImp::IO::LinkLoader ) mOuts ( OpenOasis::CommImp::IO::LinkLoader ) MeshLoader ( OpenOasis::CommImp::IO::MeshLoader ) mCellCoords ( OpenOasis::CommImp::IO::MeshLoader ) mCellFaces ( OpenOasis::CommImp::IO::MeshLoader ) mFaceCoords ( OpenOasis::CommImp::IO::MeshLoader ) mFaceNodes ( OpenOasis::CommImp::IO::MeshLoader ) mMeshDir ( OpenOasis::CommImp::IO::MeshLoader ) mNodeCoords ( OpenOasis::CommImp::IO::MeshLoader ) mPatchFaces ( OpenOasis::CommImp::IO::MeshLoader ) mZoneFaces ( OpenOasis::CommImp::IO::MeshLoader ) mData ( OpenOasis::CommImp::Numeric::DirichletBoundary , OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix ) mCol ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index ) mRow ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index ) mColumnCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) mRowCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) mValues ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix , OpenOasis::CommImp::Temporal::TimeBuffer ) mBoundaries ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mCoeffHeat ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mCoeffMat ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mGrid ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Laplacian , OpenOasis::SystHeats::HeatConductionModel ) mInitValue ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mRhs ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mTemps ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mDefault ( OpenOasis::CommImp::Numeric::Field ) mDomain ( OpenOasis::CommImp::Numeric::Field ) mType ( OpenOasis::CommImp::Numeric::Field ) Matrix ( OpenOasis::CommImp::Numeric::Matrix ) Max ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Min ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Mul ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) mCols ( OpenOasis::CommImp::Numeric::Matrix ) mRows ( OpenOasis::CommImp::Numeric::Matrix ) mCoefficient ( OpenOasis::CommImp::Numeric::Operator ) mScalarCoeffs ( OpenOasis::CommImp::Numeric::Operator ) mTensorCoeffs ( OpenOasis::CommImp::Numeric::Operator ) mVectorCoeffs ( OpenOasis::CommImp::Numeric::Operator ) mboundaries ( OpenOasis::CommImp::Numeric::Operator ) mElement ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) mBoundaryCells ( OpenOasis::CommImp::Spatial::Grid ) mBoundaryCenterDists ( OpenOasis::CommImp::Spatial::Grid ) mBoundaryFaces ( OpenOasis::CommImp::Spatial::Grid ) mCellFaceWeight ( OpenOasis::CommImp::Spatial::Grid ) mCenterDists ( OpenOasis::CommImp::Spatial::Grid ) mFaceCorrVecs ( OpenOasis::CommImp::Spatial::Grid ) mFaceIntersection ( OpenOasis::CommImp::Spatial::Grid ) mMesh ( OpenOasis::CommImp::Spatial::Grid ) mPatches ( OpenOasis::CommImp::Spatial::Grid ) mRawCellsNum ( OpenOasis::CommImp::Spatial::Grid ) mRawFacesNum ( OpenOasis::CommImp::Spatial::Grid ) mRawNodesNum ( OpenOasis::CommImp::Spatial::Grid ) mZoneCells ( OpenOasis::CommImp::Spatial::Grid ) mZones ( OpenOasis::CommImp::Spatial::Grid ) MapFromTimeSpansToTimeSpan ( OpenOasis::CommImp::Temporal::TimeBuffer ) MapFromTimeSpansToTimeStamp ( OpenOasis::CommImp::Temporal::TimeBuffer ) MapFromTimeStampsToTimeSpan ( OpenOasis::CommImp::Temporal::TimeBuffer ) MapFromTimeStampsToTimeStamp ( OpenOasis::CommImp::Temporal::TimeBuffer ) mDoExtendedDataVerification ( OpenOasis::CommImp::Temporal::TimeBuffer ) mDoExtrapolate ( OpenOasis::CommImp::Temporal::TimeBuffer ) mLastBufferSizeMessageCounter ( OpenOasis::CommImp::Temporal::TimeBuffer ) mRelaxationFactor ( OpenOasis::CommImp::Temporal::TimeBuffer ) mTimes ( OpenOasis::CommImp::Temporal::TimeBuffer ) mBoundPatches ( OpenOasis::SystHeats::HeatConductionModel ) mCellOutputs ( OpenOasis::SystHeats::HeatConductionModel ) mEigenSolver ( OpenOasis::SystHeats::HeatConductionModel ) mEnd ( OpenOasis::SystHeats::HeatConductionModel ) mK ( OpenOasis::SystHeats::HeatConductionModel ) mOutputDir ( OpenOasis::SystHeats::HeatConductionModel ) mOutputVars ( OpenOasis::SystHeats::HeatConductionModel ) mPatchBounds ( OpenOasis::SystHeats::HeatConductionModel ) mSolver ( OpenOasis::SystHeats::HeatConductionModel ) mStart ( OpenOasis::SystHeats::HeatConductionModel ) mT0 ( OpenOasis::SystHeats::HeatConductionModel ) mT0file ( OpenOasis::SystHeats::HeatConductionModel ) mTaskFile ( OpenOasis::SystHeats::HeatConductionModel ) mTempValues ( OpenOasis::SystHeats::HeatConductionModel ) n \u00b6 Normalize ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) neighbors ( OpenOasis::CommImp::Spatial::Cell ) nodeIndexes ( OpenOasis::CommImp::Spatial::Face ) normal ( OpenOasis::CommImp::Spatial::Face ) nodes ( OpenOasis::CommImp::Spatial::Mesh ) NodesInCell ( OpenOasis::SystHeats::HeatConductionModel ) o \u00b6 operator() ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::EqualFunc , OpenOasis::CommImp::Numeric::DoubleSparseMatrix::HashFunc , OpenOasis::CommImp::Numeric::DoubleSparseMatrix , OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator* ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator*= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Vector ) operator+ ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator+= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator- ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator-= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator!= ( OpenOasis::CommImp::Numeric::Vector ) operator& ( OpenOasis::CommImp::Numeric::Vector ) operator&= ( OpenOasis::CommImp::Numeric::Vector ) operator== ( OpenOasis::CommImp::Numeric::Vector ) operator^ ( OpenOasis::CommImp::Numeric::Vector ) OnValidate ( OpenOasis::SystHeats::HeatConductionModel ) p \u00b6 Product ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) ParseDiffusionTerm ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) ParseConvectionTerm ( OpenOasis::CommImp::Numeric::Solver ) ParseSourceTerm ( OpenOasis::CommImp::Numeric::Solver ) ParseTimeDerivativeTerm ( OpenOasis::CommImp::Numeric::Solver ) perimeter ( OpenOasis::CommImp::Spatial::Face ) point1 ( OpenOasis::CommImp::Spatial::XYLine ) point2 ( OpenOasis::CommImp::Spatial::XYLine ) points ( OpenOasis::CommImp::Spatial::XYPolygon , OpenOasis::CommImp::Spatial::XYPolyline ) Prepare ( OpenOasis::ILinkableComponent ) PerformTimestep ( OpenOasis::SystHeats::HeatConductionModel ) PrepareInputs ( OpenOasis::SystHeats::HeatConductionModel ) PrepareOutputs ( OpenOasis::SystHeats::HeatConductionModel ) PullInputs ( OpenOasis::SystHeats::HeatConductionModel ) r \u00b6 Range ( OpenOasis::CommImp::Numeric::Field ) Resize ( OpenOasis::CommImp::Numeric::Field ) Rows ( OpenOasis::CommImp::Numeric::Matrix ) RefineCell ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) RelaxCell ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) Reset ( OpenOasis::CommImp::Temporal::TimeBuffer , OpenOasis::IBaseExchangeItem ) Refresh ( OpenOasis::IAdaptedOutput ) RemoveListener ( OpenOasis::IBaseExchangeItem , OpenOasis::ILinkableComponent ) RemoveProvider ( OpenOasis::IInput ) RestoreState ( OpenOasis::IManageState ) RemoveAdaptedOutput ( OpenOasis::IOutput ) RemoveConsumer ( OpenOasis::IOutput ) RemoveTime ( OpenOasis::ITimeSet ) RemoveValue ( OpenOasis::IValueSet ) s \u00b6 SplitUniqueElementId ( OpenOasis::CommImp::IO::LinkLoader ) SetBoundaryFlux ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) SetBoundaryValue ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) SetColumnCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) SetRowCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) SetValue ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix , OpenOasis::IArgument ) SetBoundary ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) SetCoefficient ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Operator , OpenOasis::CommImp::Numeric::Solver ) SetInitialValue ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) Solve ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) SetAt ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Size ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Set ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) SetCol ( OpenOasis::CommImp::Numeric::Matrix ) SetDiagonal ( OpenOasis::CommImp::Numeric::Matrix ) SetRow ( OpenOasis::CommImp::Numeric::Matrix ) SetUnit ( OpenOasis::CommImp::Numeric::Matrix ) SetZero ( OpenOasis::CommImp::Numeric::Matrix ) Sub ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Sum ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) SetBoundaryCondition ( OpenOasis::CommImp::Numeric::Operator ) ScalarField ( OpenOasis::CommImp::Numeric::ScalarField ) Scheme ( OpenOasis::CommImp::Numeric::Solver ) subCells ( OpenOasis::CommImp::Spatial::Cell ) surface ( OpenOasis::CommImp::Spatial::Cell ) SortFaceNodes ( OpenOasis::CommImp::Spatial::GeoCalculator ) SortNodes ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid ) SetDoExtendedDataVerification ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetDoExtrapolate ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetOrAddValues ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetRelaxationFactor ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetExchangeItem ( OpenOasis::ExchangeItemChangeEventArgs ) SetMessages ( OpenOasis::ExchangeItemChangeEventArgs , OpenOasis::LinkableComponentStatusChangeEventArgs ) SetAdaptee ( OpenOasis::IAdaptedOutput ) SetElementSet ( OpenOasis::IBaseExchangeItem ) SetTimeSet ( OpenOasis::IBaseExchangeItem ) SetValues ( OpenOasis::IBaseExchangeItem ) SetCaption ( OpenOasis::IDescribable ) SetDescription ( OpenOasis::IDescribable ) SetPower ( OpenOasis::IDimension ) SetElementValuesForTime ( OpenOasis::IValueSet ) SetOrAddValue ( OpenOasis::IValueSet ) SetTimeSeriesValuesForElement ( OpenOasis::IValueSet ) SetLinkableComponent ( OpenOasis::LinkableComponentStatusChangeEventArgs ) SetNewStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) SetOldStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) SaveResult ( OpenOasis::SystHeats::HeatConductionModel ) sExchangeableObj ( OpenOasis::SystHeats::HeatConductionModel ) sExchangeableStates ( OpenOasis::SystHeats::HeatConductionModel ) t \u00b6 type ( OpenOasis::CommImp::Numeric::BoundaryCondition ) Type ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) Trace ( OpenOasis::CommImp::Numeric::Matrix ) Transpose ( OpenOasis::CommImp::Numeric::Matrix ) Tensor ( OpenOasis::CommImp::Numeric::Tensor ) TensorField ( OpenOasis::CommImp::Numeric::TensorField ) ToVector ( OpenOasis::CommImp::Spatial::GeoCalculator ) TimeBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer ) u \u00b6 Unit ( OpenOasis::CommImp::Numeric::Matrix ) Update ( OpenOasis::ILinkableComponent ) UpdateOutputs ( OpenOasis::SystHeats::HeatConductionModel ) v \u00b6 value ( OpenOasis::CommImp::Numeric::BoundaryCondition ) Vector ( OpenOasis::CommImp::Numeric::Vector ) VectorField ( OpenOasis::CommImp::Numeric::VectorField ) volume ( OpenOasis::CommImp::Spatial::Cell ) Validate ( OpenOasis::CommImp::Spatial::XYPolygon , OpenOasis::CommImp::Spatial::XYPolyline , OpenOasis::ILinkableComponent ) x \u00b6 x ( OpenOasis::CommImp::Spatial::Coordinate , OpenOasis::CommImp::Spatial::XYPoint ) XYExtent ( OpenOasis::CommImp::Spatial::XYExtent ) xMax ( OpenOasis::CommImp::Spatial::XYExtent ) xMin ( OpenOasis::CommImp::Spatial::XYExtent ) XYLine ( OpenOasis::CommImp::Spatial::XYLine ) XYPoint ( OpenOasis::CommImp::Spatial::XYPoint ) XYPolygon ( OpenOasis::CommImp::Spatial::XYPolygon ) XYPolyline ( OpenOasis::CommImp::Spatial::XYPolyline ) y \u00b6 y ( OpenOasis::CommImp::Spatial::Coordinate , OpenOasis::CommImp::Spatial::XYPoint ) yMax ( OpenOasis::CommImp::Spatial::XYExtent ) yMin ( OpenOasis::CommImp::Spatial::XYExtent ) z \u00b6 Zero ( OpenOasis::CommImp::Numeric::Matrix ) z ( OpenOasis::CommImp::Spatial::Coordinate ) ~ \u00b6 ~MeshLoader ( OpenOasis::CommImp::IO::MeshLoader ) ~FvmSolver ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) ~Field ( OpenOasis::CommImp::Numeric::Field ) ~Laplacian ( OpenOasis::CommImp::Numeric::Laplacian ) ~Operator ( OpenOasis::CommImp::Numeric::Operator ) ~ScalarField ( OpenOasis::CommImp::Numeric::ScalarField ) ~TensorField ( OpenOasis::CommImp::Numeric::TensorField ) ~Vector ( OpenOasis::CommImp::Numeric::Vector ) ~VectorField ( OpenOasis::CommImp::Numeric::VectorField ) ~Grid ( OpenOasis::CommImp::Spatial::Grid ) ~Grid1D ( OpenOasis::CommImp::Spatial::Grid1D ) ~Grid2D ( OpenOasis::CommImp::Spatial::Grid2D ) ~Grid3D ( OpenOasis::CommImp::Spatial::Grid3D ) ~TimeBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer ) ~HeatConductionModel ( OpenOasis::SystHeats::HeatConductionModel )","title":"Class Members"},{"location":"models/class_members/#class-members","text":"","title":"Class Members"},{"location":"models/class_members/#a","text":"At ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) Add ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Adjoint ( OpenOasis::CommImp::Numeric::Matrix ) AfterScheme ( OpenOasis::CommImp::Numeric::Solver ) AfterSolve ( OpenOasis::CommImp::Numeric::Solver ) AbsMax ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) AbsMin ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Avg ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) area ( OpenOasis::CommImp::Spatial::Face ) Activate ( OpenOasis::CommImp::Spatial::Grid ) AddValues ( OpenOasis::CommImp::Temporal::TimeBuffer ) AddValuesToBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer ) AddListener ( OpenOasis::IBaseExchangeItem , OpenOasis::ILinkableComponent ) AddProvider ( OpenOasis::IInput ) AddAdaptedOutput ( OpenOasis::IOutput ) AddConsumer ( OpenOasis::IOutput ) AddTime ( OpenOasis::ITimeSet ) ApplyInputData ( OpenOasis::SystHeats::HeatConductionModel )","title":"a"},{"location":"models/class_members/#b","text":"BeforeScheme ( OpenOasis::CommImp::Numeric::Solver ) BeforeSolve ( OpenOasis::CommImp::Numeric::Solver )","title":"b"},{"location":"models/class_members/#c","text":"CompareTo ( OpenOasis::AdditionalControl::IComparable ) CollectExchangeItemMap ( OpenOasis::CommImp::IO::LinkLoader ) CollectIteratorGroups ( OpenOasis::CommImp::IO::LinkLoader ) ComponentInfo ( OpenOasis::CommImp::IO::LinkLoader ) CheckIds ( OpenOasis::CommImp::IO::MeshLoader ) Clean ( OpenOasis::CommImp::Numeric::Field ) Clear ( OpenOasis::CommImp::Numeric::Field ) Cols ( OpenOasis::CommImp::Numeric::Matrix ) Cross ( OpenOasis::CommImp::Numeric::Vector ) centroid ( OpenOasis::CommImp::Spatial::Cell , OpenOasis::CommImp::Spatial::Face ) cellIndexes ( OpenOasis::CommImp::Spatial::Face , OpenOasis::CommImp::Spatial::Node ) cellSides ( OpenOasis::CommImp::Spatial::Face ) CalculateArea ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateCellCentroid ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateCellVolume ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateCentroid ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateFaceArea ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateFaceCentroid ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateFaceNormal ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateFacePerimeter ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateLength ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateNormal ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateVolume ( OpenOasis::CommImp::Spatial::GeoCalculator ) ChooseFoldedAxis ( OpenOasis::CommImp::Spatial::GeoCalculator ) CompareNodeOrder ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateBoundaryCenterDistances ( OpenOasis::CommImp::Spatial::Grid ) CalculateCellDistances ( OpenOasis::CommImp::Spatial::Grid ) CalculateCellSurface ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateDistance ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceCorrectionVector ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceDirector ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceIntersections ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceWeights ( OpenOasis::CommImp::Spatial::Grid ) CheckMesh ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CollectBoundaryFacesAndCells ( OpenOasis::CommImp::Spatial::Grid ) CollectCellNeighbors ( OpenOasis::CommImp::Spatial::Grid ) CollectCellsInZone ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CollectCellsSharedFace ( OpenOasis::CommImp::Spatial::Grid ) CollectCellsSharedNode ( OpenOasis::CommImp::Spatial::Grid ) CollectFacesSharedNode ( OpenOasis::CommImp::Spatial::Grid ) cells ( OpenOasis::CommImp::Spatial::Mesh ) coor ( OpenOasis::CommImp::Spatial::Node ) CalculateIntersectionPoint ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateLengthOfLineInsidePolygon ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateLengthOfPolylineInsidePolygon ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateLineToPointDistance ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateMidpoint ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculatePointToPointDistance ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculatePolylineToPointDistance ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateSharedArea ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateSharedLength ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateTriangleSharedArea ( OpenOasis::CommImp::Spatial::XYGeoTools ) CheckBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer ) ClearAfter ( OpenOasis::CommImp::Temporal::TimeBuffer ) ClearBefore ( OpenOasis::CommImp::Temporal::TimeBuffer ) Create ( OpenOasis::CommImp::Temporal::TimeBuffer ) CreateAdaptedOutput ( OpenOasis::IAdaptedOutputFactory ) ConvertFromByteStream ( OpenOasis::IByteStateConverter ) ConvertToByteStream ( OpenOasis::IByteStateConverter ) ClearState ( OpenOasis::IManageState ) CalculateUniformCoef ( OpenOasis::SystHeats::HeatConductionModel ) CreateCellOutput ( OpenOasis::SystHeats::HeatConductionModel )","title":"c"},{"location":"models/class_members/#d","text":"DirichletBoundary ( OpenOasis::CommImp::Numeric::DirichletBoundary ) DoubleSparseMatrix ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) Data ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix ) Discretize ( OpenOasis::CommImp::Numeric::Laplacian , OpenOasis::CommImp::Numeric::Operator ) Determinant ( OpenOasis::CommImp::Numeric::Matrix ) Diagonal ( OpenOasis::CommImp::Numeric::Matrix ) DDot ( OpenOasis::CommImp::Numeric::Tensor ) Div ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Dot ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Dyadic ( OpenOasis::CommImp::Numeric::Vector ) DecrementModula ( OpenOasis::CommImp::Spatial::XYGeoTools )","title":"d"},{"location":"models/class_members/#e","text":"ElementInfo ( OpenOasis::CommImp::IO::LinkLoader ) Equals ( OpenOasis::CommImp::Spatial::Coordinate ) EPSILON ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::XYGeoTools )","title":"e"},{"location":"models/class_members/#f","text":"flux ( OpenOasis::CommImp::Numeric::BoundaryCondition ) FvmSolver ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) Field ( OpenOasis::CommImp::Numeric::Field ) ForEach ( OpenOasis::CommImp::Numeric::Field ) faceIndexes ( OpenOasis::CommImp::Spatial::Cell , OpenOasis::CommImp::Spatial::Node ) faces ( OpenOasis::CommImp::Spatial::Mesh ) FindTrianglePoints ( OpenOasis::CommImp::Spatial::XYGeoTools ) Finish ( OpenOasis::ILinkableComponent )","title":"f"},{"location":"models/class_members/#g","text":"GetSpatialDefinition ( OpenOasis::AdditionalControl::ISpaceExtension ) GetCurrTime ( OpenOasis::AdditionalControl::ITimeExtension ) GetTimeExtent ( OpenOasis::AdditionalControl::ITimeExtension ) GenerateUniqueElementId ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentIds ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentInfo ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentInputs ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentOutputs ( OpenOasis::CommImp::IO::LinkLoader ) GetInputProviders ( OpenOasis::CommImp::IO::LinkLoader ) GetIteratorConfigs ( OpenOasis::CommImp::IO::LinkLoader ) GetIteratorGroups ( OpenOasis::CommImp::IO::LinkLoader ) GetOutputConsumers ( OpenOasis::CommImp::IO::LinkLoader ) GenerateCellCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GenerateFaceCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetCellCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetCellFaces ( OpenOasis::CommImp::IO::MeshLoader ) GetFaceCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetFaceNodes ( OpenOasis::CommImp::IO::MeshLoader ) GetNodeCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetPatches ( OpenOasis::CommImp::IO::MeshLoader ) GetZones ( OpenOasis::CommImp::IO::MeshLoader ) GetBoundaryCondition ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) GetType ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) GetColumnCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) GetRowCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) GetScalarSolutions ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) GetLinearEqs ( OpenOasis::CommImp::Numeric::Solver ) GetTensorSolutions ( OpenOasis::CommImp::Numeric::Solver ) GetVectorSolutions ( OpenOasis::CommImp::Numeric::Solver ) GetSource ( OpenOasis::CommImp::Numeric::Source ) GetCellNodeIndexes ( OpenOasis::CommImp::Spatial::GeoCalculator ) GetBoundaryCellIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetBoundaryCenterDistance ( OpenOasis::CommImp::Spatial::Grid ) GetBoundaryCenterDistances ( OpenOasis::CommImp::Spatial::Grid ) GetBoundaryFaceIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetCell ( OpenOasis::CommImp::Spatial::Grid ) GetCellCenterDistance ( OpenOasis::CommImp::Spatial::Grid ) GetCellCenterDistances ( OpenOasis::CommImp::Spatial::Grid ) GetCellWeightAtFace ( OpenOasis::CommImp::Spatial::Grid ) GetFace ( OpenOasis::CommImp::Spatial::Grid ) GetFaceCorrectionVector ( OpenOasis::CommImp::Spatial::Grid ) GetNode ( OpenOasis::CommImp::Spatial::Grid ) GetNumCells ( OpenOasis::CommImp::Spatial::Grid ) GetNumFaces ( OpenOasis::CommImp::Spatial::Grid ) GetNumNodes ( OpenOasis::CommImp::Spatial::Grid ) GetPatchFaceIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetPatchIds ( OpenOasis::CommImp::Spatial::Grid ) GetRawNumCells ( OpenOasis::CommImp::Spatial::Grid ) GetRawNumFaces ( OpenOasis::CommImp::Spatial::Grid ) GetRawNumNodes ( OpenOasis::CommImp::Spatial::Grid ) GetZoneCellIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetZoneIds ( OpenOasis::CommImp::Spatial::Grid ) Grid ( OpenOasis::CommImp::Spatial::Grid ) Grid1D ( OpenOasis::CommImp::Spatial::Grid1D ) Grid2D ( OpenOasis::CommImp::Spatial::Grid2D ) Grid3D ( OpenOasis::CommImp::Spatial::Grid3D ) GetTriangulations ( OpenOasis::CommImp::Spatial::XYGeoTools ) GetLength ( OpenOasis::CommImp::Spatial::XYLine , OpenOasis::CommImp::Spatial::XYPolyline ) GetArea ( OpenOasis::CommImp::Spatial::XYPolygon ) GetLine ( OpenOasis::CommImp::Spatial::XYPolygon , OpenOasis::CommImp::Spatial::XYPolyline ) GetAllValues ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetDoExtendedDataVerification ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetDoExtrapolate ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetRelaxationFactor ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetTimeAt ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetTimeSet ( OpenOasis::CommImp::Temporal::TimeBuffer , OpenOasis::IBaseExchangeItem ) GetTimesCount ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetValueSet ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetValues ( OpenOasis::CommImp::Temporal::TimeBuffer , OpenOasis::IBaseExchangeItem ) GetValuesAt ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetValuesCount ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetExchangeItem ( OpenOasis::ExchangeItemChangeEventArgs ) GetMessages ( OpenOasis::ExchangeItemChangeEventArgs , OpenOasis::LinkableComponentStatusChangeEventArgs ) GetAdaptee ( OpenOasis::IAdaptedOutput ) GetArguments ( OpenOasis::IAdaptedOutput , OpenOasis::ILinkableComponent ) GetAvailableAdaptedOutputIds ( OpenOasis::IAdaptedOutputFactory ) GetDefaultValue ( OpenOasis::IArgument ) GetPossibleValues ( OpenOasis::IArgument ) GetValue ( OpenOasis::IArgument , OpenOasis::ICategory , OpenOasis::IValueSet ) GetValueType ( OpenOasis::IArgument , OpenOasis::IValueDefinition ) GetComponent ( OpenOasis::IBaseExchangeItem ) GetElementSet ( OpenOasis::IBaseExchangeItem ) GetValueDefinition ( OpenOasis::IBaseExchangeItem , OpenOasis::IValueSet ) GetCaption ( OpenOasis::IDescribable ) GetDescription ( OpenOasis::IDescribable ) GetPower ( OpenOasis::IDimension ) GetElementId ( OpenOasis::IElementSet ) GetElementIndex ( OpenOasis::IElementSet ) GetElementType ( OpenOasis::IElementSet ) GetFaceCount ( OpenOasis::IElementSet ) GetFaceNodeIndices ( OpenOasis::IElementSet ) GetNodeCount ( OpenOasis::IElementSet ) GetNodeXCoordinate ( OpenOasis::IElementSet ) GetNodeYCoordinate ( OpenOasis::IElementSet ) GetNodeZCoordinate ( OpenOasis::IElementSet ) GetId ( OpenOasis::IIdentifiable ) GetProviders ( OpenOasis::IInput ) GetAdaptedOutputFactories ( OpenOasis::ILinkableComponent ) GetInputs ( OpenOasis::ILinkableComponent ) GetOutputs ( OpenOasis::ILinkableComponent ) GetStatus ( OpenOasis::ILinkableComponent ) GetAdaptedOutputs ( OpenOasis::IOutput ) GetConsumers ( OpenOasis::IOutput ) GetCategories ( OpenOasis::IQuality ) GetUnit ( OpenOasis::IQuantity ) GetElementCount ( OpenOasis::ISpatialDefinition ) GetSpatialReferenceSystem ( OpenOasis::ISpatialDefinition ) GetVersion ( OpenOasis::ISpatialDefinition ) GetDurationInDays ( OpenOasis::ITime ) GetTimeStamp ( OpenOasis::ITime ) GetOffsetFromUtcInHours ( OpenOasis::ITimeSet ) GetTimeHorizon ( OpenOasis::ITimeSet ) GetTimes ( OpenOasis::ITimeSet ) GetConversionFactorToSI ( OpenOasis::IUnit ) GetDimension ( OpenOasis::IUnit ) GetOffSetToSI ( OpenOasis::IUnit ) GetMissingDataValue ( OpenOasis::IValueDefinition ) GetElementValuesForTime ( OpenOasis::IValueSet ) GetIndexCount ( OpenOasis::IValueSet ) GetNumberOfIndices ( OpenOasis::IValueSet ) GetTimeSeriesValuesForElement ( OpenOasis::IValueSet ) GetLinkableComponent ( OpenOasis::LinkableComponentStatusChangeEventArgs ) GetNewStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) GetOldStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) GenerateCoeAndSrcMatrix ( OpenOasis::SystHeats::HeatConductionModel ) GetTempQuantity ( OpenOasis::SystHeats::HeatConductionModel )","title":"g"},{"location":"models/class_members/#h","text":"HasDurations ( OpenOasis::ITimeSet ) HeatConductionModel ( OpenOasis::SystHeats::HeatConductionModel )","title":"h"},{"location":"models/class_members/#i","text":"IsCellEmpty ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) Index ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index ) Initialize ( OpenOasis::CommImp::Numeric::Field , OpenOasis::IAdaptedOutput , OpenOasis::ILinkableComponent ) Invert ( OpenOasis::CommImp::Numeric::Matrix ) IsEqual ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Include ( OpenOasis::CommImp::Spatial::XYExtent ) IsContains ( OpenOasis::CommImp::Spatial::XYExtent ) IsOverlaps ( OpenOasis::CommImp::Spatial::XYExtent ) IncrementModula ( OpenOasis::CommImp::Spatial::XYGeoTools ) Intersect ( OpenOasis::CommImp::Spatial::XYGeoTools ) IntersectionPoint ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsLinesIntersected ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsPointInLine ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsPointInLineInterior ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsPointInPolygon ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsTriangleIntersected ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsConvex ( OpenOasis::CommImp::Spatial::XYPolygon ) IsOptional ( OpenOasis::IArgument ) IsReadOnly ( OpenOasis::IArgument ) IsOrdered ( OpenOasis::IQuality ) IsValues2D ( OpenOasis::IValueSet ) InitializeArguments ( OpenOasis::SystHeats::HeatConductionModel ) InitializeInputs ( OpenOasis::SystHeats::HeatConductionModel ) InitializeOutputs ( OpenOasis::SystHeats::HeatConductionModel ) InitializeSpace ( OpenOasis::SystHeats::HeatConductionModel ) InitializeTime ( OpenOasis::SystHeats::HeatConductionModel ) IsIterationConverged ( OpenOasis::SystHeats::HeatConductionModel )","title":"i"},{"location":"models/class_members/#k","text":"KeepCurrentState ( OpenOasis::IManageState )","title":"k"},{"location":"models/class_members/#l","text":"LinkLoader ( OpenOasis::CommImp::IO::LinkLoader ) Load ( OpenOasis::CommImp::IO::LinkLoader , OpenOasis::CommImp::IO::MeshLoader ) LoadComponents ( OpenOasis::CommImp::IO::LinkLoader ) LoadLinks ( OpenOasis::CommImp::IO::LinkLoader ) LoadPipeline ( OpenOasis::CommImp::IO::LinkLoader ) LoadCells ( OpenOasis::CommImp::IO::MeshLoader ) LoadFaces ( OpenOasis::CommImp::IO::MeshLoader ) LoadNodes ( OpenOasis::CommImp::IO::MeshLoader ) LoadPatches ( OpenOasis::CommImp::IO::MeshLoader ) LoadZones ( OpenOasis::CommImp::IO::MeshLoader ) Laplacian ( OpenOasis::CommImp::Numeric::Laplacian ) Length ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) ListenFunc ( OpenOasis::IBaseExchangeItem , OpenOasis::ILinkableComponent )","title":"l"},{"location":"models/class_members/#m","text":"mComps ( OpenOasis::CommImp::IO::LinkLoader ) mInps ( OpenOasis::CommImp::IO::LinkLoader ) mInputProviders ( OpenOasis::CommImp::IO::LinkLoader ) mIterConfigs ( OpenOasis::CommImp::IO::LinkLoader ) mIterGroups ( OpenOasis::CommImp::IO::LinkLoader ) mLinkFile ( OpenOasis::CommImp::IO::LinkLoader ) mLoader ( OpenOasis::CommImp::IO::LinkLoader ) mOutputConsumers ( OpenOasis::CommImp::IO::LinkLoader ) mOuts ( OpenOasis::CommImp::IO::LinkLoader ) MeshLoader ( OpenOasis::CommImp::IO::MeshLoader ) mCellCoords ( OpenOasis::CommImp::IO::MeshLoader ) mCellFaces ( OpenOasis::CommImp::IO::MeshLoader ) mFaceCoords ( OpenOasis::CommImp::IO::MeshLoader ) mFaceNodes ( OpenOasis::CommImp::IO::MeshLoader ) mMeshDir ( OpenOasis::CommImp::IO::MeshLoader ) mNodeCoords ( OpenOasis::CommImp::IO::MeshLoader ) mPatchFaces ( OpenOasis::CommImp::IO::MeshLoader ) mZoneFaces ( OpenOasis::CommImp::IO::MeshLoader ) mData ( OpenOasis::CommImp::Numeric::DirichletBoundary , OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix ) mCol ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index ) mRow ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index ) mColumnCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) mRowCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) mValues ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix , OpenOasis::CommImp::Temporal::TimeBuffer ) mBoundaries ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mCoeffHeat ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mCoeffMat ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mGrid ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Laplacian , OpenOasis::SystHeats::HeatConductionModel ) mInitValue ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mRhs ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mTemps ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mDefault ( OpenOasis::CommImp::Numeric::Field ) mDomain ( OpenOasis::CommImp::Numeric::Field ) mType ( OpenOasis::CommImp::Numeric::Field ) Matrix ( OpenOasis::CommImp::Numeric::Matrix ) Max ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Min ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Mul ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) mCols ( OpenOasis::CommImp::Numeric::Matrix ) mRows ( OpenOasis::CommImp::Numeric::Matrix ) mCoefficient ( OpenOasis::CommImp::Numeric::Operator ) mScalarCoeffs ( OpenOasis::CommImp::Numeric::Operator ) mTensorCoeffs ( OpenOasis::CommImp::Numeric::Operator ) mVectorCoeffs ( OpenOasis::CommImp::Numeric::Operator ) mboundaries ( OpenOasis::CommImp::Numeric::Operator ) mElement ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) mBoundaryCells ( OpenOasis::CommImp::Spatial::Grid ) mBoundaryCenterDists ( OpenOasis::CommImp::Spatial::Grid ) mBoundaryFaces ( OpenOasis::CommImp::Spatial::Grid ) mCellFaceWeight ( OpenOasis::CommImp::Spatial::Grid ) mCenterDists ( OpenOasis::CommImp::Spatial::Grid ) mFaceCorrVecs ( OpenOasis::CommImp::Spatial::Grid ) mFaceIntersection ( OpenOasis::CommImp::Spatial::Grid ) mMesh ( OpenOasis::CommImp::Spatial::Grid ) mPatches ( OpenOasis::CommImp::Spatial::Grid ) mRawCellsNum ( OpenOasis::CommImp::Spatial::Grid ) mRawFacesNum ( OpenOasis::CommImp::Spatial::Grid ) mRawNodesNum ( OpenOasis::CommImp::Spatial::Grid ) mZoneCells ( OpenOasis::CommImp::Spatial::Grid ) mZones ( OpenOasis::CommImp::Spatial::Grid ) MapFromTimeSpansToTimeSpan ( OpenOasis::CommImp::Temporal::TimeBuffer ) MapFromTimeSpansToTimeStamp ( OpenOasis::CommImp::Temporal::TimeBuffer ) MapFromTimeStampsToTimeSpan ( OpenOasis::CommImp::Temporal::TimeBuffer ) MapFromTimeStampsToTimeStamp ( OpenOasis::CommImp::Temporal::TimeBuffer ) mDoExtendedDataVerification ( OpenOasis::CommImp::Temporal::TimeBuffer ) mDoExtrapolate ( OpenOasis::CommImp::Temporal::TimeBuffer ) mLastBufferSizeMessageCounter ( OpenOasis::CommImp::Temporal::TimeBuffer ) mRelaxationFactor ( OpenOasis::CommImp::Temporal::TimeBuffer ) mTimes ( OpenOasis::CommImp::Temporal::TimeBuffer ) mBoundPatches ( OpenOasis::SystHeats::HeatConductionModel ) mCellOutputs ( OpenOasis::SystHeats::HeatConductionModel ) mEigenSolver ( OpenOasis::SystHeats::HeatConductionModel ) mEnd ( OpenOasis::SystHeats::HeatConductionModel ) mK ( OpenOasis::SystHeats::HeatConductionModel ) mOutputDir ( OpenOasis::SystHeats::HeatConductionModel ) mOutputVars ( OpenOasis::SystHeats::HeatConductionModel ) mPatchBounds ( OpenOasis::SystHeats::HeatConductionModel ) mSolver ( OpenOasis::SystHeats::HeatConductionModel ) mStart ( OpenOasis::SystHeats::HeatConductionModel ) mT0 ( OpenOasis::SystHeats::HeatConductionModel ) mT0file ( OpenOasis::SystHeats::HeatConductionModel ) mTaskFile ( OpenOasis::SystHeats::HeatConductionModel ) mTempValues ( OpenOasis::SystHeats::HeatConductionModel )","title":"m"},{"location":"models/class_members/#n","text":"Normalize ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) neighbors ( OpenOasis::CommImp::Spatial::Cell ) nodeIndexes ( OpenOasis::CommImp::Spatial::Face ) normal ( OpenOasis::CommImp::Spatial::Face ) nodes ( OpenOasis::CommImp::Spatial::Mesh ) NodesInCell ( OpenOasis::SystHeats::HeatConductionModel )","title":"n"},{"location":"models/class_members/#o","text":"operator() ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::EqualFunc , OpenOasis::CommImp::Numeric::DoubleSparseMatrix::HashFunc , OpenOasis::CommImp::Numeric::DoubleSparseMatrix , OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator* ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator*= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Vector ) operator+ ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator+= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator- ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator-= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator!= ( OpenOasis::CommImp::Numeric::Vector ) operator& ( OpenOasis::CommImp::Numeric::Vector ) operator&= ( OpenOasis::CommImp::Numeric::Vector ) operator== ( OpenOasis::CommImp::Numeric::Vector ) operator^ ( OpenOasis::CommImp::Numeric::Vector ) OnValidate ( OpenOasis::SystHeats::HeatConductionModel )","title":"o"},{"location":"models/class_members/#p","text":"Product ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) ParseDiffusionTerm ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) ParseConvectionTerm ( OpenOasis::CommImp::Numeric::Solver ) ParseSourceTerm ( OpenOasis::CommImp::Numeric::Solver ) ParseTimeDerivativeTerm ( OpenOasis::CommImp::Numeric::Solver ) perimeter ( OpenOasis::CommImp::Spatial::Face ) point1 ( OpenOasis::CommImp::Spatial::XYLine ) point2 ( OpenOasis::CommImp::Spatial::XYLine ) points ( OpenOasis::CommImp::Spatial::XYPolygon , OpenOasis::CommImp::Spatial::XYPolyline ) Prepare ( OpenOasis::ILinkableComponent ) PerformTimestep ( OpenOasis::SystHeats::HeatConductionModel ) PrepareInputs ( OpenOasis::SystHeats::HeatConductionModel ) PrepareOutputs ( OpenOasis::SystHeats::HeatConductionModel ) PullInputs ( OpenOasis::SystHeats::HeatConductionModel )","title":"p"},{"location":"models/class_members/#r","text":"Range ( OpenOasis::CommImp::Numeric::Field ) Resize ( OpenOasis::CommImp::Numeric::Field ) Rows ( OpenOasis::CommImp::Numeric::Matrix ) RefineCell ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) RelaxCell ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) Reset ( OpenOasis::CommImp::Temporal::TimeBuffer , OpenOasis::IBaseExchangeItem ) Refresh ( OpenOasis::IAdaptedOutput ) RemoveListener ( OpenOasis::IBaseExchangeItem , OpenOasis::ILinkableComponent ) RemoveProvider ( OpenOasis::IInput ) RestoreState ( OpenOasis::IManageState ) RemoveAdaptedOutput ( OpenOasis::IOutput ) RemoveConsumer ( OpenOasis::IOutput ) RemoveTime ( OpenOasis::ITimeSet ) RemoveValue ( OpenOasis::IValueSet )","title":"r"},{"location":"models/class_members/#s","text":"SplitUniqueElementId ( OpenOasis::CommImp::IO::LinkLoader ) SetBoundaryFlux ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) SetBoundaryValue ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) SetColumnCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) SetRowCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) SetValue ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix , OpenOasis::IArgument ) SetBoundary ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) SetCoefficient ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Operator , OpenOasis::CommImp::Numeric::Solver ) SetInitialValue ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) Solve ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) SetAt ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Size ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Set ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) SetCol ( OpenOasis::CommImp::Numeric::Matrix ) SetDiagonal ( OpenOasis::CommImp::Numeric::Matrix ) SetRow ( OpenOasis::CommImp::Numeric::Matrix ) SetUnit ( OpenOasis::CommImp::Numeric::Matrix ) SetZero ( OpenOasis::CommImp::Numeric::Matrix ) Sub ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Sum ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) SetBoundaryCondition ( OpenOasis::CommImp::Numeric::Operator ) ScalarField ( OpenOasis::CommImp::Numeric::ScalarField ) Scheme ( OpenOasis::CommImp::Numeric::Solver ) subCells ( OpenOasis::CommImp::Spatial::Cell ) surface ( OpenOasis::CommImp::Spatial::Cell ) SortFaceNodes ( OpenOasis::CommImp::Spatial::GeoCalculator ) SortNodes ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid ) SetDoExtendedDataVerification ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetDoExtrapolate ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetOrAddValues ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetRelaxationFactor ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetExchangeItem ( OpenOasis::ExchangeItemChangeEventArgs ) SetMessages ( OpenOasis::ExchangeItemChangeEventArgs , OpenOasis::LinkableComponentStatusChangeEventArgs ) SetAdaptee ( OpenOasis::IAdaptedOutput ) SetElementSet ( OpenOasis::IBaseExchangeItem ) SetTimeSet ( OpenOasis::IBaseExchangeItem ) SetValues ( OpenOasis::IBaseExchangeItem ) SetCaption ( OpenOasis::IDescribable ) SetDescription ( OpenOasis::IDescribable ) SetPower ( OpenOasis::IDimension ) SetElementValuesForTime ( OpenOasis::IValueSet ) SetOrAddValue ( OpenOasis::IValueSet ) SetTimeSeriesValuesForElement ( OpenOasis::IValueSet ) SetLinkableComponent ( OpenOasis::LinkableComponentStatusChangeEventArgs ) SetNewStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) SetOldStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) SaveResult ( OpenOasis::SystHeats::HeatConductionModel ) sExchangeableObj ( OpenOasis::SystHeats::HeatConductionModel ) sExchangeableStates ( OpenOasis::SystHeats::HeatConductionModel )","title":"s"},{"location":"models/class_members/#t","text":"type ( OpenOasis::CommImp::Numeric::BoundaryCondition ) Type ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) Trace ( OpenOasis::CommImp::Numeric::Matrix ) Transpose ( OpenOasis::CommImp::Numeric::Matrix ) Tensor ( OpenOasis::CommImp::Numeric::Tensor ) TensorField ( OpenOasis::CommImp::Numeric::TensorField ) ToVector ( OpenOasis::CommImp::Spatial::GeoCalculator ) TimeBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer )","title":"t"},{"location":"models/class_members/#u","text":"Unit ( OpenOasis::CommImp::Numeric::Matrix ) Update ( OpenOasis::ILinkableComponent ) UpdateOutputs ( OpenOasis::SystHeats::HeatConductionModel )","title":"u"},{"location":"models/class_members/#v","text":"value ( OpenOasis::CommImp::Numeric::BoundaryCondition ) Vector ( OpenOasis::CommImp::Numeric::Vector ) VectorField ( OpenOasis::CommImp::Numeric::VectorField ) volume ( OpenOasis::CommImp::Spatial::Cell ) Validate ( OpenOasis::CommImp::Spatial::XYPolygon , OpenOasis::CommImp::Spatial::XYPolyline , OpenOasis::ILinkableComponent )","title":"v"},{"location":"models/class_members/#x","text":"x ( OpenOasis::CommImp::Spatial::Coordinate , OpenOasis::CommImp::Spatial::XYPoint ) XYExtent ( OpenOasis::CommImp::Spatial::XYExtent ) xMax ( OpenOasis::CommImp::Spatial::XYExtent ) xMin ( OpenOasis::CommImp::Spatial::XYExtent ) XYLine ( OpenOasis::CommImp::Spatial::XYLine ) XYPoint ( OpenOasis::CommImp::Spatial::XYPoint ) XYPolygon ( OpenOasis::CommImp::Spatial::XYPolygon ) XYPolyline ( OpenOasis::CommImp::Spatial::XYPolyline )","title":"x"},{"location":"models/class_members/#y","text":"y ( OpenOasis::CommImp::Spatial::Coordinate , OpenOasis::CommImp::Spatial::XYPoint ) yMax ( OpenOasis::CommImp::Spatial::XYExtent ) yMin ( OpenOasis::CommImp::Spatial::XYExtent )","title":"y"},{"location":"models/class_members/#z","text":"Zero ( OpenOasis::CommImp::Numeric::Matrix ) z ( OpenOasis::CommImp::Spatial::Coordinate )","title":"z"},{"location":"models/class_members/#_1","text":"~MeshLoader ( OpenOasis::CommImp::IO::MeshLoader ) ~FvmSolver ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) ~Field ( OpenOasis::CommImp::Numeric::Field ) ~Laplacian ( OpenOasis::CommImp::Numeric::Laplacian ) ~Operator ( OpenOasis::CommImp::Numeric::Operator ) ~ScalarField ( OpenOasis::CommImp::Numeric::ScalarField ) ~TensorField ( OpenOasis::CommImp::Numeric::TensorField ) ~Vector ( OpenOasis::CommImp::Numeric::Vector ) ~VectorField ( OpenOasis::CommImp::Numeric::VectorField ) ~Grid ( OpenOasis::CommImp::Spatial::Grid ) ~Grid1D ( OpenOasis::CommImp::Spatial::Grid1D ) ~Grid2D ( OpenOasis::CommImp::Spatial::Grid2D ) ~Grid3D ( OpenOasis::CommImp::Spatial::Grid3D ) ~TimeBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer ) ~HeatConductionModel ( OpenOasis::SystHeats::HeatConductionModel )","title":"~"},{"location":"models/class_member_functions/","text":"Class Member Functions \u00b6 a \u00b6 At ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) Add ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Adjoint ( OpenOasis::CommImp::Numeric::Matrix ) AfterScheme ( OpenOasis::CommImp::Numeric::Solver ) AfterSolve ( OpenOasis::CommImp::Numeric::Solver ) AbsMax ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) AbsMin ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Avg ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Activate ( OpenOasis::CommImp::Spatial::Grid ) AddValues ( OpenOasis::CommImp::Temporal::TimeBuffer ) AddValuesToBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer ) AddListener ( OpenOasis::IBaseExchangeItem , OpenOasis::ILinkableComponent ) AddProvider ( OpenOasis::IInput ) AddAdaptedOutput ( OpenOasis::IOutput ) AddConsumer ( OpenOasis::IOutput ) AddTime ( OpenOasis::ITimeSet ) ApplyInputData ( OpenOasis::SystHeats::HeatConductionModel ) b \u00b6 BeforeScheme ( OpenOasis::CommImp::Numeric::Solver ) BeforeSolve ( OpenOasis::CommImp::Numeric::Solver ) c \u00b6 CompareTo ( OpenOasis::AdditionalControl::IComparable ) CollectExchangeItemMap ( OpenOasis::CommImp::IO::LinkLoader ) CollectIteratorGroups ( OpenOasis::CommImp::IO::LinkLoader ) CheckIds ( OpenOasis::CommImp::IO::MeshLoader ) Clean ( OpenOasis::CommImp::Numeric::Field ) Clear ( OpenOasis::CommImp::Numeric::Field ) Cols ( OpenOasis::CommImp::Numeric::Matrix ) Cross ( OpenOasis::CommImp::Numeric::Vector ) CalculateArea ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateCellCentroid ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateCellVolume ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateCentroid ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateFaceArea ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateFaceCentroid ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateFaceNormal ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateFacePerimeter ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateLength ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateNormal ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateVolume ( OpenOasis::CommImp::Spatial::GeoCalculator ) ChooseFoldedAxis ( OpenOasis::CommImp::Spatial::GeoCalculator ) CompareNodeOrder ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateBoundaryCenterDistances ( OpenOasis::CommImp::Spatial::Grid ) CalculateCellDistances ( OpenOasis::CommImp::Spatial::Grid ) CalculateCellSurface ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateDistance ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceCorrectionVector ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceDirector ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceIntersections ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceWeights ( OpenOasis::CommImp::Spatial::Grid ) CheckMesh ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CollectBoundaryFacesAndCells ( OpenOasis::CommImp::Spatial::Grid ) CollectCellNeighbors ( OpenOasis::CommImp::Spatial::Grid ) CollectCellsInZone ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CollectCellsSharedFace ( OpenOasis::CommImp::Spatial::Grid ) CollectCellsSharedNode ( OpenOasis::CommImp::Spatial::Grid ) CollectFacesSharedNode ( OpenOasis::CommImp::Spatial::Grid ) CalculateIntersectionPoint ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateLengthOfLineInsidePolygon ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateLengthOfPolylineInsidePolygon ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateLineToPointDistance ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateMidpoint ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculatePointToPointDistance ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculatePolylineToPointDistance ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateSharedArea ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateSharedLength ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateTriangleSharedArea ( OpenOasis::CommImp::Spatial::XYGeoTools ) CheckBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer ) ClearAfter ( OpenOasis::CommImp::Temporal::TimeBuffer ) ClearBefore ( OpenOasis::CommImp::Temporal::TimeBuffer ) Create ( OpenOasis::CommImp::Temporal::TimeBuffer ) CreateAdaptedOutput ( OpenOasis::IAdaptedOutputFactory ) ConvertFromByteStream ( OpenOasis::IByteStateConverter ) ConvertToByteStream ( OpenOasis::IByteStateConverter ) ClearState ( OpenOasis::IManageState ) CalculateUniformCoef ( OpenOasis::SystHeats::HeatConductionModel ) CreateCellOutput ( OpenOasis::SystHeats::HeatConductionModel ) d \u00b6 DirichletBoundary ( OpenOasis::CommImp::Numeric::DirichletBoundary ) DoubleSparseMatrix ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) Data ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix ) Discretize ( OpenOasis::CommImp::Numeric::Laplacian , OpenOasis::CommImp::Numeric::Operator ) Determinant ( OpenOasis::CommImp::Numeric::Matrix ) Diagonal ( OpenOasis::CommImp::Numeric::Matrix ) DDot ( OpenOasis::CommImp::Numeric::Tensor ) Div ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Dot ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Dyadic ( OpenOasis::CommImp::Numeric::Vector ) DecrementModula ( OpenOasis::CommImp::Spatial::XYGeoTools ) e \u00b6 Equals ( OpenOasis::CommImp::Spatial::Coordinate ) f \u00b6 FvmSolver ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) Field ( OpenOasis::CommImp::Numeric::Field ) ForEach ( OpenOasis::CommImp::Numeric::Field ) FindTrianglePoints ( OpenOasis::CommImp::Spatial::XYGeoTools ) Finish ( OpenOasis::ILinkableComponent ) g \u00b6 GetSpatialDefinition ( OpenOasis::AdditionalControl::ISpaceExtension ) GetCurrTime ( OpenOasis::AdditionalControl::ITimeExtension ) GetTimeExtent ( OpenOasis::AdditionalControl::ITimeExtension ) GenerateUniqueElementId ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentIds ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentInfo ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentInputs ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentOutputs ( OpenOasis::CommImp::IO::LinkLoader ) GetInputProviders ( OpenOasis::CommImp::IO::LinkLoader ) GetIteratorConfigs ( OpenOasis::CommImp::IO::LinkLoader ) GetIteratorGroups ( OpenOasis::CommImp::IO::LinkLoader ) GetOutputConsumers ( OpenOasis::CommImp::IO::LinkLoader ) GenerateCellCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GenerateFaceCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetCellCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetCellFaces ( OpenOasis::CommImp::IO::MeshLoader ) GetFaceCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetFaceNodes ( OpenOasis::CommImp::IO::MeshLoader ) GetNodeCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetPatches ( OpenOasis::CommImp::IO::MeshLoader ) GetZones ( OpenOasis::CommImp::IO::MeshLoader ) GetBoundaryCondition ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) GetType ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) GetColumnCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) GetRowCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) GetScalarSolutions ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) GetLinearEqs ( OpenOasis::CommImp::Numeric::Solver ) GetTensorSolutions ( OpenOasis::CommImp::Numeric::Solver ) GetVectorSolutions ( OpenOasis::CommImp::Numeric::Solver ) GetSource ( OpenOasis::CommImp::Numeric::Source ) GetCellNodeIndexes ( OpenOasis::CommImp::Spatial::GeoCalculator ) GetBoundaryCellIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetBoundaryCenterDistance ( OpenOasis::CommImp::Spatial::Grid ) GetBoundaryCenterDistances ( OpenOasis::CommImp::Spatial::Grid ) GetBoundaryFaceIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetCell ( OpenOasis::CommImp::Spatial::Grid ) GetCellCenterDistance ( OpenOasis::CommImp::Spatial::Grid ) GetCellCenterDistances ( OpenOasis::CommImp::Spatial::Grid ) GetCellWeightAtFace ( OpenOasis::CommImp::Spatial::Grid ) GetFace ( OpenOasis::CommImp::Spatial::Grid ) GetFaceCorrectionVector ( OpenOasis::CommImp::Spatial::Grid ) GetNode ( OpenOasis::CommImp::Spatial::Grid ) GetNumCells ( OpenOasis::CommImp::Spatial::Grid ) GetNumFaces ( OpenOasis::CommImp::Spatial::Grid ) GetNumNodes ( OpenOasis::CommImp::Spatial::Grid ) GetPatchFaceIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetPatchIds ( OpenOasis::CommImp::Spatial::Grid ) GetRawNumCells ( OpenOasis::CommImp::Spatial::Grid ) GetRawNumFaces ( OpenOasis::CommImp::Spatial::Grid ) GetRawNumNodes ( OpenOasis::CommImp::Spatial::Grid ) GetZoneCellIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetZoneIds ( OpenOasis::CommImp::Spatial::Grid ) Grid ( OpenOasis::CommImp::Spatial::Grid ) Grid1D ( OpenOasis::CommImp::Spatial::Grid1D ) Grid2D ( OpenOasis::CommImp::Spatial::Grid2D ) Grid3D ( OpenOasis::CommImp::Spatial::Grid3D ) GetTriangulations ( OpenOasis::CommImp::Spatial::XYGeoTools ) GetLength ( OpenOasis::CommImp::Spatial::XYLine , OpenOasis::CommImp::Spatial::XYPolyline ) GetArea ( OpenOasis::CommImp::Spatial::XYPolygon ) GetLine ( OpenOasis::CommImp::Spatial::XYPolygon , OpenOasis::CommImp::Spatial::XYPolyline ) GetAllValues ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetDoExtendedDataVerification ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetDoExtrapolate ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetRelaxationFactor ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetTimeAt ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetTimeSet ( OpenOasis::CommImp::Temporal::TimeBuffer , OpenOasis::IBaseExchangeItem ) GetTimesCount ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetValueSet ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetValues ( OpenOasis::CommImp::Temporal::TimeBuffer , OpenOasis::IBaseExchangeItem ) GetValuesAt ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetValuesCount ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetExchangeItem ( OpenOasis::ExchangeItemChangeEventArgs ) GetMessages ( OpenOasis::ExchangeItemChangeEventArgs , OpenOasis::LinkableComponentStatusChangeEventArgs ) GetAdaptee ( OpenOasis::IAdaptedOutput ) GetArguments ( OpenOasis::IAdaptedOutput , OpenOasis::ILinkableComponent ) GetAvailableAdaptedOutputIds ( OpenOasis::IAdaptedOutputFactory ) GetDefaultValue ( OpenOasis::IArgument ) GetPossibleValues ( OpenOasis::IArgument ) GetValue ( OpenOasis::IArgument , OpenOasis::ICategory , OpenOasis::IValueSet ) GetValueType ( OpenOasis::IArgument , OpenOasis::IValueDefinition ) GetComponent ( OpenOasis::IBaseExchangeItem ) GetElementSet ( OpenOasis::IBaseExchangeItem ) GetValueDefinition ( OpenOasis::IBaseExchangeItem , OpenOasis::IValueSet ) GetCaption ( OpenOasis::IDescribable ) GetDescription ( OpenOasis::IDescribable ) GetPower ( OpenOasis::IDimension ) GetElementId ( OpenOasis::IElementSet ) GetElementIndex ( OpenOasis::IElementSet ) GetElementType ( OpenOasis::IElementSet ) GetFaceCount ( OpenOasis::IElementSet ) GetFaceNodeIndices ( OpenOasis::IElementSet ) GetNodeCount ( OpenOasis::IElementSet ) GetNodeXCoordinate ( OpenOasis::IElementSet ) GetNodeYCoordinate ( OpenOasis::IElementSet ) GetNodeZCoordinate ( OpenOasis::IElementSet ) GetId ( OpenOasis::IIdentifiable ) GetProviders ( OpenOasis::IInput ) GetAdaptedOutputFactories ( OpenOasis::ILinkableComponent ) GetInputs ( OpenOasis::ILinkableComponent ) GetOutputs ( OpenOasis::ILinkableComponent ) GetStatus ( OpenOasis::ILinkableComponent ) GetAdaptedOutputs ( OpenOasis::IOutput ) GetConsumers ( OpenOasis::IOutput ) GetCategories ( OpenOasis::IQuality ) GetUnit ( OpenOasis::IQuantity ) GetElementCount ( OpenOasis::ISpatialDefinition ) GetSpatialReferenceSystem ( OpenOasis::ISpatialDefinition ) GetVersion ( OpenOasis::ISpatialDefinition ) GetDurationInDays ( OpenOasis::ITime ) GetTimeStamp ( OpenOasis::ITime ) GetOffsetFromUtcInHours ( OpenOasis::ITimeSet ) GetTimeHorizon ( OpenOasis::ITimeSet ) GetTimes ( OpenOasis::ITimeSet ) GetConversionFactorToSI ( OpenOasis::IUnit ) GetDimension ( OpenOasis::IUnit ) GetOffSetToSI ( OpenOasis::IUnit ) GetMissingDataValue ( OpenOasis::IValueDefinition ) GetElementValuesForTime ( OpenOasis::IValueSet ) GetIndexCount ( OpenOasis::IValueSet ) GetNumberOfIndices ( OpenOasis::IValueSet ) GetTimeSeriesValuesForElement ( OpenOasis::IValueSet ) GetLinkableComponent ( OpenOasis::LinkableComponentStatusChangeEventArgs ) GetNewStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) GetOldStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) GenerateCoeAndSrcMatrix ( OpenOasis::SystHeats::HeatConductionModel ) GetTempQuantity ( OpenOasis::SystHeats::HeatConductionModel ) h \u00b6 HasDurations ( OpenOasis::ITimeSet ) HeatConductionModel ( OpenOasis::SystHeats::HeatConductionModel ) i \u00b6 IsCellEmpty ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) Index ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index ) Initialize ( OpenOasis::CommImp::Numeric::Field , OpenOasis::IAdaptedOutput , OpenOasis::ILinkableComponent ) Invert ( OpenOasis::CommImp::Numeric::Matrix ) IsEqual ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Include ( OpenOasis::CommImp::Spatial::XYExtent ) IsContains ( OpenOasis::CommImp::Spatial::XYExtent ) IsOverlaps ( OpenOasis::CommImp::Spatial::XYExtent ) IncrementModula ( OpenOasis::CommImp::Spatial::XYGeoTools ) Intersect ( OpenOasis::CommImp::Spatial::XYGeoTools ) IntersectionPoint ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsLinesIntersected ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsPointInLine ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsPointInLineInterior ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsPointInPolygon ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsTriangleIntersected ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsConvex ( OpenOasis::CommImp::Spatial::XYPolygon ) IsOptional ( OpenOasis::IArgument ) IsReadOnly ( OpenOasis::IArgument ) IsOrdered ( OpenOasis::IQuality ) IsValues2D ( OpenOasis::IValueSet ) InitializeArguments ( OpenOasis::SystHeats::HeatConductionModel ) InitializeInputs ( OpenOasis::SystHeats::HeatConductionModel ) InitializeOutputs ( OpenOasis::SystHeats::HeatConductionModel ) InitializeSpace ( OpenOasis::SystHeats::HeatConductionModel ) InitializeTime ( OpenOasis::SystHeats::HeatConductionModel ) IsIterationConverged ( OpenOasis::SystHeats::HeatConductionModel ) k \u00b6 KeepCurrentState ( OpenOasis::IManageState ) l \u00b6 LinkLoader ( OpenOasis::CommImp::IO::LinkLoader ) Load ( OpenOasis::CommImp::IO::LinkLoader , OpenOasis::CommImp::IO::MeshLoader ) LoadComponents ( OpenOasis::CommImp::IO::LinkLoader ) LoadLinks ( OpenOasis::CommImp::IO::LinkLoader ) LoadPipeline ( OpenOasis::CommImp::IO::LinkLoader ) LoadCells ( OpenOasis::CommImp::IO::MeshLoader ) LoadFaces ( OpenOasis::CommImp::IO::MeshLoader ) LoadNodes ( OpenOasis::CommImp::IO::MeshLoader ) LoadPatches ( OpenOasis::CommImp::IO::MeshLoader ) LoadZones ( OpenOasis::CommImp::IO::MeshLoader ) Laplacian ( OpenOasis::CommImp::Numeric::Laplacian ) Length ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) m \u00b6 MeshLoader ( OpenOasis::CommImp::IO::MeshLoader ) Matrix ( OpenOasis::CommImp::Numeric::Matrix ) Max ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Min ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Mul ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) MapFromTimeSpansToTimeSpan ( OpenOasis::CommImp::Temporal::TimeBuffer ) MapFromTimeSpansToTimeStamp ( OpenOasis::CommImp::Temporal::TimeBuffer ) MapFromTimeStampsToTimeSpan ( OpenOasis::CommImp::Temporal::TimeBuffer ) MapFromTimeStampsToTimeStamp ( OpenOasis::CommImp::Temporal::TimeBuffer ) n \u00b6 Normalize ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) NodesInCell ( OpenOasis::SystHeats::HeatConductionModel ) o \u00b6 operator() ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::EqualFunc , OpenOasis::CommImp::Numeric::DoubleSparseMatrix::HashFunc , OpenOasis::CommImp::Numeric::DoubleSparseMatrix , OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator* ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator*= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Vector ) operator+ ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator+= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator- ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator-= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator!= ( OpenOasis::CommImp::Numeric::Vector ) operator& ( OpenOasis::CommImp::Numeric::Vector ) operator&= ( OpenOasis::CommImp::Numeric::Vector ) operator== ( OpenOasis::CommImp::Numeric::Vector ) operator^ ( OpenOasis::CommImp::Numeric::Vector ) OnValidate ( OpenOasis::SystHeats::HeatConductionModel ) p \u00b6 Product ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) ParseDiffusionTerm ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) ParseConvectionTerm ( OpenOasis::CommImp::Numeric::Solver ) ParseSourceTerm ( OpenOasis::CommImp::Numeric::Solver ) ParseTimeDerivativeTerm ( OpenOasis::CommImp::Numeric::Solver ) Prepare ( OpenOasis::ILinkableComponent ) PerformTimestep ( OpenOasis::SystHeats::HeatConductionModel ) PrepareInputs ( OpenOasis::SystHeats::HeatConductionModel ) PrepareOutputs ( OpenOasis::SystHeats::HeatConductionModel ) PullInputs ( OpenOasis::SystHeats::HeatConductionModel ) r \u00b6 Range ( OpenOasis::CommImp::Numeric::Field ) Resize ( OpenOasis::CommImp::Numeric::Field ) Rows ( OpenOasis::CommImp::Numeric::Matrix ) RefineCell ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) RelaxCell ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) Reset ( OpenOasis::CommImp::Temporal::TimeBuffer , OpenOasis::IBaseExchangeItem ) Refresh ( OpenOasis::IAdaptedOutput ) RemoveListener ( OpenOasis::IBaseExchangeItem , OpenOasis::ILinkableComponent ) RemoveProvider ( OpenOasis::IInput ) RestoreState ( OpenOasis::IManageState ) RemoveAdaptedOutput ( OpenOasis::IOutput ) RemoveConsumer ( OpenOasis::IOutput ) RemoveTime ( OpenOasis::ITimeSet ) RemoveValue ( OpenOasis::IValueSet ) s \u00b6 SplitUniqueElementId ( OpenOasis::CommImp::IO::LinkLoader ) SetBoundaryFlux ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) SetBoundaryValue ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) SetColumnCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) SetRowCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) SetValue ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix , OpenOasis::IArgument ) SetBoundary ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) SetCoefficient ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Operator , OpenOasis::CommImp::Numeric::Solver ) SetInitialValue ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) Solve ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) SetAt ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Size ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Set ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) SetCol ( OpenOasis::CommImp::Numeric::Matrix ) SetDiagonal ( OpenOasis::CommImp::Numeric::Matrix ) SetRow ( OpenOasis::CommImp::Numeric::Matrix ) SetUnit ( OpenOasis::CommImp::Numeric::Matrix ) SetZero ( OpenOasis::CommImp::Numeric::Matrix ) Sub ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Sum ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) SetBoundaryCondition ( OpenOasis::CommImp::Numeric::Operator ) ScalarField ( OpenOasis::CommImp::Numeric::ScalarField ) Scheme ( OpenOasis::CommImp::Numeric::Solver ) SortFaceNodes ( OpenOasis::CommImp::Spatial::GeoCalculator ) SortNodes ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid ) SetDoExtendedDataVerification ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetDoExtrapolate ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetOrAddValues ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetRelaxationFactor ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetExchangeItem ( OpenOasis::ExchangeItemChangeEventArgs ) SetMessages ( OpenOasis::ExchangeItemChangeEventArgs , OpenOasis::LinkableComponentStatusChangeEventArgs ) SetAdaptee ( OpenOasis::IAdaptedOutput ) SetElementSet ( OpenOasis::IBaseExchangeItem ) SetTimeSet ( OpenOasis::IBaseExchangeItem ) SetValues ( OpenOasis::IBaseExchangeItem ) SetCaption ( OpenOasis::IDescribable ) SetDescription ( OpenOasis::IDescribable ) SetPower ( OpenOasis::IDimension ) SetElementValuesForTime ( OpenOasis::IValueSet ) SetOrAddValue ( OpenOasis::IValueSet ) SetTimeSeriesValuesForElement ( OpenOasis::IValueSet ) SetLinkableComponent ( OpenOasis::LinkableComponentStatusChangeEventArgs ) SetNewStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) SetOldStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) SaveResult ( OpenOasis::SystHeats::HeatConductionModel ) t \u00b6 Type ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) Trace ( OpenOasis::CommImp::Numeric::Matrix ) Transpose ( OpenOasis::CommImp::Numeric::Matrix ) Tensor ( OpenOasis::CommImp::Numeric::Tensor ) TensorField ( OpenOasis::CommImp::Numeric::TensorField ) ToVector ( OpenOasis::CommImp::Spatial::GeoCalculator ) TimeBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer ) u \u00b6 Unit ( OpenOasis::CommImp::Numeric::Matrix ) Update ( OpenOasis::ILinkableComponent ) UpdateOutputs ( OpenOasis::SystHeats::HeatConductionModel ) v \u00b6 Vector ( OpenOasis::CommImp::Numeric::Vector ) VectorField ( OpenOasis::CommImp::Numeric::VectorField ) Validate ( OpenOasis::CommImp::Spatial::XYPolygon , OpenOasis::CommImp::Spatial::XYPolyline , OpenOasis::ILinkableComponent ) x \u00b6 XYExtent ( OpenOasis::CommImp::Spatial::XYExtent ) XYLine ( OpenOasis::CommImp::Spatial::XYLine ) XYPoint ( OpenOasis::CommImp::Spatial::XYPoint ) XYPolygon ( OpenOasis::CommImp::Spatial::XYPolygon ) XYPolyline ( OpenOasis::CommImp::Spatial::XYPolyline ) z \u00b6 Zero ( OpenOasis::CommImp::Numeric::Matrix ) ~ \u00b6 ~MeshLoader ( OpenOasis::CommImp::IO::MeshLoader ) ~FvmSolver ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) ~Field ( OpenOasis::CommImp::Numeric::Field ) ~Laplacian ( OpenOasis::CommImp::Numeric::Laplacian ) ~Operator ( OpenOasis::CommImp::Numeric::Operator ) ~ScalarField ( OpenOasis::CommImp::Numeric::ScalarField ) ~TensorField ( OpenOasis::CommImp::Numeric::TensorField ) ~Vector ( OpenOasis::CommImp::Numeric::Vector ) ~VectorField ( OpenOasis::CommImp::Numeric::VectorField ) ~Grid ( OpenOasis::CommImp::Spatial::Grid ) ~Grid1D ( OpenOasis::CommImp::Spatial::Grid1D ) ~Grid2D ( OpenOasis::CommImp::Spatial::Grid2D ) ~Grid3D ( OpenOasis::CommImp::Spatial::Grid3D ) ~TimeBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer ) ~HeatConductionModel ( OpenOasis::SystHeats::HeatConductionModel )","title":"Class Member Functions"},{"location":"models/class_member_functions/#class-member-functions","text":"","title":"Class Member Functions"},{"location":"models/class_member_functions/#a","text":"At ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) Add ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Adjoint ( OpenOasis::CommImp::Numeric::Matrix ) AfterScheme ( OpenOasis::CommImp::Numeric::Solver ) AfterSolve ( OpenOasis::CommImp::Numeric::Solver ) AbsMax ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) AbsMin ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Avg ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Activate ( OpenOasis::CommImp::Spatial::Grid ) AddValues ( OpenOasis::CommImp::Temporal::TimeBuffer ) AddValuesToBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer ) AddListener ( OpenOasis::IBaseExchangeItem , OpenOasis::ILinkableComponent ) AddProvider ( OpenOasis::IInput ) AddAdaptedOutput ( OpenOasis::IOutput ) AddConsumer ( OpenOasis::IOutput ) AddTime ( OpenOasis::ITimeSet ) ApplyInputData ( OpenOasis::SystHeats::HeatConductionModel )","title":"a"},{"location":"models/class_member_functions/#b","text":"BeforeScheme ( OpenOasis::CommImp::Numeric::Solver ) BeforeSolve ( OpenOasis::CommImp::Numeric::Solver )","title":"b"},{"location":"models/class_member_functions/#c","text":"CompareTo ( OpenOasis::AdditionalControl::IComparable ) CollectExchangeItemMap ( OpenOasis::CommImp::IO::LinkLoader ) CollectIteratorGroups ( OpenOasis::CommImp::IO::LinkLoader ) CheckIds ( OpenOasis::CommImp::IO::MeshLoader ) Clean ( OpenOasis::CommImp::Numeric::Field ) Clear ( OpenOasis::CommImp::Numeric::Field ) Cols ( OpenOasis::CommImp::Numeric::Matrix ) Cross ( OpenOasis::CommImp::Numeric::Vector ) CalculateArea ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateCellCentroid ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateCellVolume ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateCentroid ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateFaceArea ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateFaceCentroid ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateFaceNormal ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateFacePerimeter ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateLength ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateNormal ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateVolume ( OpenOasis::CommImp::Spatial::GeoCalculator ) ChooseFoldedAxis ( OpenOasis::CommImp::Spatial::GeoCalculator ) CompareNodeOrder ( OpenOasis::CommImp::Spatial::GeoCalculator ) CalculateBoundaryCenterDistances ( OpenOasis::CommImp::Spatial::Grid ) CalculateCellDistances ( OpenOasis::CommImp::Spatial::Grid ) CalculateCellSurface ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CalculateDistance ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceCorrectionVector ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceDirector ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceIntersections ( OpenOasis::CommImp::Spatial::Grid ) CalculateFaceWeights ( OpenOasis::CommImp::Spatial::Grid ) CheckMesh ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CollectBoundaryFacesAndCells ( OpenOasis::CommImp::Spatial::Grid ) CollectCellNeighbors ( OpenOasis::CommImp::Spatial::Grid ) CollectCellsInZone ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) CollectCellsSharedFace ( OpenOasis::CommImp::Spatial::Grid ) CollectCellsSharedNode ( OpenOasis::CommImp::Spatial::Grid ) CollectFacesSharedNode ( OpenOasis::CommImp::Spatial::Grid ) CalculateIntersectionPoint ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateLengthOfLineInsidePolygon ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateLengthOfPolylineInsidePolygon ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateLineToPointDistance ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateMidpoint ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculatePointToPointDistance ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculatePolylineToPointDistance ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateSharedArea ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateSharedLength ( OpenOasis::CommImp::Spatial::XYGeoTools ) CalculateTriangleSharedArea ( OpenOasis::CommImp::Spatial::XYGeoTools ) CheckBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer ) ClearAfter ( OpenOasis::CommImp::Temporal::TimeBuffer ) ClearBefore ( OpenOasis::CommImp::Temporal::TimeBuffer ) Create ( OpenOasis::CommImp::Temporal::TimeBuffer ) CreateAdaptedOutput ( OpenOasis::IAdaptedOutputFactory ) ConvertFromByteStream ( OpenOasis::IByteStateConverter ) ConvertToByteStream ( OpenOasis::IByteStateConverter ) ClearState ( OpenOasis::IManageState ) CalculateUniformCoef ( OpenOasis::SystHeats::HeatConductionModel ) CreateCellOutput ( OpenOasis::SystHeats::HeatConductionModel )","title":"c"},{"location":"models/class_member_functions/#d","text":"DirichletBoundary ( OpenOasis::CommImp::Numeric::DirichletBoundary ) DoubleSparseMatrix ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) Data ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix ) Discretize ( OpenOasis::CommImp::Numeric::Laplacian , OpenOasis::CommImp::Numeric::Operator ) Determinant ( OpenOasis::CommImp::Numeric::Matrix ) Diagonal ( OpenOasis::CommImp::Numeric::Matrix ) DDot ( OpenOasis::CommImp::Numeric::Tensor ) Div ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Dot ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Dyadic ( OpenOasis::CommImp::Numeric::Vector ) DecrementModula ( OpenOasis::CommImp::Spatial::XYGeoTools )","title":"d"},{"location":"models/class_member_functions/#e","text":"Equals ( OpenOasis::CommImp::Spatial::Coordinate )","title":"e"},{"location":"models/class_member_functions/#f","text":"FvmSolver ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) Field ( OpenOasis::CommImp::Numeric::Field ) ForEach ( OpenOasis::CommImp::Numeric::Field ) FindTrianglePoints ( OpenOasis::CommImp::Spatial::XYGeoTools ) Finish ( OpenOasis::ILinkableComponent )","title":"f"},{"location":"models/class_member_functions/#g","text":"GetSpatialDefinition ( OpenOasis::AdditionalControl::ISpaceExtension ) GetCurrTime ( OpenOasis::AdditionalControl::ITimeExtension ) GetTimeExtent ( OpenOasis::AdditionalControl::ITimeExtension ) GenerateUniqueElementId ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentIds ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentInfo ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentInputs ( OpenOasis::CommImp::IO::LinkLoader ) GetComponentOutputs ( OpenOasis::CommImp::IO::LinkLoader ) GetInputProviders ( OpenOasis::CommImp::IO::LinkLoader ) GetIteratorConfigs ( OpenOasis::CommImp::IO::LinkLoader ) GetIteratorGroups ( OpenOasis::CommImp::IO::LinkLoader ) GetOutputConsumers ( OpenOasis::CommImp::IO::LinkLoader ) GenerateCellCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GenerateFaceCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetCellCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetCellFaces ( OpenOasis::CommImp::IO::MeshLoader ) GetFaceCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetFaceNodes ( OpenOasis::CommImp::IO::MeshLoader ) GetNodeCoordinates ( OpenOasis::CommImp::IO::MeshLoader ) GetPatches ( OpenOasis::CommImp::IO::MeshLoader ) GetZones ( OpenOasis::CommImp::IO::MeshLoader ) GetBoundaryCondition ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) GetType ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) GetColumnCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) GetRowCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) GetScalarSolutions ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) GetLinearEqs ( OpenOasis::CommImp::Numeric::Solver ) GetTensorSolutions ( OpenOasis::CommImp::Numeric::Solver ) GetVectorSolutions ( OpenOasis::CommImp::Numeric::Solver ) GetSource ( OpenOasis::CommImp::Numeric::Source ) GetCellNodeIndexes ( OpenOasis::CommImp::Spatial::GeoCalculator ) GetBoundaryCellIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetBoundaryCenterDistance ( OpenOasis::CommImp::Spatial::Grid ) GetBoundaryCenterDistances ( OpenOasis::CommImp::Spatial::Grid ) GetBoundaryFaceIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetCell ( OpenOasis::CommImp::Spatial::Grid ) GetCellCenterDistance ( OpenOasis::CommImp::Spatial::Grid ) GetCellCenterDistances ( OpenOasis::CommImp::Spatial::Grid ) GetCellWeightAtFace ( OpenOasis::CommImp::Spatial::Grid ) GetFace ( OpenOasis::CommImp::Spatial::Grid ) GetFaceCorrectionVector ( OpenOasis::CommImp::Spatial::Grid ) GetNode ( OpenOasis::CommImp::Spatial::Grid ) GetNumCells ( OpenOasis::CommImp::Spatial::Grid ) GetNumFaces ( OpenOasis::CommImp::Spatial::Grid ) GetNumNodes ( OpenOasis::CommImp::Spatial::Grid ) GetPatchFaceIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetPatchIds ( OpenOasis::CommImp::Spatial::Grid ) GetRawNumCells ( OpenOasis::CommImp::Spatial::Grid ) GetRawNumFaces ( OpenOasis::CommImp::Spatial::Grid ) GetRawNumNodes ( OpenOasis::CommImp::Spatial::Grid ) GetZoneCellIndexes ( OpenOasis::CommImp::Spatial::Grid ) GetZoneIds ( OpenOasis::CommImp::Spatial::Grid ) Grid ( OpenOasis::CommImp::Spatial::Grid ) Grid1D ( OpenOasis::CommImp::Spatial::Grid1D ) Grid2D ( OpenOasis::CommImp::Spatial::Grid2D ) Grid3D ( OpenOasis::CommImp::Spatial::Grid3D ) GetTriangulations ( OpenOasis::CommImp::Spatial::XYGeoTools ) GetLength ( OpenOasis::CommImp::Spatial::XYLine , OpenOasis::CommImp::Spatial::XYPolyline ) GetArea ( OpenOasis::CommImp::Spatial::XYPolygon ) GetLine ( OpenOasis::CommImp::Spatial::XYPolygon , OpenOasis::CommImp::Spatial::XYPolyline ) GetAllValues ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetDoExtendedDataVerification ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetDoExtrapolate ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetRelaxationFactor ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetTimeAt ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetTimeSet ( OpenOasis::CommImp::Temporal::TimeBuffer , OpenOasis::IBaseExchangeItem ) GetTimesCount ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetValueSet ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetValues ( OpenOasis::CommImp::Temporal::TimeBuffer , OpenOasis::IBaseExchangeItem ) GetValuesAt ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetValuesCount ( OpenOasis::CommImp::Temporal::TimeBuffer ) GetExchangeItem ( OpenOasis::ExchangeItemChangeEventArgs ) GetMessages ( OpenOasis::ExchangeItemChangeEventArgs , OpenOasis::LinkableComponentStatusChangeEventArgs ) GetAdaptee ( OpenOasis::IAdaptedOutput ) GetArguments ( OpenOasis::IAdaptedOutput , OpenOasis::ILinkableComponent ) GetAvailableAdaptedOutputIds ( OpenOasis::IAdaptedOutputFactory ) GetDefaultValue ( OpenOasis::IArgument ) GetPossibleValues ( OpenOasis::IArgument ) GetValue ( OpenOasis::IArgument , OpenOasis::ICategory , OpenOasis::IValueSet ) GetValueType ( OpenOasis::IArgument , OpenOasis::IValueDefinition ) GetComponent ( OpenOasis::IBaseExchangeItem ) GetElementSet ( OpenOasis::IBaseExchangeItem ) GetValueDefinition ( OpenOasis::IBaseExchangeItem , OpenOasis::IValueSet ) GetCaption ( OpenOasis::IDescribable ) GetDescription ( OpenOasis::IDescribable ) GetPower ( OpenOasis::IDimension ) GetElementId ( OpenOasis::IElementSet ) GetElementIndex ( OpenOasis::IElementSet ) GetElementType ( OpenOasis::IElementSet ) GetFaceCount ( OpenOasis::IElementSet ) GetFaceNodeIndices ( OpenOasis::IElementSet ) GetNodeCount ( OpenOasis::IElementSet ) GetNodeXCoordinate ( OpenOasis::IElementSet ) GetNodeYCoordinate ( OpenOasis::IElementSet ) GetNodeZCoordinate ( OpenOasis::IElementSet ) GetId ( OpenOasis::IIdentifiable ) GetProviders ( OpenOasis::IInput ) GetAdaptedOutputFactories ( OpenOasis::ILinkableComponent ) GetInputs ( OpenOasis::ILinkableComponent ) GetOutputs ( OpenOasis::ILinkableComponent ) GetStatus ( OpenOasis::ILinkableComponent ) GetAdaptedOutputs ( OpenOasis::IOutput ) GetConsumers ( OpenOasis::IOutput ) GetCategories ( OpenOasis::IQuality ) GetUnit ( OpenOasis::IQuantity ) GetElementCount ( OpenOasis::ISpatialDefinition ) GetSpatialReferenceSystem ( OpenOasis::ISpatialDefinition ) GetVersion ( OpenOasis::ISpatialDefinition ) GetDurationInDays ( OpenOasis::ITime ) GetTimeStamp ( OpenOasis::ITime ) GetOffsetFromUtcInHours ( OpenOasis::ITimeSet ) GetTimeHorizon ( OpenOasis::ITimeSet ) GetTimes ( OpenOasis::ITimeSet ) GetConversionFactorToSI ( OpenOasis::IUnit ) GetDimension ( OpenOasis::IUnit ) GetOffSetToSI ( OpenOasis::IUnit ) GetMissingDataValue ( OpenOasis::IValueDefinition ) GetElementValuesForTime ( OpenOasis::IValueSet ) GetIndexCount ( OpenOasis::IValueSet ) GetNumberOfIndices ( OpenOasis::IValueSet ) GetTimeSeriesValuesForElement ( OpenOasis::IValueSet ) GetLinkableComponent ( OpenOasis::LinkableComponentStatusChangeEventArgs ) GetNewStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) GetOldStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) GenerateCoeAndSrcMatrix ( OpenOasis::SystHeats::HeatConductionModel ) GetTempQuantity ( OpenOasis::SystHeats::HeatConductionModel )","title":"g"},{"location":"models/class_member_functions/#h","text":"HasDurations ( OpenOasis::ITimeSet ) HeatConductionModel ( OpenOasis::SystHeats::HeatConductionModel )","title":"h"},{"location":"models/class_member_functions/#i","text":"IsCellEmpty ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) Index ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index ) Initialize ( OpenOasis::CommImp::Numeric::Field , OpenOasis::IAdaptedOutput , OpenOasis::ILinkableComponent ) Invert ( OpenOasis::CommImp::Numeric::Matrix ) IsEqual ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Include ( OpenOasis::CommImp::Spatial::XYExtent ) IsContains ( OpenOasis::CommImp::Spatial::XYExtent ) IsOverlaps ( OpenOasis::CommImp::Spatial::XYExtent ) IncrementModula ( OpenOasis::CommImp::Spatial::XYGeoTools ) Intersect ( OpenOasis::CommImp::Spatial::XYGeoTools ) IntersectionPoint ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsLinesIntersected ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsPointInLine ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsPointInLineInterior ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsPointInPolygon ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsTriangleIntersected ( OpenOasis::CommImp::Spatial::XYGeoTools ) IsConvex ( OpenOasis::CommImp::Spatial::XYPolygon ) IsOptional ( OpenOasis::IArgument ) IsReadOnly ( OpenOasis::IArgument ) IsOrdered ( OpenOasis::IQuality ) IsValues2D ( OpenOasis::IValueSet ) InitializeArguments ( OpenOasis::SystHeats::HeatConductionModel ) InitializeInputs ( OpenOasis::SystHeats::HeatConductionModel ) InitializeOutputs ( OpenOasis::SystHeats::HeatConductionModel ) InitializeSpace ( OpenOasis::SystHeats::HeatConductionModel ) InitializeTime ( OpenOasis::SystHeats::HeatConductionModel ) IsIterationConverged ( OpenOasis::SystHeats::HeatConductionModel )","title":"i"},{"location":"models/class_member_functions/#k","text":"KeepCurrentState ( OpenOasis::IManageState )","title":"k"},{"location":"models/class_member_functions/#l","text":"LinkLoader ( OpenOasis::CommImp::IO::LinkLoader ) Load ( OpenOasis::CommImp::IO::LinkLoader , OpenOasis::CommImp::IO::MeshLoader ) LoadComponents ( OpenOasis::CommImp::IO::LinkLoader ) LoadLinks ( OpenOasis::CommImp::IO::LinkLoader ) LoadPipeline ( OpenOasis::CommImp::IO::LinkLoader ) LoadCells ( OpenOasis::CommImp::IO::MeshLoader ) LoadFaces ( OpenOasis::CommImp::IO::MeshLoader ) LoadNodes ( OpenOasis::CommImp::IO::MeshLoader ) LoadPatches ( OpenOasis::CommImp::IO::MeshLoader ) LoadZones ( OpenOasis::CommImp::IO::MeshLoader ) Laplacian ( OpenOasis::CommImp::Numeric::Laplacian ) Length ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector )","title":"l"},{"location":"models/class_member_functions/#m","text":"MeshLoader ( OpenOasis::CommImp::IO::MeshLoader ) Matrix ( OpenOasis::CommImp::Numeric::Matrix ) Max ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Min ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Mul ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) MapFromTimeSpansToTimeSpan ( OpenOasis::CommImp::Temporal::TimeBuffer ) MapFromTimeSpansToTimeStamp ( OpenOasis::CommImp::Temporal::TimeBuffer ) MapFromTimeStampsToTimeSpan ( OpenOasis::CommImp::Temporal::TimeBuffer ) MapFromTimeStampsToTimeStamp ( OpenOasis::CommImp::Temporal::TimeBuffer )","title":"m"},{"location":"models/class_member_functions/#n","text":"Normalize ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) NodesInCell ( OpenOasis::SystHeats::HeatConductionModel )","title":"n"},{"location":"models/class_member_functions/#o","text":"operator() ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::EqualFunc , OpenOasis::CommImp::Numeric::DoubleSparseMatrix::HashFunc , OpenOasis::CommImp::Numeric::DoubleSparseMatrix , OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator* ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator*= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Vector ) operator+ ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator+= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator- ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator-= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator= ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) operator!= ( OpenOasis::CommImp::Numeric::Vector ) operator& ( OpenOasis::CommImp::Numeric::Vector ) operator&= ( OpenOasis::CommImp::Numeric::Vector ) operator== ( OpenOasis::CommImp::Numeric::Vector ) operator^ ( OpenOasis::CommImp::Numeric::Vector ) OnValidate ( OpenOasis::SystHeats::HeatConductionModel )","title":"o"},{"location":"models/class_member_functions/#p","text":"Product ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) ParseDiffusionTerm ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) ParseConvectionTerm ( OpenOasis::CommImp::Numeric::Solver ) ParseSourceTerm ( OpenOasis::CommImp::Numeric::Solver ) ParseTimeDerivativeTerm ( OpenOasis::CommImp::Numeric::Solver ) Prepare ( OpenOasis::ILinkableComponent ) PerformTimestep ( OpenOasis::SystHeats::HeatConductionModel ) PrepareInputs ( OpenOasis::SystHeats::HeatConductionModel ) PrepareOutputs ( OpenOasis::SystHeats::HeatConductionModel ) PullInputs ( OpenOasis::SystHeats::HeatConductionModel )","title":"p"},{"location":"models/class_member_functions/#r","text":"Range ( OpenOasis::CommImp::Numeric::Field ) Resize ( OpenOasis::CommImp::Numeric::Field ) Rows ( OpenOasis::CommImp::Numeric::Matrix ) RefineCell ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) RelaxCell ( OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) Reset ( OpenOasis::CommImp::Temporal::TimeBuffer , OpenOasis::IBaseExchangeItem ) Refresh ( OpenOasis::IAdaptedOutput ) RemoveListener ( OpenOasis::IBaseExchangeItem , OpenOasis::ILinkableComponent ) RemoveProvider ( OpenOasis::IInput ) RestoreState ( OpenOasis::IManageState ) RemoveAdaptedOutput ( OpenOasis::IOutput ) RemoveConsumer ( OpenOasis::IOutput ) RemoveTime ( OpenOasis::ITimeSet ) RemoveValue ( OpenOasis::IValueSet )","title":"r"},{"location":"models/class_member_functions/#s","text":"SplitUniqueElementId ( OpenOasis::CommImp::IO::LinkLoader ) SetBoundaryFlux ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) SetBoundaryValue ( OpenOasis::CommImp::Numeric::Boundary , OpenOasis::CommImp::Numeric::DirichletBoundary ) SetColumnCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) SetRowCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) SetValue ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix , OpenOasis::IArgument ) SetBoundary ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) SetCoefficient ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Operator , OpenOasis::CommImp::Numeric::Solver ) SetInitialValue ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) Solve ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Solver ) SetAt ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Size ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Set ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) SetCol ( OpenOasis::CommImp::Numeric::Matrix ) SetDiagonal ( OpenOasis::CommImp::Numeric::Matrix ) SetRow ( OpenOasis::CommImp::Numeric::Matrix ) SetUnit ( OpenOasis::CommImp::Numeric::Matrix ) SetZero ( OpenOasis::CommImp::Numeric::Matrix ) Sub ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) Sum ( OpenOasis::CommImp::Numeric::Matrix , OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) SetBoundaryCondition ( OpenOasis::CommImp::Numeric::Operator ) ScalarField ( OpenOasis::CommImp::Numeric::ScalarField ) Scheme ( OpenOasis::CommImp::Numeric::Solver ) SortFaceNodes ( OpenOasis::CommImp::Spatial::GeoCalculator ) SortNodes ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::Grid ) SetDoExtendedDataVerification ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetDoExtrapolate ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetOrAddValues ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetRelaxationFactor ( OpenOasis::CommImp::Temporal::TimeBuffer ) SetExchangeItem ( OpenOasis::ExchangeItemChangeEventArgs ) SetMessages ( OpenOasis::ExchangeItemChangeEventArgs , OpenOasis::LinkableComponentStatusChangeEventArgs ) SetAdaptee ( OpenOasis::IAdaptedOutput ) SetElementSet ( OpenOasis::IBaseExchangeItem ) SetTimeSet ( OpenOasis::IBaseExchangeItem ) SetValues ( OpenOasis::IBaseExchangeItem ) SetCaption ( OpenOasis::IDescribable ) SetDescription ( OpenOasis::IDescribable ) SetPower ( OpenOasis::IDimension ) SetElementValuesForTime ( OpenOasis::IValueSet ) SetOrAddValue ( OpenOasis::IValueSet ) SetTimeSeriesValuesForElement ( OpenOasis::IValueSet ) SetLinkableComponent ( OpenOasis::LinkableComponentStatusChangeEventArgs ) SetNewStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) SetOldStatus ( OpenOasis::LinkableComponentStatusChangeEventArgs ) SaveResult ( OpenOasis::SystHeats::HeatConductionModel )","title":"s"},{"location":"models/class_member_functions/#t","text":"Type ( OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Spatial::Grid , OpenOasis::CommImp::Spatial::Grid1D , OpenOasis::CommImp::Spatial::Grid2D , OpenOasis::CommImp::Spatial::Grid3D ) Trace ( OpenOasis::CommImp::Numeric::Matrix ) Transpose ( OpenOasis::CommImp::Numeric::Matrix ) Tensor ( OpenOasis::CommImp::Numeric::Tensor ) TensorField ( OpenOasis::CommImp::Numeric::TensorField ) ToVector ( OpenOasis::CommImp::Spatial::GeoCalculator ) TimeBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer )","title":"t"},{"location":"models/class_member_functions/#u","text":"Unit ( OpenOasis::CommImp::Numeric::Matrix ) Update ( OpenOasis::ILinkableComponent ) UpdateOutputs ( OpenOasis::SystHeats::HeatConductionModel )","title":"u"},{"location":"models/class_member_functions/#v","text":"Vector ( OpenOasis::CommImp::Numeric::Vector ) VectorField ( OpenOasis::CommImp::Numeric::VectorField ) Validate ( OpenOasis::CommImp::Spatial::XYPolygon , OpenOasis::CommImp::Spatial::XYPolyline , OpenOasis::ILinkableComponent )","title":"v"},{"location":"models/class_member_functions/#x","text":"XYExtent ( OpenOasis::CommImp::Spatial::XYExtent ) XYLine ( OpenOasis::CommImp::Spatial::XYLine ) XYPoint ( OpenOasis::CommImp::Spatial::XYPoint ) XYPolygon ( OpenOasis::CommImp::Spatial::XYPolygon ) XYPolyline ( OpenOasis::CommImp::Spatial::XYPolyline )","title":"x"},{"location":"models/class_member_functions/#z","text":"Zero ( OpenOasis::CommImp::Numeric::Matrix )","title":"z"},{"location":"models/class_member_functions/#_1","text":"~MeshLoader ( OpenOasis::CommImp::IO::MeshLoader ) ~FvmSolver ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) ~Field ( OpenOasis::CommImp::Numeric::Field ) ~Laplacian ( OpenOasis::CommImp::Numeric::Laplacian ) ~Operator ( OpenOasis::CommImp::Numeric::Operator ) ~ScalarField ( OpenOasis::CommImp::Numeric::ScalarField ) ~TensorField ( OpenOasis::CommImp::Numeric::TensorField ) ~Vector ( OpenOasis::CommImp::Numeric::Vector ) ~VectorField ( OpenOasis::CommImp::Numeric::VectorField ) ~Grid ( OpenOasis::CommImp::Spatial::Grid ) ~Grid1D ( OpenOasis::CommImp::Spatial::Grid1D ) ~Grid2D ( OpenOasis::CommImp::Spatial::Grid2D ) ~Grid3D ( OpenOasis::CommImp::Spatial::Grid3D ) ~TimeBuffer ( OpenOasis::CommImp::Temporal::TimeBuffer ) ~HeatConductionModel ( OpenOasis::SystHeats::HeatConductionModel )","title":"~"},{"location":"models/class_member_variables/","text":"Class Member Variables \u00b6 a \u00b6 area ( OpenOasis::CommImp::Spatial::Face ) c \u00b6 centroid ( OpenOasis::CommImp::Spatial::Cell , OpenOasis::CommImp::Spatial::Face ) cellIndexes ( OpenOasis::CommImp::Spatial::Face , OpenOasis::CommImp::Spatial::Node ) cellSides ( OpenOasis::CommImp::Spatial::Face ) cells ( OpenOasis::CommImp::Spatial::Mesh ) coor ( OpenOasis::CommImp::Spatial::Node ) e \u00b6 EPSILON ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::XYGeoTools ) f \u00b6 flux ( OpenOasis::CommImp::Numeric::BoundaryCondition ) faceIndexes ( OpenOasis::CommImp::Spatial::Cell , OpenOasis::CommImp::Spatial::Node ) faces ( OpenOasis::CommImp::Spatial::Mesh ) m \u00b6 mComps ( OpenOasis::CommImp::IO::LinkLoader ) mInps ( OpenOasis::CommImp::IO::LinkLoader ) mInputProviders ( OpenOasis::CommImp::IO::LinkLoader ) mIterConfigs ( OpenOasis::CommImp::IO::LinkLoader ) mIterGroups ( OpenOasis::CommImp::IO::LinkLoader ) mLinkFile ( OpenOasis::CommImp::IO::LinkLoader ) mLoader ( OpenOasis::CommImp::IO::LinkLoader ) mOutputConsumers ( OpenOasis::CommImp::IO::LinkLoader ) mOuts ( OpenOasis::CommImp::IO::LinkLoader ) mCellCoords ( OpenOasis::CommImp::IO::MeshLoader ) mCellFaces ( OpenOasis::CommImp::IO::MeshLoader ) mFaceCoords ( OpenOasis::CommImp::IO::MeshLoader ) mFaceNodes ( OpenOasis::CommImp::IO::MeshLoader ) mMeshDir ( OpenOasis::CommImp::IO::MeshLoader ) mNodeCoords ( OpenOasis::CommImp::IO::MeshLoader ) mPatchFaces ( OpenOasis::CommImp::IO::MeshLoader ) mZoneFaces ( OpenOasis::CommImp::IO::MeshLoader ) mData ( OpenOasis::CommImp::Numeric::DirichletBoundary , OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix ) mCol ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index ) mRow ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index ) mColumnCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) mRowCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) mValues ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix , OpenOasis::CommImp::Temporal::TimeBuffer ) mBoundaries ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mCoeffHeat ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mCoeffMat ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mGrid ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Laplacian , OpenOasis::SystHeats::HeatConductionModel ) mInitValue ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mRhs ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mTemps ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mDefault ( OpenOasis::CommImp::Numeric::Field ) mDomain ( OpenOasis::CommImp::Numeric::Field ) mType ( OpenOasis::CommImp::Numeric::Field ) mCols ( OpenOasis::CommImp::Numeric::Matrix ) mRows ( OpenOasis::CommImp::Numeric::Matrix ) mCoefficient ( OpenOasis::CommImp::Numeric::Operator ) mScalarCoeffs ( OpenOasis::CommImp::Numeric::Operator ) mTensorCoeffs ( OpenOasis::CommImp::Numeric::Operator ) mVectorCoeffs ( OpenOasis::CommImp::Numeric::Operator ) mboundaries ( OpenOasis::CommImp::Numeric::Operator ) mElement ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) mBoundaryCells ( OpenOasis::CommImp::Spatial::Grid ) mBoundaryCenterDists ( OpenOasis::CommImp::Spatial::Grid ) mBoundaryFaces ( OpenOasis::CommImp::Spatial::Grid ) mCellFaceWeight ( OpenOasis::CommImp::Spatial::Grid ) mCenterDists ( OpenOasis::CommImp::Spatial::Grid ) mFaceCorrVecs ( OpenOasis::CommImp::Spatial::Grid ) mFaceIntersection ( OpenOasis::CommImp::Spatial::Grid ) mMesh ( OpenOasis::CommImp::Spatial::Grid ) mPatches ( OpenOasis::CommImp::Spatial::Grid ) mRawCellsNum ( OpenOasis::CommImp::Spatial::Grid ) mRawFacesNum ( OpenOasis::CommImp::Spatial::Grid ) mRawNodesNum ( OpenOasis::CommImp::Spatial::Grid ) mZoneCells ( OpenOasis::CommImp::Spatial::Grid ) mZones ( OpenOasis::CommImp::Spatial::Grid ) mDoExtendedDataVerification ( OpenOasis::CommImp::Temporal::TimeBuffer ) mDoExtrapolate ( OpenOasis::CommImp::Temporal::TimeBuffer ) mLastBufferSizeMessageCounter ( OpenOasis::CommImp::Temporal::TimeBuffer ) mRelaxationFactor ( OpenOasis::CommImp::Temporal::TimeBuffer ) mTimes ( OpenOasis::CommImp::Temporal::TimeBuffer ) mBoundPatches ( OpenOasis::SystHeats::HeatConductionModel ) mCellOutputs ( OpenOasis::SystHeats::HeatConductionModel ) mEigenSolver ( OpenOasis::SystHeats::HeatConductionModel ) mEnd ( OpenOasis::SystHeats::HeatConductionModel ) mK ( OpenOasis::SystHeats::HeatConductionModel ) mOutputDir ( OpenOasis::SystHeats::HeatConductionModel ) mOutputVars ( OpenOasis::SystHeats::HeatConductionModel ) mPatchBounds ( OpenOasis::SystHeats::HeatConductionModel ) mSolver ( OpenOasis::SystHeats::HeatConductionModel ) mStart ( OpenOasis::SystHeats::HeatConductionModel ) mT0 ( OpenOasis::SystHeats::HeatConductionModel ) mT0file ( OpenOasis::SystHeats::HeatConductionModel ) mTaskFile ( OpenOasis::SystHeats::HeatConductionModel ) mTempValues ( OpenOasis::SystHeats::HeatConductionModel ) n \u00b6 neighbors ( OpenOasis::CommImp::Spatial::Cell ) nodeIndexes ( OpenOasis::CommImp::Spatial::Face ) normal ( OpenOasis::CommImp::Spatial::Face ) nodes ( OpenOasis::CommImp::Spatial::Mesh ) p \u00b6 perimeter ( OpenOasis::CommImp::Spatial::Face ) point1 ( OpenOasis::CommImp::Spatial::XYLine ) point2 ( OpenOasis::CommImp::Spatial::XYLine ) points ( OpenOasis::CommImp::Spatial::XYPolygon , OpenOasis::CommImp::Spatial::XYPolyline ) s \u00b6 subCells ( OpenOasis::CommImp::Spatial::Cell ) surface ( OpenOasis::CommImp::Spatial::Cell ) sExchangeableObj ( OpenOasis::SystHeats::HeatConductionModel ) sExchangeableStates ( OpenOasis::SystHeats::HeatConductionModel ) t \u00b6 type ( OpenOasis::CommImp::Numeric::BoundaryCondition ) v \u00b6 value ( OpenOasis::CommImp::Numeric::BoundaryCondition ) volume ( OpenOasis::CommImp::Spatial::Cell ) x \u00b6 x ( OpenOasis::CommImp::Spatial::Coordinate , OpenOasis::CommImp::Spatial::XYPoint ) xMax ( OpenOasis::CommImp::Spatial::XYExtent ) xMin ( OpenOasis::CommImp::Spatial::XYExtent ) y \u00b6 y ( OpenOasis::CommImp::Spatial::Coordinate , OpenOasis::CommImp::Spatial::XYPoint ) yMax ( OpenOasis::CommImp::Spatial::XYExtent ) yMin ( OpenOasis::CommImp::Spatial::XYExtent ) z \u00b6 z ( OpenOasis::CommImp::Spatial::Coordinate )","title":"Class Member Variables"},{"location":"models/class_member_variables/#class-member-variables","text":"","title":"Class Member Variables"},{"location":"models/class_member_variables/#a","text":"area ( OpenOasis::CommImp::Spatial::Face )","title":"a"},{"location":"models/class_member_variables/#c","text":"centroid ( OpenOasis::CommImp::Spatial::Cell , OpenOasis::CommImp::Spatial::Face ) cellIndexes ( OpenOasis::CommImp::Spatial::Face , OpenOasis::CommImp::Spatial::Node ) cellSides ( OpenOasis::CommImp::Spatial::Face ) cells ( OpenOasis::CommImp::Spatial::Mesh ) coor ( OpenOasis::CommImp::Spatial::Node )","title":"c"},{"location":"models/class_member_variables/#e","text":"EPSILON ( OpenOasis::CommImp::Spatial::GeoCalculator , OpenOasis::CommImp::Spatial::XYGeoTools )","title":"e"},{"location":"models/class_member_variables/#f","text":"flux ( OpenOasis::CommImp::Numeric::BoundaryCondition ) faceIndexes ( OpenOasis::CommImp::Spatial::Cell , OpenOasis::CommImp::Spatial::Node ) faces ( OpenOasis::CommImp::Spatial::Mesh )","title":"f"},{"location":"models/class_member_variables/#m","text":"mComps ( OpenOasis::CommImp::IO::LinkLoader ) mInps ( OpenOasis::CommImp::IO::LinkLoader ) mInputProviders ( OpenOasis::CommImp::IO::LinkLoader ) mIterConfigs ( OpenOasis::CommImp::IO::LinkLoader ) mIterGroups ( OpenOasis::CommImp::IO::LinkLoader ) mLinkFile ( OpenOasis::CommImp::IO::LinkLoader ) mLoader ( OpenOasis::CommImp::IO::LinkLoader ) mOutputConsumers ( OpenOasis::CommImp::IO::LinkLoader ) mOuts ( OpenOasis::CommImp::IO::LinkLoader ) mCellCoords ( OpenOasis::CommImp::IO::MeshLoader ) mCellFaces ( OpenOasis::CommImp::IO::MeshLoader ) mFaceCoords ( OpenOasis::CommImp::IO::MeshLoader ) mFaceNodes ( OpenOasis::CommImp::IO::MeshLoader ) mMeshDir ( OpenOasis::CommImp::IO::MeshLoader ) mNodeCoords ( OpenOasis::CommImp::IO::MeshLoader ) mPatchFaces ( OpenOasis::CommImp::IO::MeshLoader ) mZoneFaces ( OpenOasis::CommImp::IO::MeshLoader ) mData ( OpenOasis::CommImp::Numeric::DirichletBoundary , OpenOasis::CommImp::Numeric::Field , OpenOasis::CommImp::Numeric::Matrix ) mCol ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index ) mRow ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix::Index ) mColumnCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) mRowCount ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix ) mValues ( OpenOasis::CommImp::Numeric::DoubleSparseMatrix , OpenOasis::CommImp::Temporal::TimeBuffer ) mBoundaries ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mCoeffHeat ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mCoeffMat ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mGrid ( OpenOasis::CommImp::Numeric::FVM::FvmSolver , OpenOasis::CommImp::Numeric::Laplacian , OpenOasis::SystHeats::HeatConductionModel ) mInitValue ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mRhs ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mTemps ( OpenOasis::CommImp::Numeric::FVM::FvmSolver ) mDefault ( OpenOasis::CommImp::Numeric::Field ) mDomain ( OpenOasis::CommImp::Numeric::Field ) mType ( OpenOasis::CommImp::Numeric::Field ) mCols ( OpenOasis::CommImp::Numeric::Matrix ) mRows ( OpenOasis::CommImp::Numeric::Matrix ) mCoefficient ( OpenOasis::CommImp::Numeric::Operator ) mScalarCoeffs ( OpenOasis::CommImp::Numeric::Operator ) mTensorCoeffs ( OpenOasis::CommImp::Numeric::Operator ) mVectorCoeffs ( OpenOasis::CommImp::Numeric::Operator ) mboundaries ( OpenOasis::CommImp::Numeric::Operator ) mElement ( OpenOasis::CommImp::Numeric::Tensor , OpenOasis::CommImp::Numeric::Vector ) mBoundaryCells ( OpenOasis::CommImp::Spatial::Grid ) mBoundaryCenterDists ( OpenOasis::CommImp::Spatial::Grid ) mBoundaryFaces ( OpenOasis::CommImp::Spatial::Grid ) mCellFaceWeight ( OpenOasis::CommImp::Spatial::Grid ) mCenterDists ( OpenOasis::CommImp::Spatial::Grid ) mFaceCorrVecs ( OpenOasis::CommImp::Spatial::Grid ) mFaceIntersection ( OpenOasis::CommImp::Spatial::Grid ) mMesh ( OpenOasis::CommImp::Spatial::Grid ) mPatches ( OpenOasis::CommImp::Spatial::Grid ) mRawCellsNum ( OpenOasis::CommImp::Spatial::Grid ) mRawFacesNum ( OpenOasis::CommImp::Spatial::Grid ) mRawNodesNum ( OpenOasis::CommImp::Spatial::Grid ) mZoneCells ( OpenOasis::CommImp::Spatial::Grid ) mZones ( OpenOasis::CommImp::Spatial::Grid ) mDoExtendedDataVerification ( OpenOasis::CommImp::Temporal::TimeBuffer ) mDoExtrapolate ( OpenOasis::CommImp::Temporal::TimeBuffer ) mLastBufferSizeMessageCounter ( OpenOasis::CommImp::Temporal::TimeBuffer ) mRelaxationFactor ( OpenOasis::CommImp::Temporal::TimeBuffer ) mTimes ( OpenOasis::CommImp::Temporal::TimeBuffer ) mBoundPatches ( OpenOasis::SystHeats::HeatConductionModel ) mCellOutputs ( OpenOasis::SystHeats::HeatConductionModel ) mEigenSolver ( OpenOasis::SystHeats::HeatConductionModel ) mEnd ( OpenOasis::SystHeats::HeatConductionModel ) mK ( OpenOasis::SystHeats::HeatConductionModel ) mOutputDir ( OpenOasis::SystHeats::HeatConductionModel ) mOutputVars ( OpenOasis::SystHeats::HeatConductionModel ) mPatchBounds ( OpenOasis::SystHeats::HeatConductionModel ) mSolver ( OpenOasis::SystHeats::HeatConductionModel ) mStart ( OpenOasis::SystHeats::HeatConductionModel ) mT0 ( OpenOasis::SystHeats::HeatConductionModel ) mT0file ( OpenOasis::SystHeats::HeatConductionModel ) mTaskFile ( OpenOasis::SystHeats::HeatConductionModel ) mTempValues ( OpenOasis::SystHeats::HeatConductionModel )","title":"m"},{"location":"models/class_member_variables/#n","text":"neighbors ( OpenOasis::CommImp::Spatial::Cell ) nodeIndexes ( OpenOasis::CommImp::Spatial::Face ) normal ( OpenOasis::CommImp::Spatial::Face ) nodes ( OpenOasis::CommImp::Spatial::Mesh )","title":"n"},{"location":"models/class_member_variables/#p","text":"perimeter ( OpenOasis::CommImp::Spatial::Face ) point1 ( OpenOasis::CommImp::Spatial::XYLine ) point2 ( OpenOasis::CommImp::Spatial::XYLine ) points ( OpenOasis::CommImp::Spatial::XYPolygon , OpenOasis::CommImp::Spatial::XYPolyline )","title":"p"},{"location":"models/class_member_variables/#s","text":"subCells ( OpenOasis::CommImp::Spatial::Cell ) surface ( OpenOasis::CommImp::Spatial::Cell ) sExchangeableObj ( OpenOasis::SystHeats::HeatConductionModel ) sExchangeableStates ( OpenOasis::SystHeats::HeatConductionModel )","title":"s"},{"location":"models/class_member_variables/#t","text":"type ( OpenOasis::CommImp::Numeric::BoundaryCondition )","title":"t"},{"location":"models/class_member_variables/#v","text":"value ( OpenOasis::CommImp::Numeric::BoundaryCondition ) volume ( OpenOasis::CommImp::Spatial::Cell )","title":"v"},{"location":"models/class_member_variables/#x","text":"x ( OpenOasis::CommImp::Spatial::Coordinate , OpenOasis::CommImp::Spatial::XYPoint ) xMax ( OpenOasis::CommImp::Spatial::XYExtent ) xMin ( OpenOasis::CommImp::Spatial::XYExtent )","title":"x"},{"location":"models/class_member_variables/#y","text":"y ( OpenOasis::CommImp::Spatial::Coordinate , OpenOasis::CommImp::Spatial::XYPoint ) yMax ( OpenOasis::CommImp::Spatial::XYExtent ) yMin ( OpenOasis::CommImp::Spatial::XYExtent )","title":"y"},{"location":"models/class_member_variables/#z","text":"z ( OpenOasis::CommImp::Spatial::Coordinate )","title":"z"},{"location":"models/class_member_typedefs/","text":"Class Member Typedefs \u00b6 c \u00b6 ComponentInfo ( OpenOasis::CommImp::IO::LinkLoader ) e \u00b6 ElementInfo ( OpenOasis::CommImp::IO::LinkLoader ) l \u00b6 ListenFunc ( OpenOasis::IBaseExchangeItem , OpenOasis::ILinkableComponent )","title":"Class Member Typedefs"},{"location":"models/class_member_typedefs/#class-member-typedefs","text":"","title":"Class Member Typedefs"},{"location":"models/class_member_typedefs/#c","text":"ComponentInfo ( OpenOasis::CommImp::IO::LinkLoader )","title":"c"},{"location":"models/class_member_typedefs/#e","text":"ElementInfo ( OpenOasis::CommImp::IO::LinkLoader )","title":"e"},{"location":"models/class_member_typedefs/#l","text":"ListenFunc ( OpenOasis::IBaseExchangeItem , OpenOasis::ILinkableComponent )","title":"l"},{"location":"models/class_member_enums/","text":"Class Member Enums \u00b6 Nothing related to Class Member Enums found.","title":"Class Member Enums"},{"location":"models/class_member_enums/#class-member-enums","text":"Nothing related to Class Member Enums found.","title":"Class Member Enums"},{"location":"models/namespace_members/","text":"Namespace Members \u00b6 d \u00b6 DimensionBase ( OpenOasis ) DEFAULT_FILE_NUM ( OpenOasis::CommImp::IO ) DEFAULT_LOGGER_ID ( OpenOasis::CommImp::IO ) DEFAULT_LOGGER_SIZE ( OpenOasis::CommImp::IO ) e \u00b6 ElementType ( OpenOasis ) f \u00b6 FieldDomain ( OpenOasis::CommImp::Numeric ) FieldType ( OpenOasis::CommImp::Numeric ) g \u00b6 GetLogger ( OpenOasis::CommImp::IO ) l \u00b6 LinkableComponentStatus ( OpenOasis ) logger ( OpenOasis::CommImp::IO ) LinearEqs ( OpenOasis::CommImp::Numeric ) m \u00b6 mtx ( OpenOasis::CommImp::IO ) o \u00b6 OasisLoggers ( OpenOasis::CommImp::IO ) s \u00b6 ScalarFieldDbl ( OpenOasis::CommImp::Numeric ) ScalarFieldFp ( OpenOasis::CommImp::Numeric ) ScalarFieldInt ( OpenOasis::CommImp::Numeric ) SolverStatus ( OpenOasis::CommImp::Numeric ) t \u00b6 TensorFieldDbl ( OpenOasis::CommImp::Numeric ) TensorFieldFp ( OpenOasis::CommImp::Numeric ) TensorFieldInt ( OpenOasis::CommImp::Numeric ) v \u00b6 VectorFieldDbl2D ( OpenOasis::CommImp::Numeric ) VectorFieldDbl3D ( OpenOasis::CommImp::Numeric ) VectorFieldFp ( OpenOasis::CommImp::Numeric ) VectorFieldInt2D ( OpenOasis::CommImp::Numeric ) VectorFieldInt3D ( OpenOasis::CommImp::Numeric )","title":"Namespace Members"},{"location":"models/namespace_members/#namespace-members","text":"","title":"Namespace Members"},{"location":"models/namespace_members/#d","text":"DimensionBase ( OpenOasis ) DEFAULT_FILE_NUM ( OpenOasis::CommImp::IO ) DEFAULT_LOGGER_ID ( OpenOasis::CommImp::IO ) DEFAULT_LOGGER_SIZE ( OpenOasis::CommImp::IO )","title":"d"},{"location":"models/namespace_members/#e","text":"ElementType ( OpenOasis )","title":"e"},{"location":"models/namespace_members/#f","text":"FieldDomain ( OpenOasis::CommImp::Numeric ) FieldType ( OpenOasis::CommImp::Numeric )","title":"f"},{"location":"models/namespace_members/#g","text":"GetLogger ( OpenOasis::CommImp::IO )","title":"g"},{"location":"models/namespace_members/#l","text":"LinkableComponentStatus ( OpenOasis ) logger ( OpenOasis::CommImp::IO ) LinearEqs ( OpenOasis::CommImp::Numeric )","title":"l"},{"location":"models/namespace_members/#m","text":"mtx ( OpenOasis::CommImp::IO )","title":"m"},{"location":"models/namespace_members/#o","text":"OasisLoggers ( OpenOasis::CommImp::IO )","title":"o"},{"location":"models/namespace_members/#s","text":"ScalarFieldDbl ( OpenOasis::CommImp::Numeric ) ScalarFieldFp ( OpenOasis::CommImp::Numeric ) ScalarFieldInt ( OpenOasis::CommImp::Numeric ) SolverStatus ( OpenOasis::CommImp::Numeric )","title":"s"},{"location":"models/namespace_members/#t","text":"TensorFieldDbl ( OpenOasis::CommImp::Numeric ) TensorFieldFp ( OpenOasis::CommImp::Numeric ) TensorFieldInt ( OpenOasis::CommImp::Numeric )","title":"t"},{"location":"models/namespace_members/#v","text":"VectorFieldDbl2D ( OpenOasis::CommImp::Numeric ) VectorFieldDbl3D ( OpenOasis::CommImp::Numeric ) VectorFieldFp ( OpenOasis::CommImp::Numeric ) VectorFieldInt2D ( OpenOasis::CommImp::Numeric ) VectorFieldInt3D ( OpenOasis::CommImp::Numeric )","title":"v"},{"location":"models/namespace_member_functions/","text":"Namespace Member Functions \u00b6 g \u00b6 GetLogger ( OpenOasis::CommImp::IO )","title":"Namespace Member Functions"},{"location":"models/namespace_member_functions/#namespace-member-functions","text":"","title":"Namespace Member Functions"},{"location":"models/namespace_member_functions/#g","text":"GetLogger ( OpenOasis::CommImp::IO )","title":"g"},{"location":"models/namespace_member_variables/","text":"Namespace Member Variables \u00b6 d \u00b6 DEFAULT_FILE_NUM ( OpenOasis::CommImp::IO ) DEFAULT_LOGGER_ID ( OpenOasis::CommImp::IO ) DEFAULT_LOGGER_SIZE ( OpenOasis::CommImp::IO ) l \u00b6 logger ( OpenOasis::CommImp::IO ) m \u00b6 mtx ( OpenOasis::CommImp::IO ) o \u00b6 OasisLoggers ( OpenOasis::CommImp::IO )","title":"Namespace Member Variables"},{"location":"models/namespace_member_variables/#namespace-member-variables","text":"","title":"Namespace Member Variables"},{"location":"models/namespace_member_variables/#d","text":"DEFAULT_FILE_NUM ( OpenOasis::CommImp::IO ) DEFAULT_LOGGER_ID ( OpenOasis::CommImp::IO ) DEFAULT_LOGGER_SIZE ( OpenOasis::CommImp::IO )","title":"d"},{"location":"models/namespace_member_variables/#l","text":"logger ( OpenOasis::CommImp::IO )","title":"l"},{"location":"models/namespace_member_variables/#m","text":"mtx ( OpenOasis::CommImp::IO )","title":"m"},{"location":"models/namespace_member_variables/#o","text":"OasisLoggers ( OpenOasis::CommImp::IO )","title":"o"},{"location":"models/namespace_member_typedefs/","text":"Namespace Member Typedefs \u00b6 l \u00b6 LinearEqs ( OpenOasis::CommImp::Numeric ) s \u00b6 ScalarFieldDbl ( OpenOasis::CommImp::Numeric ) ScalarFieldFp ( OpenOasis::CommImp::Numeric ) ScalarFieldInt ( OpenOasis::CommImp::Numeric ) t \u00b6 TensorFieldDbl ( OpenOasis::CommImp::Numeric ) TensorFieldFp ( OpenOasis::CommImp::Numeric ) TensorFieldInt ( OpenOasis::CommImp::Numeric ) v \u00b6 VectorFieldDbl2D ( OpenOasis::CommImp::Numeric ) VectorFieldDbl3D ( OpenOasis::CommImp::Numeric ) VectorFieldFp ( OpenOasis::CommImp::Numeric ) VectorFieldInt2D ( OpenOasis::CommImp::Numeric ) VectorFieldInt3D ( OpenOasis::CommImp::Numeric )","title":"Namespace Member Typedefs"},{"location":"models/namespace_member_typedefs/#namespace-member-typedefs","text":"","title":"Namespace Member Typedefs"},{"location":"models/namespace_member_typedefs/#l","text":"LinearEqs ( OpenOasis::CommImp::Numeric )","title":"l"},{"location":"models/namespace_member_typedefs/#s","text":"ScalarFieldDbl ( OpenOasis::CommImp::Numeric ) ScalarFieldFp ( OpenOasis::CommImp::Numeric ) ScalarFieldInt ( OpenOasis::CommImp::Numeric )","title":"s"},{"location":"models/namespace_member_typedefs/#t","text":"TensorFieldDbl ( OpenOasis::CommImp::Numeric ) TensorFieldFp ( OpenOasis::CommImp::Numeric ) TensorFieldInt ( OpenOasis::CommImp::Numeric )","title":"t"},{"location":"models/namespace_member_typedefs/#v","text":"VectorFieldDbl2D ( OpenOasis::CommImp::Numeric ) VectorFieldDbl3D ( OpenOasis::CommImp::Numeric ) VectorFieldFp ( OpenOasis::CommImp::Numeric ) VectorFieldInt2D ( OpenOasis::CommImp::Numeric ) VectorFieldInt3D ( OpenOasis::CommImp::Numeric )","title":"v"},{"location":"models/namespace_member_enums/","text":"Namespace Member Enums \u00b6 d \u00b6 DimensionBase ( OpenOasis ) e \u00b6 ElementType ( OpenOasis ) f \u00b6 FieldDomain ( OpenOasis::CommImp::Numeric ) FieldType ( OpenOasis::CommImp::Numeric ) l \u00b6 LinkableComponentStatus ( OpenOasis ) s \u00b6 SolverStatus ( OpenOasis::CommImp::Numeric )","title":"Namespace Member Enums"},{"location":"models/namespace_member_enums/#namespace-member-enums","text":"","title":"Namespace Member Enums"},{"location":"models/namespace_member_enums/#d","text":"DimensionBase ( OpenOasis )","title":"d"},{"location":"models/namespace_member_enums/#e","text":"ElementType ( OpenOasis )","title":"e"},{"location":"models/namespace_member_enums/#f","text":"FieldDomain ( OpenOasis::CommImp::Numeric ) FieldType ( OpenOasis::CommImp::Numeric )","title":"f"},{"location":"models/namespace_member_enums/#l","text":"LinkableComponentStatus ( OpenOasis )","title":"l"},{"location":"models/namespace_member_enums/#s","text":"SolverStatus ( OpenOasis::CommImp::Numeric )","title":"s"},{"location":"models/functions/","text":"Functions \u00b6 Nothing related to Functions found.","title":"Functions"},{"location":"models/functions/#functions","text":"Nothing related to Functions found.","title":"Functions"},{"location":"models/macros/","text":"Macros \u00b6 Nothing related to Macros found.","title":"Macros"},{"location":"models/macros/#macros","text":"Nothing related to Macros found.","title":"Macros"},{"location":"models/variables/","text":"Variables \u00b6 Nothing related to Variables found.","title":"Variables"},{"location":"models/variables/#variables","text":"Nothing related to Variables found.","title":"Variables"},{"location":"models/links/","text":"Related Pages Modules Class List Namespace ListNamespace List Namespace Members Namespace Member Functions Namespace Member Variables Namespace Member Typedefs Namespace Member Enumerations Class Index Class Hierarchy Class Members Class Member Functions Class Member Variables Class Member Typedefs Class Member Enumerations Files File Variables File Functions File Macros","title":"Links"}]}